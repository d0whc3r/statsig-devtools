// This file is auto-generated by @hey-api/openapi-ts

export type AlertSchemaDto = {
  /**
   * ID of the alert
   */
  id: string
  /**
   * Name of the alert
   */
  name: string
  /**
   * Type of alert
   */
  alertType: 'threshold'
  /**
   * List of metrics associated with this alert
   */
  metrics: {
    [key: string]: unknown
  }
  /**
   * Metric groupbys
   */
  metricGroupBys: {
    [key: string]: unknown
  }
  /**
   * Formula for the alert
   */
  formula?: string
  /**
   * Alert message
   */
  message: string
  creatorID?: string
  companyID: string
  /**
   * Priority of this alert
   */
  priority: 'P0' | 'P1' | 'P2' | 'P3' | 'P4' | 'P5'
  alertThreshold: number
  warningThreshold?: number
  /**
   * How far back and how frequently a metric should be checked, in milliseconds
   */
  windowMs: number
  /**
   * Condition under which a metric change triggers an alert in milliseconds
   */
  condition: 'greater' | 'greater_or_equal' | 'less' | 'less_or_equal' | 'equal' | 'not_equal'
  /**
   * Condition under which a re-notification is sent
   */
  renotificationConditions?: Array<'raise' | 'warn' | 'no-data'>
  /**
   * How long to wait before re-notifying in milliseconds
   */
  renotificationWindowMs?: number
  /**
   * Re-notification message
   */
  renotificationMessage?: string
  /**
   * Team associated with this alert
   */
  team?: string | null
  /**
   * Tags associated with this alert
   */
  tags: Array<string>
}

export type ArchiveSchemaDto = {
  forceArchive?: boolean
  /**
   * The reason for archiving the gate
   */
  archiveReason?: string
}

export type AssignmentSourceContractDto = {
  /**
   * Unique identifier for the assignment source.
   */
  name: string
  /**
   * Detailed context and purpose of the assignment source.
   */
  description: string
  /**
   * Marks the assignment source as verified for internal trustworthiness.
   */
  isVerified?: boolean
  /**
   * Tags for categorization and search.
   */
  tags: Array<string>
  /**
   * SQL query defining the data source for assignments.
   */
  sql: string
  /**
   * Column name representing the timestamp of assignments.
   */
  timestampColumn: string
  /**
   * Column name for the experiment ID associated with the assignments.
   */
  experimentIDColumn: string
  /**
   * Column name for the group ID linked to the assignments.
   */
  groupIDColumn: string
  /**
   * Mappings of Statsig units to their respective columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name associated with the ID type mapping.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
}

export type AssignmentSourceCreationDto = {
  /**
   * Unique identifier for the assignment source.
   */
  name: string
  /**
   * Optional detailed context for the assignment source.
   */
  description?: string
  /**
   * Marks the assignment source as verified for internal trustworthiness.
   */
  isVerified?: boolean
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source for assignments.
   */
  sql: string
  /**
   * Column name representing the timestamp of assignments.
   */
  timestampColumn: string
  /**
   * Column name for the experiment ID associated with the assignments.
   */
  experimentIDColumn: string
  /**
   * Column name for the group ID linked to the assignments.
   */
  groupIDColumn: string
  /**
   * Mappings of Statsig units to their respective columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name associated with the ID type mapping.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the assignment source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type AssignmentSourcePartialUpdateDto = {
  /**
   * Unique identifier for the assignment source.
   */
  name?: string
  /**
   * Detailed context and purpose of the assignment source.
   */
  description?: string
  /**
   * Marks the assignment source as verified for internal trustworthiness.
   */
  isVerified?: boolean
  /**
   * Tags for categorization and search.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source for assignments.
   */
  readonly sql?: unknown
  /**
   * Column name representing the timestamp of assignments.
   */
  timestampColumn?: string
  /**
   * Column name for the experiment ID associated with the assignments.
   */
  experimentIDColumn?: string
  /**
   * Column name for the group ID linked to the assignments.
   */
  groupIDColumn?: string
  /**
   * Mappings of Statsig units to their respective columns.
   */
  idTypeMapping?: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name associated with the ID type mapping.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the assignment source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type AssignmentSourceQueryUpdateDto = {
  /**
   * Optional new name for the assignment source.
   */
  name?: string
  /**
   * Optional updated context for the assignment source.
   */
  description?: string
  /**
   * Marks the assignment source as verified for internal trustworthiness.
   */
  isVerified?: boolean
  /**
   * Optional updated tags for categorization.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source for assignments.
   */
  sql: string
  /**
   * Column name representing the timestamp of assignments.
   */
  timestampColumn: string
  /**
   * Column name for the experiment ID associated with the assignments.
   */
  experimentIDColumn: string
  /**
   * Column name for the group ID linked to the assignments.
   */
  groupIDColumn: string
  /**
   * Mappings of Statsig units to their respective columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name associated with the ID type mapping.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the assignment source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type AuditLogDto = {
  /**
   * id of the audit log
   */
  id: string
  /**
   * name of the audit log
   */
  name: string
  /**
   * change log of the audit log
   */
  changeLog: string
  actionType: {
    [key: string]: unknown
  }
  date: string
  time: string
  updatedBy: string
  updatedByUserID: string
  modifierEmail: {
    [key: string]: unknown
  }
  changes: {
    [key: string]: unknown
  }
  tags: Array<string>
  targetAppIDs?: Array<string>
}

export type AutotuneCreateDto = {
  /**
   * A brief summary of what the autotune is being used for.
   */
  description?: string
  /**
   * An array of Variant objects.
   */
  variants: Array<{
    /**
     * Variant name
     */
    name: string
    /**
     * Variant JSON data
     */
    json: unknown
    /**
     * Variant size
     */
    size?: number
  }>
  /**
   * The event you are trying to optimize for.
   */
  successEvent: string
  /**
   * The value that should come with the event for it to be considered successful.
   */
  successEventValue?: string
  /**
   * The initial time period where Autotune will equally split the traffic.
   */
  explorationWindow:
    | '1hr'
    | '24hr'
    | '48hr'
    | '168hr'
    | '336hr'
    | '1'
    | '24'
    | '48'
    | '168'
    | '336'
    | '1hrs'
    | '24hrs'
    | '48hrs'
    | '168hrs'
    | '336hrs'
  /**
   * The maximum duration between the exposure and success event that counts as a success.
   */
  attributionWindow: '1hr' | '2hr' | '4hr' | '24hr' | '1hrs' | '2hrs' | '4hrs' | '24hrs' | '1' | '2' | '4' | '24'
  /**
   * Time unit of attribution window
   */
  attributionWindowUnit?: 'min' | 'hour' | 'day'
  /**
   * Exploration window rate
   */
  explorationWindowRate?: number
  /**
   * Long term exploration allocation
   */
  longtermExplorationAllocation?: number
  /**
   * The "probability of best" threshold a variant needs to achieve for Autotune to declare it the winner, stop collecting data, and direct all traffic.
   */
  winnerThreshold: '80%' | '90%' | '95%' | '98%' | '99%'
  /**
   * Metadata field containing the numeric value to optimize for. If this field is null, autotune optimizes for the existence of a follow-up event. This is only used for contextual autotunes.
   */
  metadataField?: string
  /**
   * Whether to optimize for an increase or decrease in the metadata field value. Default is true. This is only used for contextual autotunes.
   */
  higherIsBetter?: boolean
  /**
   * Makes this autotune contextual
   */
  isContextual?: boolean
  /**
   * Metric source to pull success event data from
   */
  metricSourceID?: string
  /**
   * Linked experiment to measure the success of the Autotune
   */
  linkedExperimentName?: string
  /**
   * Autotune goal
   */
  goalRichText?: string
  /**
   * Optimize for event occurrence vs value
   */
  optimizationParameter?: 'occurrence' | 'value'
  /**
   * Metric source column to optimize for
   */
  valueColumn?: string
  /**
   * List of features that should be included in the analysis
   */
  featureList?: Array<string>
  /**
   * The name that was originally given to the autotune on creation but formatted as an ID ("A Autotune" -> "a_autotune").
   */
  name: string
  /**
   * idType of the autotune (userID, stableID, or a customID). Defaults to userID if not provided
   */
  idType?: string
}

export type AutotuneExperimentDto = {
  /**
   * Detailed description of the configurationâ€™s purpose.
   */
  description: string
  variants: Array<{
    /**
     * Variant name
     */
    name: string
    /**
     * Variant JSON data
     */
    json: unknown
    /**
     * Variant size
     */
    size?: number
    /**
     * The name that was originally given to the autotune on creation but formatted as an ID ("A Autotune" -> "a_autotune").
     */
    id: string
  }>
  /**
   * The event you are trying to optimize for.
   */
  successEvent: string
  /**
   * The value that should come with the event for it to be considered successful.
   */
  successEventValue: string
  /**
   * The initial time period where Autotune will equally split the traffic.
   */
  explorationWindow:
    | '1hr'
    | '24hr'
    | '48hr'
    | '168hr'
    | '336hr'
    | '1'
    | '24'
    | '48'
    | '168'
    | '336'
    | '1hrs'
    | '24hrs'
    | '48hrs'
    | '168hrs'
    | '336hrs'
  /**
   * The maximum duration between the exposure and success event that counts as a success.
   */
  attributionWindow: '1hr' | '2hr' | '4hr' | '24hr' | '1hrs' | '2hrs' | '4hrs' | '24hrs' | '1' | '2' | '4' | '24'
  /**
   * Time unit of attribution window
   */
  attributionWindowUnit?: 'min' | 'hour' | 'day'
  /**
   * Exploration window rate
   */
  explorationWindowRate?: number
  /**
   * Long term exploration allocation
   */
  longtermExplorationAllocation?: number
  /**
   * The "probability of best" threshold a variant needs to achieve for Autotune to declare it the winner, stop collecting data, and direct all traffic.
   */
  winnerThreshold: '80%' | '90%' | '95%' | '98%' | '99%'
  /**
   * Metadata field containing the numeric value to optimize for. If this field is null, autotune optimizes for the existence of a follow-up event. This is only used for contextual autotunes.
   */
  metadataField?: string
  /**
   * Whether to optimize for an increase or decrease in the metadata field value. Default is true. This is only used for contextual autotunes.
   */
  higherIsBetter?: boolean
  /**
   * Whether this is a contextual autotune
   */
  isContextual?: boolean
  /**
   * Metric source to pull success event data from
   */
  metricSourceID?: string
  /**
   * Linked experiment to measure the success of the Autotune
   */
  linkedExperimentName?: string
  /**
   * Autotune goal
   */
  goalRichText?: string
  /**
   * Optimize for event occurrence vs value
   */
  optimizationParameter?: 'occurrence' | 'value'
  /**
   * Metric source column to optimize for
   */
  valueColumn?: string
  /**
   * List of features that should be included in the analysis
   */
  featureList?: Array<string>
  /**
   * ID
   */
  id: string
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * Type of ID
   */
  idType: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  /**
   * ID of the user who created the entity.
   */
  creatorID: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  /**
   * Email of the creator.
   */
  creatorEmail: string | null
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * List of target applications associated with this configuration.
   */
  targetApps?: Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * Optional name for the responsible team.
   */
  team?: string | null
  /**
   * Optional ID of the responsible team.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  /**
   * Is the autotune experiment currently running.
   */
  isStarted: boolean
  winner: {
    /**
     * The Statsig UserID of the last modifier of this autotune.
     */
    id: string
    /**
     * The Statsig Username of the last modifier of this autotune.
     */
    name: string
  } | null
}

/**
 * Autotune object
 */
export type AutotuneFullUpdateDto = {
  /**
   * A brief summary of what the autotune is being used for.
   */
  description?: string
  /**
   * An array of Variant objects.
   */
  variants: Array<{
    /**
     * Variant name
     */
    name: string
    /**
     * Variant JSON data
     */
    json: unknown
    /**
     * Variant size
     */
    size?: number
  }>
  /**
   * The event you are trying to optimize for.
   */
  successEvent: string
  /**
   * The value that should come with the event for it to be considered successful.
   */
  successEventValue?: string
  /**
   * The initial time period where Autotune will equally split the traffic.
   */
  explorationWindow:
    | '1hr'
    | '24hr'
    | '48hr'
    | '168hr'
    | '336hr'
    | '1'
    | '24'
    | '48'
    | '168'
    | '336'
    | '1hrs'
    | '24hrs'
    | '48hrs'
    | '168hrs'
    | '336hrs'
  /**
   * The maximum duration between the exposure and success event that counts as a success.
   */
  attributionWindow: '1hr' | '2hr' | '4hr' | '24hr' | '1hrs' | '2hrs' | '4hrs' | '24hrs' | '1' | '2' | '4' | '24'
  /**
   * Time unit of attribution window
   */
  attributionWindowUnit?: 'min' | 'hour' | 'day'
  /**
   * Exploration window rate
   */
  explorationWindowRate?: number
  /**
   * Long term exploration allocation
   */
  longtermExplorationAllocation?: number
  /**
   * The "probability of best" threshold a variant needs to achieve for Autotune to declare it the winner, stop collecting data, and direct all traffic.
   */
  winnerThreshold: '80%' | '90%' | '95%' | '98%' | '99%'
  /**
   * Metadata field containing the numeric value to optimize for. If this field is null, autotune optimizes for the existence of a follow-up event. This is only used for contextual autotunes.
   */
  metadataField?: string
  /**
   * Whether to optimize for an increase or decrease in the metadata field value. Default is true. This is only used for contextual autotunes.
   */
  higherIsBetter?: boolean
  /**
   * Whether this is a contextual autotune
   */
  isContextual?: boolean
  /**
   * Metric source to pull success event data from
   */
  metricSourceID?: string
  /**
   * Linked experiment to measure the success of the Autotune
   */
  linkedExperimentName?: string
  /**
   * Autotune goal
   */
  goalRichText?: string
  /**
   * Optimize for event occurrence vs value
   */
  optimizationParameter?: 'occurrence' | 'value'
  /**
   * Metric source column to optimize for
   */
  valueColumn?: string
  /**
   * List of features that should be included in the analysis
   */
  featureList?: Array<string>
}

export type AutotunePartialUpdateDto = {
  /**
   * A brief summary of what the autotune is being used for.
   */
  description?: string
  /**
   * An array of Variant objects.
   */
  variants?: Array<{
    /**
     * Variant name
     */
    name: string
    /**
     * Variant JSON data
     */
    json: unknown
    /**
     * Variant size
     */
    size?: number
  }>
  /**
   * The event you are trying to optimize for.
   */
  successEvent?: string
  /**
   * The value that should come with the event for it to be considered successful.
   */
  successEventValue?: string
  /**
   * The initial time period where Autotune will equally split the traffic.
   */
  explorationWindow?:
    | '1hr'
    | '24hr'
    | '48hr'
    | '168hr'
    | '336hr'
    | '1'
    | '24'
    | '48'
    | '168'
    | '336'
    | '1hrs'
    | '24hrs'
    | '48hrs'
    | '168hrs'
    | '336hrs'
  /**
   * The maximum duration between the exposure and success event that counts as a success.
   */
  attributionWindow?: '1hr' | '2hr' | '4hr' | '24hr' | '1hrs' | '2hrs' | '4hrs' | '24hrs' | '1' | '2' | '4' | '24'
  /**
   * Time unit of attribution window
   */
  attributionWindowUnit?: 'min' | 'hour' | 'day'
  /**
   * Exploration window rate
   */
  explorationWindowRate?: number
  /**
   * Long term exploration allocation
   */
  longtermExplorationAllocation?: number
  /**
   * The "probability of best" threshold a variant needs to achieve for Autotune to declare it the winner, stop collecting data, and direct all traffic.
   */
  winnerThreshold?: '80%' | '90%' | '95%' | '98%' | '99%'
  /**
   * Metadata field containing the numeric value to optimize for. If this field is null, autotune optimizes for the existence of a follow-up event. This is only used for contextual autotunes.
   */
  metadataField?: string
  /**
   * Whether to optimize for an increase or decrease in the metadata field value. Default is true. This is only used for contextual autotunes.
   */
  higherIsBetter?: boolean
  /**
   * Whether this is a contextual autotune
   */
  isContextual?: boolean
  /**
   * Metric source to pull success event data from
   */
  metricSourceID?: string
  /**
   * Linked experiment to measure the success of the Autotune
   */
  linkedExperimentName?: string
  /**
   * Autotune goal
   */
  goalRichText?: string
  /**
   * Optimize for event occurrence vs value
   */
  optimizationParameter?: 'occurrence' | 'value'
  /**
   * Metric source column to optimize for
   */
  valueColumn?: string
  /**
   * List of features that should be included in the analysis
   */
  featureList?: Array<string>
}

export type BulkAssignConfigTargetAppDto = {
  /**
   * target app ids
   */
  targetApps: Array<string>
  /**
   * Gate IDs to assign to target app(s)
   */
  gates?: Array<string>
  /**
   * Dynamic Config IDs to assign to target app(s)
   */
  dynamicConfigs?: Array<string>
  /**
   * Experiment IDs to assign to target app(s)
   */
  experiments?: Array<string>
}

export type ChangeValidationDto = {
  reviewID: string
  validated: boolean
  message?: string
}

export type ChangeValidationUpdateMessageDto = {
  reviewID: string
  message?: string
}

export type CompanyInfoResponseDto = {
  companyID: string
  companyName: string
  isWarehouseNative: boolean
  orgID: string | null
  orgName: string | null
}

export type CumulativeExposureResponseDto = Array<{
  groupID: string
  groupName: string
  results: Array<{
    date: string
    exposures: number
  }>
}>

export type DynamicConfigCreateDto = {
  /**
   * Name for the configuration.
   */
  name: string
  /**
   * Is the dynamic config enabled
   */
  isEnabled?: boolean
  description?: string
  /**
   * An array of Rule objects
   */
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage?: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    returnValueJson5?: string
    variants?: Array<{
      id?: string
      name: string
      passPercentage: number
      returnValue?: {
        [key: string]: unknown
      }
      returnValueJson5?: string
    }>
  }>
  /**
   * The fallback JSON object when no rules are triggered
   */
  defaultValue?: {
    [key: string]: unknown
  }
  /**
   * Can include comments. If provided with defaultValue, must parse to the same JSON
   */
  defaultValueJson5?: string
  /**
   * The type of ID which the dynamic config is based on.
   */
  idType?: string
  /**
   * The list of tag names attached to the dynamic config
   */
  tags?: Array<string>
  creatorID?: string | null
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  creatorEmail?: string | null
  /**
   * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
   */
  schema?: string | null
  /**
   * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
   */
  schemaJson5?: string | null
  targetApps?: string | Array<string>
  /**
   * The team name associated with the dynamic config, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the dynamic config, Enterprise only.
   */
  teamID?: string | null
  /**
   * The release pipeline ID associated with the dynamic config
   */
  releasePipelineID?: string | null
  id?: string
  isTemplate?: boolean
}

export type DynamicConfigDto = {
  /**
   * ID
   */
  id: string
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * The type of ID which the dynamic config is based on.
   */
  idType?: string
  /**
   * A brief summary of what the dynamic config is being used for
   */
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  creatorID?: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  creatorEmail?: string | null
  /**
   * The list of tag names attached to the dynamic config
   */
  tags?: Array<string>
  targetApps?: string | Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * The team name associated with the dynamic config, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the dynamic config, Enterprise only.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  /**
   * Is the dynamic config enabled
   */
  isEnabled: boolean
  /**
   * An array of Rule objects
   */
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    returnValueJson5?: string
    variants?: Array<{
      id?: string
      name: string
      passPercentage: number
      returnValue?: {
        [key: string]: unknown
      }
      returnValueJson5?: string
    }>
  }>
  /**
   * The fallback JSON object when no rules are triggered
   */
  defaultValue?: {
    [key: string]: unknown
  }
  /**
   * Can include comments. If provided with defaultValue, must parse to the same JSON
   */
  defaultValueJson5?: string
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
   */
  schema?: string | null
  /**
   * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
   */
  schemaJson5?: string | null
  /**
   * The release pipeline ID associated with the dynamic config
   */
  releasePipelineID?: string | null
  isTemplate?: boolean
}

export type DynamicConfigFullUpdateDto = {
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * Is the dynamic config enabled
   */
  isEnabled: boolean
  /**
   * A brief summary of what the dynamic config is being used for
   */
  description: string
  /**
   * An array of Rule objects
   */
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage?: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    returnValueJson5?: string
    variants?: Array<{
      id?: string
      name: string
      passPercentage: number
      returnValue?: {
        [key: string]: unknown
      }
      returnValueJson5?: string
    }>
  }>
  /**
   * The fallback JSON object when no rules are triggered
   */
  defaultValue?: {
    [key: string]: unknown
  }
  /**
   * Can include comments. If provided with defaultValue, must parse to the same JSON
   */
  defaultValueJson5?: string
  /**
   * The type of ID which the dynamic config is based on.
   */
  idType?: string
  /**
   * The list of tag names attached to the dynamic config
   */
  tags?: Array<string>
  creatorID?: string | null
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  creatorEmail?: string | null
  /**
   * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
   */
  schema?: string | null
  /**
   * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
   */
  schemaJson5?: string | null
  targetApps?: string | Array<string>
  /**
   * The team name associated with the dynamic config, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the dynamic config, Enterprise only.
   */
  teamID?: string | null
  /**
   * The release pipeline ID associated with the dynamic config
   */
  releasePipelineID?: string | null
}

export type DynamicConfigPartialUpdateDto = {
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * Is the dynamic config enabled
   */
  isEnabled?: boolean
  /**
   * A brief summary of what the dynamic config is being used for
   */
  description?: string
  /**
   * An array of Rule objects
   */
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage?: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    returnValueJson5?: string
    variants?: Array<{
      id?: string
      name: string
      passPercentage: number
      returnValue?: {
        [key: string]: unknown
      }
      returnValueJson5?: string
    }>
  }>
  /**
   * The fallback JSON object when no rules are triggered
   */
  defaultValue?: {
    [key: string]: unknown
  }
  /**
   * Can include comments. If provided with defaultValue, must parse to the same JSON
   */
  defaultValueJson5?: string
  /**
   * The type of ID which the dynamic config is based on.
   */
  idType?: string
  /**
   * The list of tag names attached to the dynamic config
   */
  tags?: Array<string>
  creatorID?: string | null
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  creatorEmail?: string | null
  /**
   * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
   */
  schema?: string | null
  /**
   * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
   */
  schemaJson5?: string | null
  targetApps?: string | Array<string>
  /**
   * The team name associated with the dynamic config, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the dynamic config, Enterprise only.
   */
  teamID?: string | null
  /**
   * The release pipeline ID associated with the dynamic config
   */
  releasePipelineID?: string | null
}

export type DynamicConfigRuleDto = {
  /**
   * The name of this rule.
   */
  name: string
  /**
   * Of the users that meet the conditions of this rule, what percent should return true.
   */
  passPercentage: number
  /**
   * An array of Condition objects.
   */
  conditions: Array<{
    targetValue?: Array<string> | Array<number> | string | number | null
    operator?: string
    field?: string | null
    customID?: string | null
    type:
      | 'app_version'
      | 'browser_name'
      | 'browser_version'
      | 'country'
      | 'custom_field'
      | 'email'
      | 'environment_tier'
      | 'fails_gate'
      | 'fails_segment'
      | 'ip_address'
      | 'locale'
      | 'os_name'
      | 'os_version'
      | 'passes_gate'
      | 'passes_segment'
      | 'public'
      | 'time'
      | 'unit_id'
      | 'user_id'
      | 'url'
      | 'javascript'
      | 'device_model'
      | 'target_app'
  }>
  /**
   * The environments this rule is enabled for.
   */
  environments?: Array<string> | null
  /**
   * The Statsig ID of this rule.
   */
  id?: string
  /**
   * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
   */
  baseID?: string
  /**
   * The return value of the rule.
   */
  returnValue?: {
    [key: string]: unknown
  }
  completedAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  pendingAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
}

export type DynamicConfigRulePartialDto = {
  /**
   * The name of this rule.
   */
  name?: string
  /**
   * Of the users that meet the conditions of this rule, what percent should return true.
   */
  passPercentage?: number
  /**
   * An array of Condition objects.
   */
  conditions?: Array<{
    targetValue?: Array<string> | Array<number> | string | number | null
    operator?: string
    field?: string | null
    customID?: string | null
    type:
      | 'app_version'
      | 'browser_name'
      | 'browser_version'
      | 'country'
      | 'custom_field'
      | 'email'
      | 'environment_tier'
      | 'fails_gate'
      | 'fails_segment'
      | 'ip_address'
      | 'locale'
      | 'os_name'
      | 'os_version'
      | 'passes_gate'
      | 'passes_segment'
      | 'public'
      | 'time'
      | 'unit_id'
      | 'user_id'
      | 'url'
      | 'javascript'
      | 'device_model'
      | 'target_app'
  }>
  environments?: Array<string> | null
  /**
   * The Statsig ID of this rule.
   */
  id?: string
  /**
   * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
   */
  baseID?: string
  returnValue?: {
    [key: string]: unknown
  }
  completedAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  pendingAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  returnValueJson5?: string
  variants?: Array<{
    id?: string
    name: string
    passPercentage: number
    returnValue?: {
      [key: string]: unknown
    }
    returnValueJson5?: string
  }>
}

export type DynamicConfigRulesDto = {
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
}

export type EchidnaGateLoadPulseQueryDto = {
  refresh?: 'full' | 'incremental' | 'metric'
  metricIDs?: Array<string>
  ruleId: string
  turboMode?: boolean
}

export type EchidnaLoadPulseQueryDto = {
  refresh?: 'full' | 'incremental' | 'metric'
  metricIDs?: Array<string>
  ruleId?: string
  turboMode?: boolean
}

export type EnableDisableGroupsDto = {
  group_names: Array<string>
}

export type EntityPropertySourceCreationDto = {
  /**
   * Unique identifier for the entity property source.
   */
  name: string
  /**
   * Optional detailed context for the entity property source.
   */
  description?: string
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source.
   */
  sql: string
  /**
   * Optional column name for timestamp.
   */
  timestampColumn?: string
  /**
   * Indicates if the timestamp is treated as a day.
   */
  timestampAsDay?: boolean
  /**
   * Mappings of Statsig units to their columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name linked to the ID.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the entity property source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type EntityPropertySourceDto = {
  /**
   * Unique identifier for the entity property source.
   */
  name: string
  /**
   * Detailed context and purpose of the entity property source.
   */
  description: string
  /**
   * Tags for categorization and search.
   */
  tags: Array<string>
  /**
   * SQL query defining the data source.
   */
  sql: string
  /**
   * Optional column name for timestamp.
   */
  timestampColumn?: string
  /**
   * Indicates if the timestamp is treated as a day.
   */
  timestampAsDay?: boolean
  /**
   * Mappings of Statsig units to their columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name linked to the ID.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
}

export type EntityPropertySourcePartialUpdateDto = {
  /**
   * Unique identifier for the entity property source.
   */
  name?: string
  /**
   * Detailed context and purpose of the entity property source.
   */
  description?: string
  /**
   * Tags for categorization and search.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source
   */
  readonly sql?: unknown
  /**
   * Optional column name for timestamp.
   */
  timestampColumn?: string
  /**
   * Indicates if the timestamp is treated as a day.
   */
  timestampAsDay?: boolean
  /**
   * Mappings of Statsig units to their columns.
   */
  idTypeMapping?: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name linked to the ID.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the entity property source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type EntityPropertySourceQueryUpdateDto = {
  /**
   * Optional new name for the entity property source.
   */
  name?: string
  /**
   * Optional updated context for the entity property source.
   */
  description?: string
  /**
   * Optional updated tags for categorization.
   */
  tags?: Array<string>
  /**
   * SQL query defining the data source.
   */
  sql: string
  /**
   * Optional column name for timestamp.
   */
  timestampColumn?: string
  /**
   * Indicates if the timestamp is treated as a day.
   */
  timestampAsDay?: boolean
  /**
   * Mappings of Statsig units to their columns.
   */
  idTypeMapping: Array<{
    /**
     * ID for the Statsig unit.
     */
    statsigUnitID: string
    /**
     * Column name linked to the ID.
     */
    column: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the entity property source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type EnvironmentsContractDto = {
  environments: Array<{
    /**
     * The name of the environment.
     */
    name: string
    /**
     * A unique identifier for the environment.
     */
    id: string
    /**
     * Whether the environment is production.
     */
    isProduction: boolean
    /**
     * Whether the environment requires review.
     */
    requiresReview: boolean
    /**
     * The ID of the review group that the environment requires review from.
     */
    requiredReviewGroupID?: string
    /**
     * Whether the environment requires a release pipeline.
     */
    requiresReleasePipeline: boolean
  }>
}

export type EnvironmentsUpdateContractDto = {
  environments: Array<{
    /**
     * The name of the environment.
     */
    name: string
    /**
     * A unique identifier for the environment. If not provided, the associated environment will be treated as a newly created environment.
     */
    id?: string
    /**
     * Whether the environment is production.
     */
    isProduction: boolean
    /**
     * Whether the environment requires review.
     */
    requiresReview: boolean
    /**
     * The ID of the review group that the environment requires review from.
     */
    requiredReviewGroupID?: string
    /**
     * Whether the environment requires a release pipeline.
     */
    requiresReleasePipeline: boolean
  }>
}

export type ExperimentAbandonDto = {
  /**
   * The reason for making the decision to update the experiment status
   */
  decisionReason: string
}

/**
 * Schema for archiving an experiment
 */
export type ExperimentArchiveDto = {
  /**
   * The reason for archiving the experiment
   */
  archiveReason?: string
}

/**
 * Create Experiment
 */
export type ExperimentCreateDto = {
  /**
   * The name of the new experiment
   */
  name: string
  /**
   * A description of the new experiment
   */
  description?: string
  /**
   * The idType the experiment will be performed on
   */
  idType?: string
  /**
   * The secondary ID type for the experiment used in WHN for ID resolution
   */
  secondaryIDType?: string | null
  /**
   * The identifier mapping mode for the experiment used in WHN for ID resolution
   */
  identifierMappingMode?: 'strictOneToOne' | 'firstTouchOneToMany' | 'lastTouchOneToMany'
  /**
   * The identity resolution entity property source for the experiment used in WHN for ID resolution
   */
  identityResolutionSource?: string | null
  /**
   * A statement that will be tested by this experiment
   */
  hypothesis?: string
  /**
   * Links to relevant documentation or resources
   */
  links?: Array<{
    /**
     * The URL of the link
     */
    url: string
    /**
     * The title of the link
     */
    title?: string
  }>
  /**
   * The test groups for your experiment
   */
  groups?: Array<{
    name: string
    id?: string | null
    size: number
    parameterValues: {
      [key: string]: unknown
    }
    disabled?: boolean
    description?: string
    foreignGroupID?: string
  }>
  /**
   * Optional control group ID
   */
  controlGroupID?: string
  /**
   * Percent of layer allocated to this experiment
   */
  allocation?: number
  /**
   * Primary metric tags for the experiment
   */
  primaryMetricTags?: Array<string>
  /**
   * Secondary metric tags for the experiment
   */
  secondaryMetricTags?: Array<string>
  /**
   * Main metrics needed to evaluate your hypothesis
   */
  primaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics to monitor that might impact the analysis or final decision of the experiment
   */
  secondaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics you want to investigate or learn from. The usual corrections applied to Primary and Secondary metrics are not applied to these.
   */
  otherMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Target apps assigned to this experiment
   */
  targetApps?: string | Array<string>
  /**
   * Tags associated with the experiment
   */
  tags?: Array<string>
  /**
   * How long the experiment is expected to last in days
   */
  duration?: number
  /**
   * Target exposures for the experiment
   */
  targetExposures?: number
  /**
   * Restrict your experiment to users passing the selected feature gate
   */
  targetingGateID?: string | null
  /**
   * Apply sequential testing?
   */
  sequentialTesting?: boolean
  /**
   * Is Bonferroni correction applied per variant?
   */
  bonferroniCorrection?: boolean
  /**
   * Is Bonferroni correction applied per metric?
   */
  bonferroniCorrectionPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per variant?
   */
  benjaminiHochbergPerVariant?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per metric?
   */
  benjaminiHochbergPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied for primary metrics only?
   */
  benjaminiPrimaryMetricsOnly?: boolean
  /**
   * Default error margin used for results
   */
  defaultConfidenceInterval?: '80' | '90' | '95' | '98' | '99'
  /**
   * Up to 10 manually set quality scores for an experiment. The scores and weights will be added to the existing weights and scores, and then weights will be renormalized to 100. This can be set via the Statsig Console API. If targeting a default check, the weight of the check will be updated, but not the status or description. A default score can be removed by setting the weight to 0. The default score identifiers are one of: HYPOTHESIS_LENGTH, BALANCED_EXPOSURE, PRIMARY_METRICS_LENGTH, COMPARISON_CORRECTION, GUARDRAIL_METRIC_TAGS, SUFFICIENT_SAMPLE, POWER_ANALYSIS, SEQUENTIAL_TESTING
   */
  manualQualityScores?: Array<{
    criteriaName:
      | 'HYPOTHESIS_LENGTH'
      | 'BALANCED_EXPOSURE'
      | 'PRIMARY_METRICS_LENGTH'
      | 'COMPARISON_CORRECTION'
      | 'GUARDRAIL_METRIC_TAGS'
      | 'SUFFICIENT_SAMPLE'
      | 'POWER_ANALYSIS'
      | 'SEQUENTIAL_TESTING'
      | string
    status: 'PASSED' | 'FAILED' | 'WARNING'
    criteriaDescription: string
    score: number
    weight: number
  }>
  /**
   * The current status of the experiment
   */
  status?: 'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
  /**
   * ID of the launched group, null otherwise
   */
  launchedGroupID?: string | null
  /**
   * Source name of the assignment
   */
  assignmentSourceName?: string
  /**
   * Name of the source experiment for assignment
   */
  assignmentSourceExperimentName?: string
  /**
   * The Statsig ID of the creator of this experiment
   */
  creatorID?: string | null
  /**
   * The email of the creator of this experiment
   */
  creatorEmail?: string | null
  /**
   * For Warehouse Native
   */
  isAnalysisOnly?: boolean | null
  /**
   * The team name associated with the experiment, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the experiment, Enterprise only.
   */
  teamID?: string | null
  /**
   * Warehouse Native Only - Allocation duration in days
   */
  allocationDuration?: number | null
  /**
   * Warehouse Native Only - Cohorted analysis duration in days
   */
  cohortedAnalysisDuration?: number
  /**
   * Warehouse Native Only - Allow cohort metrics to mature after experiment end
   */
  cohortedMetricsMatureAfterEnd?: boolean
  /**
   * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
   */
  cohortWaitUntilEndToInclude?: boolean
  /**
   * Fixed analysis duration in days
   */
  fixedAnalysisDuration?: number
  /**
   * Warehouse Native only - UTC hour at which to run scheduled pulse loads
   */
  scheduledReloadHour?: number | null
  /**
   * Warehouse Native only - reload type for scheduled reloads
   */
  scheduledReloadType?: 'full' | 'incremental'
  /**
   * Warehouse Native only - end time for analysis only experiments
   */
  analysisEndTime?: string
  /**
   * Array of criteria for filtering assignment sources.
   */
  assignmentSourceFilters?: Array<{
    /**
     * Column to filter on.
     */
    column?: string
    condition:
      | 'in'
      | 'not_in'
      | '='
      | '>'
      | '<'
      | '>='
      | '<='
      | 'is_null'
      | 'non_null'
      | 'contains'
      | 'not_contains'
      | 'sql_filter'
      | 'starts_with'
      | 'ends_with'
      | 'after_exposure'
      | 'before_exposure'
      | 'is_true'
      | 'is_false'
    /**
     * Optional array of values for the criterion to match against.
     */
    values?: Array<string>
  }>
  /**
   * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
   */
  analyticsType?: 'frequentist' | 'bayesian' | 'sprt'
  /**
   * Whether this is a Statsig Sidecar experiment.
   */
  isSidecar?: boolean
  /**
   * Experiment notes reported after experiment completes
   */
  decisionReason?: string
  id?: string
  /**
   * Which layer to place the experiment into.
   */
  layerID?: string
}

export type ExperimentFullUpdateDto = {
  /**
   * The display name of the experiment
   */
  name?: string
  /**
   * A helpful summary of what this experiment does
   */
  description: string
  /**
   * The type of ID which the experiment is based on
   */
  idType: string
  /**
   * The secondary ID type for the experiment used in WHN for ID resolution
   */
  secondaryIDType?: string | null
  /**
   * The identifier mapping mode for the experiment used in WHN for ID resolution
   */
  identifierMappingMode?: 'strictOneToOne' | 'firstTouchOneToMany' | 'lastTouchOneToMany'
  /**
   * The identity resolution entity property source for the experiment used in WHN for ID resolution
   */
  identityResolutionSource?: string | null
  /**
   * A statement that will be tested by this experiment
   */
  hypothesis: string
  /**
   * Links to relevant documentation or resources
   */
  links?: Array<{
    /**
     * The URL of the link
     */
    url: string
    /**
     * The title of the link
     */
    title?: string
  }>
  /**
   * The test groups for your experiment
   */
  groups: Array<{
    name: string
    id?: string | null
    size: number
    parameterValues: {
      [key: string]: unknown
    }
    disabled?: boolean
    description?: string
    foreignGroupID?: string
  }>
  /**
   * Optional control group ID
   */
  controlGroupID?: string
  /**
   * Percent of layer allocated to this experiment
   */
  allocation: number
  /**
   * Primary metric tags for the experiment
   */
  primaryMetricTags?: Array<string>
  /**
   * Secondary metric tags for the experiment
   */
  secondaryMetricTags?: Array<string>
  /**
   * Main metrics needed to evaluate your hypothesis
   */
  primaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics to monitor that might impact the analysis or final decision of the experiment
   */
  secondaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics you want to investigate or learn from. The usual corrections applied to Primary and Secondary metrics are not applied to these.
   */
  otherMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Target apps assigned to this experiment
   */
  targetApps?: string | Array<string>
  /**
   * Tags associated with the experiment
   */
  tags?: Array<string>
  /**
   * How long the experiment is expected to last in days
   */
  duration?: number
  /**
   * Target exposures for the experiment
   */
  targetExposures?: number
  /**
   * Restrict your experiment to users passing the selected feature gate
   */
  targetingGateID: string | null
  /**
   * Apply sequential testing?
   */
  sequentialTesting?: boolean
  /**
   * Is Bonferroni correction applied per variant?
   */
  bonferroniCorrection: boolean
  /**
   * Is Bonferroni correction applied per metric?
   */
  bonferroniCorrectionPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per variant?
   */
  benjaminiHochbergPerVariant?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per metric?
   */
  benjaminiHochbergPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied for primary metrics only?
   */
  benjaminiPrimaryMetricsOnly?: boolean
  /**
   * Default error margin used for results
   */
  defaultConfidenceInterval: '80' | '90' | '95' | '98' | '99'
  /**
   * Up to 10 manually set quality scores for an experiment. The scores and weights will be added to the existing weights and scores, and then weights will be renormalized to 100. This can be set via the Statsig Console API. If targeting a default check, the weight of the check will be updated, but not the status or description. A default score can be removed by setting the weight to 0. The default score identifiers are one of: HYPOTHESIS_LENGTH, BALANCED_EXPOSURE, PRIMARY_METRICS_LENGTH, COMPARISON_CORRECTION, GUARDRAIL_METRIC_TAGS, SUFFICIENT_SAMPLE, POWER_ANALYSIS, SEQUENTIAL_TESTING
   */
  manualQualityScores?: Array<{
    criteriaName:
      | 'HYPOTHESIS_LENGTH'
      | 'BALANCED_EXPOSURE'
      | 'PRIMARY_METRICS_LENGTH'
      | 'COMPARISON_CORRECTION'
      | 'GUARDRAIL_METRIC_TAGS'
      | 'SUFFICIENT_SAMPLE'
      | 'POWER_ANALYSIS'
      | 'SEQUENTIAL_TESTING'
      | string
    status: 'PASSED' | 'FAILED' | 'WARNING'
    criteriaDescription: string
    score: number
    weight: number
  }>
  /**
   * The current status of the experiment
   */
  status: 'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
  /**
   * ID of the launched group, null otherwise
   */
  launchedGroupID?: string | null
  /**
   * Source name of the assignment
   */
  assignmentSourceName?: string
  /**
   * Name of the source experiment for assignment
   */
  assignmentSourceExperimentName?: string
  /**
   * The Statsig ID of the creator of this experiment
   */
  creatorID?: string | null
  /**
   * The email of the creator of this experiment
   */
  creatorEmail?: string | null
  /**
   * For Warehouse Native
   */
  isAnalysisOnly?: boolean | null
  /**
   * The team name associated with the experiment, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the experiment, Enterprise only.
   */
  teamID?: string | null
  /**
   * Warehouse Native Only - Allocation duration in days
   */
  allocationDuration?: number | null
  /**
   * Warehouse Native Only - Cohorted analysis duration in days
   */
  cohortedAnalysisDuration?: number
  /**
   * Warehouse Native Only - Allow cohort metrics to mature after experiment end
   */
  cohortedMetricsMatureAfterEnd?: boolean
  /**
   * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
   */
  cohortWaitUntilEndToInclude?: boolean
  /**
   * Fixed analysis duration in days
   */
  fixedAnalysisDuration?: number
  /**
   * Warehouse Native only - UTC hour at which to run scheduled pulse loads
   */
  scheduledReloadHour?: number | null
  /**
   * Warehouse Native only - reload type for scheduled reloads
   */
  scheduledReloadType?: 'full' | 'incremental'
  /**
   * Warehouse Native only - end time for analysis only experiments
   */
  analysisEndTime?: string
  /**
   * Array of criteria for filtering assignment sources.
   */
  assignmentSourceFilters?: Array<{
    /**
     * Column to filter on.
     */
    column?: string
    condition:
      | 'in'
      | 'not_in'
      | '='
      | '>'
      | '<'
      | '>='
      | '<='
      | 'is_null'
      | 'non_null'
      | 'contains'
      | 'not_contains'
      | 'sql_filter'
      | 'starts_with'
      | 'ends_with'
      | 'after_exposure'
      | 'before_exposure'
      | 'is_true'
      | 'is_false'
    /**
     * Optional array of values for the criterion to match against.
     */
    values?: Array<string>
  }>
  /**
   * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
   */
  analyticsType?: 'frequentist' | 'bayesian' | 'sprt'
  /**
   * Whether this is a Statsig Sidecar experiment.
   */
  isSidecar?: boolean
  /**
   * Experiment notes reported after experiment completes
   */
  decisionReason?: string
}

export type ExperimentOverridesDto = {
  /**
   * Array of experiment overrides, each specifying type, ID, and group ID.
   */
  overrides: Array<{
    type: 'gate' | 'segment'
    /**
     * The id of the segment or gate
     */
    id: string
    /**
     * The experiment group which user will be forced into
     */
    groupID: string
  }>
  /**
   * Array of user ID overrides, specifying which users to force into experiment groups.
   */
  userIDOverrides: Array<{
    /**
     * The experiment group the user will be forced into.
     */
    groupID: string
    /**
     * Array of user IDs to be assigned to the specified experiment group.
     */
    ids: Array<string>
    /**
     * Optional environment designation (e.g., production, staging) for the experiment.
     */
    environment?: string | null
    /**
     * Optional type of unit for the experiment, defining the scope of the override.
     */
    unitType?: string | null
  }>
}

export type ExperimentPartialUpdateDto = {
  /**
   * The display name of the experiment
   */
  name?: string
  /**
   * A helpful summary of what this experiment does
   */
  description?: string
  /**
   * The type of ID which the experiment is based on
   */
  idType?: string
  /**
   * The secondary ID type for the experiment used in WHN for ID resolution
   */
  secondaryIDType?: string | null
  /**
   * The identifier mapping mode for the experiment used in WHN for ID resolution
   */
  identifierMappingMode?: 'strictOneToOne' | 'firstTouchOneToMany' | 'lastTouchOneToMany'
  /**
   * The identity resolution entity property source for the experiment used in WHN for ID resolution
   */
  identityResolutionSource?: string | null
  /**
   * A statement that will be tested by this experiment
   */
  hypothesis?: string
  /**
   * Links to relevant documentation or resources
   */
  links?: Array<{
    /**
     * The URL of the link
     */
    url: string
    /**
     * The title of the link
     */
    title?: string
  }>
  /**
   * The test groups for your experiment
   */
  groups?: Array<{
    name: string
    id?: string | null
    size: number
    parameterValues: {
      [key: string]: unknown
    }
    disabled?: boolean
    description?: string
    foreignGroupID?: string
  }>
  /**
   * Optional control group ID
   */
  controlGroupID?: string
  /**
   * Percent of layer allocated to this experiment
   */
  allocation?: number
  /**
   * Primary metric tags for the experiment
   */
  primaryMetricTags?: Array<string>
  /**
   * Secondary metric tags for the experiment
   */
  secondaryMetricTags?: Array<string>
  /**
   * Main metrics needed to evaluate your hypothesis
   */
  primaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics to monitor that might impact the analysis or final decision of the experiment
   */
  secondaryMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics you want to investigate or learn from. The usual corrections applied to Primary and Secondary metrics are not applied to these.
   */
  otherMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Target apps assigned to this experiment
   */
  targetApps?: string | Array<string>
  /**
   * Tags associated with the experiment
   */
  tags?: Array<string>
  /**
   * How long the experiment is expected to last in days
   */
  duration?: number
  /**
   * Target exposures for the experiment
   */
  targetExposures?: number
  /**
   * Restrict your experiment to users passing the selected feature gate
   */
  targetingGateID?: string | null
  /**
   * Apply sequential testing?
   */
  sequentialTesting?: boolean
  /**
   * Is Bonferroni correction applied per variant?
   */
  bonferroniCorrection?: boolean
  /**
   * Is Bonferroni correction applied per metric?
   */
  bonferroniCorrectionPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per variant?
   */
  benjaminiHochbergPerVariant?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per metric?
   */
  benjaminiHochbergPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied for primary metrics only?
   */
  benjaminiPrimaryMetricsOnly?: boolean
  /**
   * Default error margin used for results
   */
  defaultConfidenceInterval?: '80' | '90' | '95' | '98' | '99'
  /**
   * Up to 10 manually set quality scores for an experiment. The scores and weights will be added to the existing weights and scores, and then weights will be renormalized to 100. This can be set via the Statsig Console API. If targeting a default check, the weight of the check will be updated, but not the status or description. A default score can be removed by setting the weight to 0. The default score identifiers are one of: HYPOTHESIS_LENGTH, BALANCED_EXPOSURE, PRIMARY_METRICS_LENGTH, COMPARISON_CORRECTION, GUARDRAIL_METRIC_TAGS, SUFFICIENT_SAMPLE, POWER_ANALYSIS, SEQUENTIAL_TESTING
   */
  manualQualityScores?: Array<{
    criteriaName:
      | 'HYPOTHESIS_LENGTH'
      | 'BALANCED_EXPOSURE'
      | 'PRIMARY_METRICS_LENGTH'
      | 'COMPARISON_CORRECTION'
      | 'GUARDRAIL_METRIC_TAGS'
      | 'SUFFICIENT_SAMPLE'
      | 'POWER_ANALYSIS'
      | 'SEQUENTIAL_TESTING'
      | string
    status: 'PASSED' | 'FAILED' | 'WARNING'
    criteriaDescription: string
    score: number
    weight: number
  }>
  /**
   * The current status of the experiment
   */
  status?: 'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
  /**
   * ID of the launched group, null otherwise
   */
  launchedGroupID?: string | null
  /**
   * Source name of the assignment
   */
  assignmentSourceName?: string
  /**
   * Name of the source experiment for assignment
   */
  assignmentSourceExperimentName?: string
  /**
   * The Statsig ID of the creator of this experiment
   */
  creatorID?: string | null
  /**
   * The email of the creator of this experiment
   */
  creatorEmail?: string | null
  /**
   * For Warehouse Native
   */
  isAnalysisOnly?: boolean | null
  /**
   * The team name associated with the experiment, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the experiment, Enterprise only.
   */
  teamID?: string | null
  /**
   * Warehouse Native Only - Allocation duration in days
   */
  allocationDuration?: number | null
  /**
   * Warehouse Native Only - Cohorted analysis duration in days
   */
  cohortedAnalysisDuration?: number
  /**
   * Warehouse Native Only - Allow cohort metrics to mature after experiment end
   */
  cohortedMetricsMatureAfterEnd?: boolean
  /**
   * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
   */
  cohortWaitUntilEndToInclude?: boolean
  /**
   * Fixed analysis duration in days
   */
  fixedAnalysisDuration?: number
  /**
   * Warehouse Native only - UTC hour at which to run scheduled pulse loads
   */
  scheduledReloadHour?: number | null
  /**
   * Warehouse Native only - reload type for scheduled reloads
   */
  scheduledReloadType?: 'full' | 'incremental'
  /**
   * Warehouse Native only - end time for analysis only experiments
   */
  analysisEndTime?: string
  /**
   * Array of criteria for filtering assignment sources.
   */
  assignmentSourceFilters?: Array<{
    /**
     * Column to filter on.
     */
    column?: string
    condition:
      | 'in'
      | 'not_in'
      | '='
      | '>'
      | '<'
      | '>='
      | '<='
      | 'is_null'
      | 'non_null'
      | 'contains'
      | 'not_contains'
      | 'sql_filter'
      | 'starts_with'
      | 'ends_with'
      | 'after_exposure'
      | 'before_exposure'
      | 'is_true'
      | 'is_false'
    /**
     * Optional array of values for the criterion to match against.
     */
    values?: Array<string>
  }>
  /**
   * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
   */
  analyticsType?: 'frequentist' | 'bayesian' | 'sprt'
  /**
   * Whether this is a Statsig Sidecar experiment.
   */
  isSidecar?: boolean
  /**
   * Experiment notes reported after experiment completes
   */
  decisionReason?: string
}

export type ExperimentPulseResultsDto = {
  ds: string
  primaryMetrics: Array<{
    metricID: string
    metricName: string
    /**
     * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
     */
    directionality: 'increase' | 'decrease'
    absoluteChange?: number
    /**
     * Absolute confidence interval delta
     */
    confidenceIntervalDelta?: number
    percentChange?: number
    sequentialTestingConfidenceIntervalDelta?: number
    percentConfidenceIntervalDelta?: number
    percentSequentialTestingConfidenceIntervalDelta?: number
    testMean?: number
    controlMean?: number
    testStd?: number
    controlStd?: number
    testUnits?: number
    controlUnits?: number
    pValue?: number
    absoluteToplineImpact?: number
    absoluteToplineImpactDelta?: number
    relativeToplineImpact?: number
    relativeToplineImpactDelta?: number
    projectedAbsoluteToplineImpact?: number
    projectedAbsoluteToplineImpactDelta?: number
    projectedRelativeToplineImpact?: number
    projectedRelativeToplineImpactDelta?: number
  }>
  secondaryMetrics: Array<{
    metricID: string
    metricName: string
    /**
     * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
     */
    directionality: 'increase' | 'decrease'
    absoluteChange?: number
    /**
     * Absolute confidence interval delta
     */
    confidenceIntervalDelta?: number
    percentChange?: number
    sequentialTestingConfidenceIntervalDelta?: number
    percentConfidenceIntervalDelta?: number
    percentSequentialTestingConfidenceIntervalDelta?: number
    testMean?: number
    controlMean?: number
    testStd?: number
    controlStd?: number
    testUnits?: number
    controlUnits?: number
    pValue?: number
    absoluteToplineImpact?: number
    absoluteToplineImpactDelta?: number
    relativeToplineImpact?: number
    relativeToplineImpactDelta?: number
    projectedAbsoluteToplineImpact?: number
    projectedAbsoluteToplineImpactDelta?: number
    projectedRelativeToplineImpact?: number
    projectedRelativeToplineImpactDelta?: number
  }>
  otherMetrics?: Array<{
    metricID: string
    metricName: string
    /**
     * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
     */
    directionality: 'increase' | 'decrease'
    absoluteChange?: number
    /**
     * Absolute confidence interval delta
     */
    confidenceIntervalDelta?: number
    percentChange?: number
    sequentialTestingConfidenceIntervalDelta?: number
    percentConfidenceIntervalDelta?: number
    percentSequentialTestingConfidenceIntervalDelta?: number
    testMean?: number
    controlMean?: number
    testStd?: number
    controlStd?: number
    testUnits?: number
    controlUnits?: number
    pValue?: number
    absoluteToplineImpact?: number
    absoluteToplineImpactDelta?: number
    relativeToplineImpact?: number
    relativeToplineImpactDelta?: number
    projectedAbsoluteToplineImpact?: number
    projectedAbsoluteToplineImpactDelta?: number
    projectedRelativeToplineImpact?: number
    projectedRelativeToplineImpactDelta?: number
  }>
}

export type ExperimentStartDto = {
  /**
   * For Warehouse Native analysis-only experiments; start time of experiment analysis.
   */
  analysisStartTime?: string
  /**
   * For Warehouse Native analysis-only experiments; end time of experiment analysis.
   */
  analysisEndTime?: string
}

/**
 * Schema for updating the status of an experiment
 */
export type ExperimentStatusUpdateDto = {
  /**
   * The ID of the group to launch
   */
  id: string
  /**
   * The reason for making the decision to update the experiment status
   */
  decisionReason: string
  /**
   * Indicates whether to remove targeting from the experiment
   */
  removeTargeting?: boolean
}

export type ExposureCountDto = {
  /**
   * ids of gates to query (max 25)
   */
  gates: Array<{
    id: string
    pastDay: number
    past7Days: number
  }>
  /**
   * ids of experiments to query (max 25)
   */
  experiments: Array<{
    id: string
    pastDay: number
    past7Days: number
  }>
  /**
   * ids of dynamic configs to query (max 25)
   */
  dynamicConfigs: Array<{
    id: string
    pastDay: number
    past7Days: number
  }>
}

export type ExternalExperimentDto = {
  reviewSettings?: {
    requiredReview: boolean
    allowedReviewers?: Array<{
      id: string
      name: string
      email: string
    }> | null
  }
  activeReview?: {
    reviewID: string
    reviewStatus: string
    description: string
  }
  /**
   * ID
   */
  id: string
  /**
   * The display name of the experiment
   */
  name?: string
  idType: string
  /**
   * A helpful summary of what this experiment does
   */
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  /**
   * The Statsig ID of the creator of this experiment
   */
  creatorID?: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  /**
   * The email of the creator of this experiment
   */
  creatorEmail?: string | null
  tags: Array<string>
  /**
   * Target apps assigned to this experiment
   */
  targetApps?: string | Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * The team name associated with the experiment, Enterprise only.
   */
  team?: string | null
  /**
   * The team ID associated with the experiment, Enterprise only.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  /**
   * The secondary ID type for the experiment used in WHN for ID resolution
   */
  secondaryIDType?: string | null
  /**
   * The identifier mapping mode for the experiment used in WHN for ID resolution
   */
  identifierMappingMode?: 'strictOneToOne' | 'firstTouchOneToMany' | 'lastTouchOneToMany'
  /**
   * The identity resolution entity property source for the experiment used in WHN for ID resolution
   */
  identityResolutionSource?: string | null
  /**
   * A statement that will be tested by this experiment
   */
  hypothesis: string
  /**
   * Links to relevant documentation or resources
   */
  links?: Array<{
    /**
     * The URL of the link
     */
    url: string
    /**
     * The title of the link
     */
    title?: string
  }>
  /**
   * The test groups for your experiment
   */
  groups: Array<{
    name: string
    id?: string | null
    size: number
    parameterValues: {
      [key: string]: unknown
    }
    disabled?: boolean
    description?: string
    foreignGroupID?: string
  }>
  /**
   * Optional control group ID
   */
  controlGroupID?: string
  /**
   * Percent of layer allocated to this experiment
   */
  allocation: number
  /**
   * Primary metric tags for the experiment
   */
  primaryMetricTags?: Array<string>
  /**
   * Secondary metric tags for the experiment
   */
  secondaryMetricTags?: Array<string>
  primaryMetrics: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  secondaryMetrics: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * Additional metrics you want to investigate or learn from. The usual corrections applied to Primary and Secondary metrics are not applied to these.
   */
  otherMetrics?: Array<{
    name: string
    type: string
    direction?: 'increase' | 'decrease'
    hypothesizedValue?: number
  }>
  /**
   * How long the experiment is expected to last in days
   */
  duration?: number
  /**
   * Target exposures for the experiment
   */
  targetExposures?: number
  /**
   * Restrict your experiment to users passing the selected feature gate
   */
  targetingGateID: string | null
  /**
   * Apply sequential testing?
   */
  sequentialTesting?: boolean
  /**
   * Is Bonferroni correction applied per variant?
   */
  bonferroniCorrection: boolean
  /**
   * Is Bonferroni correction applied per metric?
   */
  bonferroniCorrectionPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per variant?
   */
  benjaminiHochbergPerVariant?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied per metric?
   */
  benjaminiHochbergPerMetric?: boolean
  /**
   * Is Benjamini-Hochberg procedure applied for primary metrics only?
   */
  benjaminiPrimaryMetricsOnly?: boolean
  /**
   * Default error margin used for results
   */
  defaultConfidenceInterval: '80' | '90' | '95' | '98' | '99'
  /**
   * Up to 10 manually set quality scores for an experiment. The scores and weights will be added to the existing weights and scores, and then weights will be renormalized to 100. This can be set via the Statsig Console API. If targeting a default check, the weight of the check will be updated, but not the status or description. A default score can be removed by setting the weight to 0. The default score identifiers are one of: HYPOTHESIS_LENGTH, BALANCED_EXPOSURE, PRIMARY_METRICS_LENGTH, COMPARISON_CORRECTION, GUARDRAIL_METRIC_TAGS, SUFFICIENT_SAMPLE, POWER_ANALYSIS, SEQUENTIAL_TESTING
   */
  manualQualityScores?: Array<{
    criteriaName:
      | 'HYPOTHESIS_LENGTH'
      | 'BALANCED_EXPOSURE'
      | 'PRIMARY_METRICS_LENGTH'
      | 'COMPARISON_CORRECTION'
      | 'GUARDRAIL_METRIC_TAGS'
      | 'SUFFICIENT_SAMPLE'
      | 'POWER_ANALYSIS'
      | 'SEQUENTIAL_TESTING'
      | string
    status: 'PASSED' | 'FAILED' | 'WARNING'
    criteriaDescription: string
    score: number
    weight: number
  }>
  /**
   * The current status of the experiment
   */
  status: 'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
  /**
   * ID of the launched group, null otherwise
   */
  launchedGroupID?: string | null
  assignmentSourceName?: string
  /**
   * Name of the source experiment for assignment
   */
  assignmentSourceExperimentName?: string
  isAnalysisOnly?: boolean
  /**
   * Warehouse Native Only - Allocation duration in days
   */
  allocationDuration?: number | null
  /**
   * Warehouse Native Only - Cohorted analysis duration in days
   */
  cohortedAnalysisDuration?: number
  /**
   * Warehouse Native Only - Allow cohort metrics to mature after experiment end
   */
  cohortedMetricsMatureAfterEnd?: boolean
  /**
   * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
   */
  cohortWaitUntilEndToInclude?: boolean
  /**
   * Fixed analysis duration in days
   */
  fixedAnalysisDuration?: number
  /**
   * Warehouse Native only - UTC hour at which to run scheduled pulse loads
   */
  scheduledReloadHour?: number | null
  /**
   * Warehouse Native only - reload type for scheduled reloads
   */
  scheduledReloadType?: 'full' | 'incremental'
  analysisEndTime?: string
  /**
   * Array of criteria for filtering assignment sources.
   */
  assignmentSourceFilters?: Array<{
    /**
     * Column to filter on.
     */
    column?: string
    condition:
      | 'in'
      | 'not_in'
      | '='
      | '>'
      | '<'
      | '>='
      | '<='
      | 'is_null'
      | 'non_null'
      | 'contains'
      | 'not_contains'
      | 'sql_filter'
      | 'starts_with'
      | 'ends_with'
      | 'after_exposure'
      | 'before_exposure'
      | 'is_true'
      | 'is_false'
    /**
     * Optional array of values for the criterion to match against.
     */
    values?: Array<string>
  }>
  analyticsType?: string | null
  /**
   * Whether this is a Statsig Sidecar experiment.
   */
  isSidecar?: boolean
  decisionReason: string | null
  subtype?: 'conversion' | 'reactivation' | 'retention'
  externalExperimentName?: string
  layerID: string | null
  startTime: number | null
  endTime: number | null
  decisionTime: number | null
  healthChecks?: Array<{
    name: string
    description: string
    status: 'PASSED' | 'FAILED' | 'WAITING' | 'WARNING'
    metadata?: {
      type: string
      lastPulseLoadTime?: number
      crossoverPercent?: number
      assignmentSourceID?: string
      assignmentSourceName?: string
      foreignExperimentID?: string
      deduplication_rate?: number
      deduplication_rates?: Array<{
        group_id: string
        rate: number
        group_name: string
      }>
      primary_id_type: string
      secondary_id_type?: string
      missingMetrics?: Array<string>
      metrics?: Array<{
        metric_name: string
        earliest_date: string | null
        latest_date: string | null
      }>
      lastUpdatedDs?: string
    }
    type?:
      | 'has_checks'
      | 'has_valid_unit_type'
      | 'has_balanced_exposures'
      | 'has_event_metrics'
      | 'has_pulse_metrics'
      | 'assignment_health'
      | 'has_crossover'
      | 'has_exposures'
      | 'has_recent_exposures_for_analyze_whn'
      | 'user_metrics_exist'
      | 'deduplication_rate'
      | 'deduplication_rate_group_level'
      | 'windowed_metrics_have_outliers'
      | 'exposures_data_is_behind'
      | 'pre_experimental_bias_check'
      | 'segments_of_interest_analysis'
      | 'has_changed_parameter'
      | 'metric_history_for_topline_impact'
      | 'default_value_mismatch'
      | 'has_data_gaps'
      | 'has_correct_target_app'
      | 'has_dag_failures'
      | 'has_exploration_completed'
      | 'autotune_has_outcomes'
  }>
  /**
   * Overall health check status
   */
  healthCheckStatus: 'PASSED' | 'FAILED' | 'WAITING' | 'WARNING'
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  inlineTargetingRulesJSON?: string | null
  summarySections?: Array<{
    name: string
    content: string | null
  }> | null
}

export type ExternalGateDto = {
  /**
   * ID
   */
  id: string
  name?: string
  idType?: string
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  creatorID?: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  creatorEmail?: string | null
  tags?: Array<string>
  targetApps?: string | Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  team?: string | null
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  checksPerHour: number | null
  status: 'In Progress' | 'Launched' | 'Disabled' | 'Archived'
  type: 'TEMPORARY' | 'PERMANENT' | 'STALE' | 'TEMPLATE'
  typeReason:
    | 'NONE'
    | 'STALE_PROBABLY_LAUNCHED'
    | 'STALE_PROBABLY_UNLAUNCHED'
    | 'STALE_PROBABLY_FORGOTTEN'
    | 'STALE_NO_RULES'
    | 'STALE_PROBABLY_DEAD_CHECK'
    | 'STALE_EMPTY_CHECKS'
    | 'STALE_ALL_TRUE'
    | 'STALE_ALL_FALSE'
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  isTemplate?: boolean
  isEnabled: boolean
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
  measureMetricLifts?: boolean
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
  reviewSettings?: {
    requiredReview: boolean
    allowedReviewers?: Array<{
      id: string
      name: string
      email: string
    }> | null
  }
  releasePipelineID?: string | null
  activeReview?: {
    reviewID: string
    reviewStatus: string
    description: string
  }
}

export type ExternalMetricDefinitionContractDto = {
  /**
   * The name of the metric, serving as its primary identifier.
   */
  name: string
  /**
   * The type of the metric, defining its aggregation method and characteristics.
   */
  type:
    | 'ratio'
    | 'sum'
    | 'composite'
    | 'mean'
    | 'event_count_custom'
    | 'event_user'
    | 'funnel'
    | 'undefined'
    | 'setup_incomplete'
    | 'composite_sum'
    | 'import_window'
    | 'user_warehouse'
    | 'count_distinct'
  /**
   * Marks the metric as verified, indicating trustworthiness within the organization.
   */
  isVerified?: boolean
  /**
   * Set to true to make the metric definition editable only through the Console API.
   */
  isReadOnly?: boolean
  /**
   * Array of unit types associated with the metric, such as stableID or userID.
   */
  unitTypes?: Array<string>
  /**
   * An array of event definitions used to compute the metric.
   */
  metricEvents?: Array<{
    /**
     * The name of the metric event.
     */
    name: string
    /**
     * The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
     */
    type?: 'count' | 'count_distinct' | 'value' | 'metadata'
    /**
     * The key for associated metadata, if applicable.
     */
    metadataKey?: string
    /**
     * Filtering criteria for the metric event, including conditions and values to refine the event data.
     */
    criteria?: Array<MetricEventsCriteriaDto>
  }>
  /**
   * List of input metrics used to calculate the new metric for composite types.
   */
  metricComponentMetrics?: Array<{
    name: string
    type: string
  }>
  /**
   * An optional description providing additional context about the metric.
   */
  description?: string
  /**
   * Specifies the desired directionality for the metric, indicating whether an increase or decrease is favorable.
   */
  directionality: 'increase' | 'decrease'
  /**
   * Optional tags for categorizing the metric and improving searchability.
   */
  tags?: Array<string>
  /**
   * Indicates whether the metric is permanent and should not be deleted.
   */
  isPermanent?: boolean
  /**
   * Time window for the metric rollup. Specify "custom" for a customized time window.
   */
  rollupTimeWindow?: string
  /**
   * Custom time window start date in days since exposure.
   */
  customRollUpStart?: number
  /**
   * Custom time window end date in days since exposure.
   */
  customRollUpEnd?: number
  /**
   * List of events used to create funnel metrics.
   */
  funnelEventList?: Array<{
    /**
     * The name of the funnel event used in the metric.
     */
    name: string
    /**
     * The type of funnel event, specifying how the event is tracked.
     */
    type: 'event_dau' | 'event_user' | 'event_count' | 'event_count_custom'
  }>
  /**
   * Specifies whether to count events or distinct users for the funnel metric.
   */
  funnelCountDistinct?: 'events' | 'users'
  /**
   * Defines warehouse native metrics for advanced configurations.
   */
  warehouseNative?: {
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    aggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * For Count, Sum, Mean, User Count aggregation types: the name of metric source
     */
    metricSourceName?: string
    /**
     * Filtering criteria for the metric source
     */
    criteria?: Array<MetricEventsCriteriaDto>
    waitForCohortWindow?: boolean
    /**
     * Filtering criteria for the denominator metric source, if this metric is a ratio
     */
    denominatorCriteria?: Array<MetricEventsCriteriaDto>
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    denominatorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Custom end window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupEnd?: number
    /**
     * Custom start window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupStart?: number
    /**
     * Name of the metric source for the denominator.
     */
    denominatorMetricSourceName?: string
    /**
     * Rollup-mode for ratio denominator unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    denominatorRollupTimeWindow?: string
    /**
     * Column name for the denominatorâ€™s value.
     */
    denominatorValueColumn?: string
    /**
     * Duration for counting funnel events in days.
     */
    funnelCalculationWindow?: number
    /**
     * Allowed: usersâ”ƒsessions for distinct count method in funnel events.
     */
    funnelCountDistinct?: 'sessions' | 'users'
    /**
     * List of funnel events with associated criteria and identifiers.
     */
    funnelEvents?: Array<{
      /**
       * Optional array of criteria to filter the funnel events, defined by various types and conditions.
       */
      criteria?: Array<MetricEventsCriteriaDto>
      /**
       * Optional name of the metric source associated with the funnel event.
       */
      metricSourceName?: string
      /**
       * Optional step name for the funnel event, can be null if not specified.
       */
      name?: string | null
      /**
       * Name of column which being used as session identifier. Funnel event with the same metric source
       */
      sessionIdentifierField?: string | null
    }>
    /**
     * Allowed: start_eventâ”ƒexposure to determine funnel start criteria.
     */
    funnelStartCriteria?: 'start_event' | 'exposure'
    /**
     * Specify metadata columns for breaking down metric analysis.
     */
    metricDimensionColumns?: Array<string>
    /**
     * Number of days for metric baking; specify duration for analysis.
     */
    metricBakeDays?: number
    /**
     * Aggregation type for numerator; Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile.
     */
    numeratorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Column name representing the metricâ€™s value.
     */
    valueColumn?: string
    /**
     * Threshold value for filtering metrics.
     */
    valueThreshold?: number
    /**
     * Include units which do not have a denominator. Only applicable to ratios.
     */
    allowNullRatioDenominator?: boolean
    funnelStrictOrdering?: boolean
    funnelUseExposureAsFirstEvent?: boolean
    funnelTimestampAllowanceMs?: number
    funnelTimeToConvert?: boolean
    /**
     * High threshold for winsorization; must be between 0 and 1.
     */
    winsorizationHigh?: number
    /**
     * Low threshold for winsorization; must be between 0 and 1.
     */
    winsorizationLow?: number
    winsorizationHighDenominator?: number
    winsorizationLowDenominator?: number
    /**
     * Attribution window for CUPED adjustments in days.
     */
    cupedAttributionWindow?: number | null
    /**
     * Rollup-mode for unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    rollupTimeWindow?: string
    /**
     * Custom start window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpStart?: number
    /**
     * Custom end window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpEnd?: number
    /**
     * Flag to include only users with a conversion event in the metric.
     */
    onlyIncludeUsersWithConversionEvent?: boolean
    /**
     * Flag to measure the denominator custom rollup window in minutes instead of days.
     */
    denominatorCustomRollupMeasureInMinutes?: boolean
    /**
     * Flag to measure the custom rollup window in minutes instead of days.
     */
    customRollupMeasureInMinutes?: boolean
    /**
     * Percentile value for statistical calculations.
     */
    percentile?: number
    /**
     * Use log transform for the metric.
     */
    useLogTransform?: boolean
    /**
     * Use secondary retention event.
     */
    useSecondaryRetentionEvent?: boolean
    /**
     * Retention end.
     */
    retentionEnd?: number
    /**
     * Retention length.
     */
    retentionLength?: number
    /**
     * Log transform base to be used for the metric.
     */
    logTransformBase?: number | null
    /**
     * Maximum cap for metric values.
     */
    cap?: number
    /**
     * Mean Squared Error for surrogate metric.
     */
    surrogateMetricMSE?: number | null
  }
  /**
   * The team associated with the metric, applicable for enterprise environments.
   */
  team?: string | null
  /**
   * The team ID associated with the metric, applicable for enterprise environments.
   */
  teamID?: string | null
  /**
   * Skips persisting the metric (used to validate that inputs are correct)
   */
  dryRun?: boolean
  /**
   * Unique identifier for the metric, used for referencing within the system.
   */
  id: string
  /**
   * Indicates if the metric is hidden from the user interface.
   */
  isHidden?: boolean
  lineage: {
    /**
     * List of event names that contribute to the metricâ€™s calculation.
     */
    events: Array<string>
    /**
     * List of metric names that are part of this metricâ€™s lineage.
     */
    metrics: Array<string>
  }
  /**
   * Name of the person who created the metric, if available.
   */
  creatorName?: string | null
  /**
   * Email address of the metric creator for contact purposes.
   */
  creatorEmail?: string | null
  /**
   * Timestamp indicating when the metric was created.
   */
  createdTime?: number
  /**
   * ID of the last modifier.
   */
  lastModifierID?: string | null
  /**
   * Time of the last modification to this metric.
   */
  lastModifiedTime?: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail?: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName?: string | null
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
    /**
     * The name of the owner.
     */
    name: string
  }
}

/**
 * Create a new gate
 */
export type GateCreateDto = {
  name?: string
  isEnabled?: boolean
  description?: string
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
  tags?: Array<string>
  type?: 'PERMANENT' | 'TEMPORARY'
  idType?: string
  targetApps?: string | Array<string>
  creatorID?: string | null
  creatorEmail?: string | null
  team?: string | null
  teamID?: string | null
  measureMetricLifts?: boolean
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
  /**
   * Whether reviews are required for this gate. If a gate has reviews required due to a project-level or team-level setting, setting this will have no effect.
   */
  reviewSettings?: {
    requiredReview: boolean
  }
  releasePipelineID?: string | null
  id?: string
  isTemplate?: boolean
}

export type GateFullUpdateDto = {
  name?: string
  isEnabled: boolean
  description: string
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
  tags?: Array<string>
  type?: 'PERMANENT' | 'TEMPORARY'
  idType?: string
  targetApps?: string | Array<string>
  creatorID?: string | null
  creatorEmail?: string | null
  team?: string | null
  teamID?: string | null
  measureMetricLifts?: boolean
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
  /**
   * Whether reviews are required for this gate. If a gate has reviews required due to a project-level or team-level setting, setting this will have no effect.
   */
  reviewSettings?: {
    requiredReview: boolean
  }
  releasePipelineID?: string | null
}

export type GatePartialUpdateDto = {
  name?: string
  isEnabled?: boolean
  description?: string
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
  tags?: Array<string>
  type?: 'PERMANENT' | 'TEMPORARY'
  idType?: string
  targetApps?: string | Array<string>
  creatorID?: string | null
  creatorEmail?: string | null
  team?: string | null
  teamID?: string | null
  measureMetricLifts?: boolean
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
  /**
   * Whether reviews are required for this gate. If a gate has reviews required due to a project-level or team-level setting, setting this will have no effect.
   */
  reviewSettings?: {
    requiredReview: boolean
  }
  releasePipelineID?: string | null
}

export type GatePulseResultsDto = {
  ds: string
  monitoringMetrics: Array<{
    metricID: string
    metricName: string
    /**
     * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
     */
    directionality: 'increase' | 'decrease'
    absoluteChange?: number
    /**
     * Absolute confidence interval delta
     */
    confidenceIntervalDelta?: number
    percentChange?: number
    sequentialTestingConfidenceIntervalDelta?: number
    percentConfidenceIntervalDelta?: number
    percentSequentialTestingConfidenceIntervalDelta?: number
    testMean?: number
    controlMean?: number
    testStd?: number
    controlStd?: number
    testUnits?: number
    controlUnits?: number
    pValue?: number
    absoluteToplineImpact?: number
    absoluteToplineImpactDelta?: number
    relativeToplineImpact?: number
    relativeToplineImpactDelta?: number
    projectedAbsoluteToplineImpact?: number
    projectedAbsoluteToplineImpactDelta?: number
    projectedRelativeToplineImpact?: number
    projectedRelativeToplineImpactDelta?: number
  }>
}

export type GateRulesDto = {
  /**
   * Gate Rules
   */
  rules: Array<{
    [key: string]: unknown
  }>
}

export type HoldoutCreateContractDto = {
  /**
   * name of the holdout
   */
  name: string
  /**
   * description of the holdout
   */
  description?: string
  /**
   * type of id
   */
  idType?: string
  /**
   * id of the team
   */
  teamID?: string | null
}

export type HoldoutDto = {
  /**
   * ID
   */
  id: string
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * type of id
   */
  idType: string
  /**
   * brief summary of what the holdout is being used for
   */
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  /**
   * ID of the user who created the entity.
   */
  creatorID: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  /**
   * Email of the creator.
   */
  creatorEmail: string | null
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * List of target applications associated with this configuration.
   */
  targetApps?: Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * Optional name for the responsible team.
   */
  team?: string | null
  /**
   * Optional ID of the responsible team.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  /**
   * enable or disable the holdout
   */
  isEnabled: boolean
  /**
   * percentage of users between 0-10% to pass through the holdout
   */
  passPercentage: number
  /**
   * an array of gateIDs which this holdout is applied to
   */
  gateIDs: Array<string>
  /**
   * an array of experimentIDs which this holdout is applied to
   */
  experimentIDs: Array<string>
  /**
   * an array of layerIDs which this holdout is applied to
   */
  layerIDs: Array<string>
  /**
   * whether the holdout is being applied to all new gates
   */
  isGlobal: boolean
  /**
   * the gateID that the holdout is targeting
   */
  targetingGateID: string | null
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
}

export type HoldoutFullUpdateContractDto = {
  /**
   * enable or disable the holdout
   */
  isEnabled: boolean
  /**
   * brief summary of what the holdout is being used for
   */
  description: string
  /**
   * percentage of users between 0-10% to pass through the holdout
   */
  passPercentage: number
  /**
   * an array of gateIDs which this holdout is applied to
   */
  gateIDs: Array<string>
  /**
   * an array of experimentIDs which this holdout is applied to
   */
  experimentIDs: Array<string>
  /**
   * an array of layerIDs which this holdout is applied to
   */
  layerIDs: Array<string>
  /**
   * whether the holdout is being applied to all new gates
   */
  isGlobal: boolean
  /**
   * the gateID that the holdout is targeting
   */
  targetingGateID: string | null
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
}

export type HoldoutPartialUpdateContractDto = {
  /**
   * enable or disable the holdout
   */
  isEnabled?: boolean
  /**
   * brief summary of what the holdout is being used for
   */
  description?: string
  /**
   * percentage of users between 0-10% to pass through the holdout
   */
  passPercentage?: number
  /**
   * an array of gateIDs which this holdout is applied to
   */
  gateIDs?: Array<string>
  /**
   * an array of experimentIDs which this holdout is applied to
   */
  experimentIDs?: Array<string>
  /**
   * an array of layerIDs which this holdout is applied to
   */
  layerIDs?: Array<string>
  /**
   * whether the holdout is being applied to all new gates
   */
  isGlobal?: boolean
  /**
   * the gateID that the holdout is targeting
   */
  targetingGateID?: string | null
  monitoringMetrics?: Array<{
    name: string
    type: string
  }>
}

/**
 * Schema for a list of IDs with a name and count
 */
export type IdListDto = {
  /**
   * The name associated with the list of IDs
   */
  name: string
  /**
   * The count of IDs in the list
   */
  count: number
  /**
   * The array of IDs
   */
  ids: Array<string>
}

export type IdListMetadataDto = {
  /**
   * The current version of the ID list
   */
  currentVersion?: number
  /**
   * If the ID list is currently being updated
   */
  isUpdating?: boolean
}

export type IngestionBackfillContractDto = {
  /**
   * Expected valid date in the form of YYYY-MM-DD
   */
  datestamp_start: string
  /**
   * Expected valid date in the form of YYYY-MM-DD
   */
  datestamp_end: string
  type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
  source?: string | Array<string> | null
  dataset: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
}

export type IngestionBackfillDataDto = {
  runID: string
}

export type IngestionCreateDatabricksConnectionContractDto = {
  token: string
  host: string
  path: string
  deltaSharingCredentials?: string
  verified?: boolean
}

export type IngestionDto = {
  id: string
  type: string
  enabled: boolean
  data: {
    [key: string]: unknown
  }
}

export type IngestionEventCountResponseDto =
  | Array<{
      date: string
      event: string
      count: number
      last_updated_time: string
    }>
  | Array<{
      date: string
      events: Array<{
        event: string
        count: number
        last_updated_time: string
      }>
    }>

export type IngestionEventDeltaResponseDto =
  | Array<{
      date: string
      source: string
      event: string
      internal_count: number
      external_count: number
      has_diff: boolean
      threshold: number
      last_updated_time: string
    }>
  | Array<{
      date: string
      events: Array<{
        source: string
        event: string
        internal_count: number
        external_count: number
        has_diff: boolean
        threshold: number
        last_updated_time: string
      }>
    }>

export type IngestionRunDataContractDto = {
  runID: string
  latestStatus: string
  lastUpdatedAt: string
  createdAt: string
  trigger: string
  sources: Array<string>
  dateStamps: Array<string>
  runHistory: Array<{
    statusTimestamp: string
    status: string
  }>
  granularHistory: Array<{
    source: string
    latestSourceStatus: string
    statusByDate: Array<{
      dateStamp: string
      statuses: Array<{
        statusTimestamp: string
        status: string
      }>
    }>
  }>
}

export type IngestionScheduleDto = {
  dataset: string
  scheduled_hour_pst: number
}

export type IngestionScheduleUpdateContractDto = {
  dataset: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
  scheduled_hour_pst?: number
}

export type IngestionSourceCreateContractDto =
  | {
      dataset: 'Metrics'
      column_mapping?: {
        /**
         * The unique user identifier this metric is for. This might not necessarily be a user_id - it could be a custom_id of some kind. Make sure this is in the same format as your logged unit_ids.
         */
        unit_id: string
        /**
         * The id_type the unit_id represents. Must be valid id_type. Default Statsig types are user_id/stable_id, but you may have generated custom id_types. Make sure this matches (case sensitive) a customID in your project, or you wonâ€™t get experiment results.
         */
        id_type: string
        /**
         * Date of the daily metric, ISO formatted (ex. 2021-02-17). Weâ€™ll load custom metrics to whatever date you use here.
         */
        dateid: string
        /**
         * String format. Not null. Length < 128 characters.
         */
        metric_name: string
        /**
         * Numeric value for the metric. This OR both of numerator and denominator need to be provided.
         */
        metric_value?: string
        /**
         * Required for ratio metrics. If present along with a denominator in any record, the metric will be treated as ratio and only calculated for users with non-null denominators
         */
        numerator?: string
        /**
         * Required for ratio metrics. If present along with a numerator in any record, the metric will be treated as ratio and only calculated for users with non-null numerators.
         */
        denominator?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name: string
      query?: string
      use_delta_sharing?: true
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }
  | {
      dataset: 'Events'
      column_mapping?: {
        /**
         * The unique user identifier this event is for. This might not necessarily be a single column for userID - it could be spread across multiple columns for deviceID etc.
         */
        unit_id?: string
        /**
         * Name of the event. String under 128 characters, using â€˜_â€™ for spaces.
         */
        event_name: string
        /**
         * Unix timestamp in seconds of the event (ex. 1613584800)
         */
        timestamp: string
        ids: {
          [key: string]: string
        }
        metadata?: {
          [key: string]: string
        }
        metadata_object?: string
        event_value?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name: string
      query?: string
      use_delta_sharing?: true
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }
  | {
      dataset: 'Exposures' | 'export_exposures'
      column_mapping?: {
        /**
         * Unique identifier for the experiment.
         */
        experiment: string
        /**
         * Unique identifier for the experiment groups.
         */
        group_id: string
        /**
         * The unique user identifier this exposure is for. This might not necessarily be a single column for userID - it could be spread across multiple columns for deviceID etc.
         */
        unit_id?: string
        /**
         * Unix timestamp in seconds of the event (ex. 1613584800)
         */
        timestamp: string
        ids: {
          [key: string]: string
        }
        metadata?: {
          [key: string]: string
        }
        metadata_object?: string
        event_value?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name: string
      query?: string
      use_delta_sharing?: true
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }

export type IngestionStatusDto = {
  ds?: string
  ingestion_dataset: string | null
  ingestion_source: string | null
  source_name: string | null
  message: string | null
  status: string | null
  rowCount?: number
  metricCount?: number
  timestamp: string | null
}

export type IngestionUpdateContractDto =
  | {
      dataset: 'Metrics'
      column_mapping?: {
        /**
         * The unique user identifier this metric is for. This might not necessarily be a user_id - it could be a custom_id of some kind. Make sure this is in the same format as your logged unit_ids.
         */
        unit_id: string
        /**
         * The id_type the unit_id represents. Must be valid id_type. Default Statsig types are user_id/stable_id, but you may have generated custom id_types. Make sure this matches (case sensitive) a customID in your project, or you wonâ€™t get experiment results.
         */
        id_type: string
        /**
         * Date of the daily metric, ISO formatted (ex. 2021-02-17). Weâ€™ll load custom metrics to whatever date you use here.
         */
        dateid: string
        /**
         * String format. Not null. Length < 128 characters.
         */
        metric_name: string
        /**
         * Numeric value for the metric. This OR both of numerator and denominator need to be provided.
         */
        metric_value?: string
        /**
         * Required for ratio metrics. If present along with a denominator in any record, the metric will be treated as ratio and only calculated for users with non-null denominators
         */
        numerator?: string
        /**
         * Required for ratio metrics. If present along with a numerator in any record, the metric will be treated as ratio and only calculated for users with non-null numerators.
         */
        denominator?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name?: string
      query?: string
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }
  | {
      dataset: 'Events'
      column_mapping?: {
        /**
         * The unique user identifier this event is for. This might not necessarily be a single column for userID - it could be spread across multiple columns for deviceID etc.
         */
        unit_id?: string
        /**
         * Name of the event. String under 128 characters, using â€˜_â€™ for spaces.
         */
        event_name: string
        /**
         * Unix timestamp in seconds of the event (ex. 1613584800)
         */
        timestamp: string
        ids: {
          [key: string]: string
        }
        metadata?: {
          [key: string]: string
        }
        metadata_object?: string
        event_value?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name?: string
      query?: string
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }
  | {
      dataset: 'Exposures' | 'export_exposures'
      column_mapping?: {
        /**
         * Unique identifier for the experiment.
         */
        experiment: string
        /**
         * Unique identifier for the experiment groups.
         */
        group_id: string
        /**
         * The unique user identifier this exposure is for. This might not necessarily be a single column for userID - it could be spread across multiple columns for deviceID etc.
         */
        unit_id?: string
        /**
         * Unix timestamp in seconds of the event (ex. 1613584800)
         */
        timestamp: string
        ids: {
          [key: string]: string
        }
        metadata?: {
          [key: string]: string
        }
        metadata_object?: string
        event_value?: string
      }
      type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
      source_name?: string
      query?: string
      share?: string
      schema?: string
      table?: string
      enabled?: boolean
    }

export type KeyCreateContractDto = {
  description: string
  type: 'SERVER' | 'CLIENT' | 'CONSOLE' | 'SCIM'
  scopes?: Array<
    | 'omni_read_only'
    | 'omni_read_write'
    | 'client_download_config_specs'
    | 'none_hash_enabled'
    | 'can_access_keys'
    | 'client_can_write_user_store'
    | 'personal_read_only'
    | 'personal_read_write'
  >
  environments?: Array<string>
  targetAppID?: string
  secondaryTargetAppIDs?: Array<string>
}

export type KeyDto = {
  key: string | null
  type: 'SERVER' | 'CLIENT' | 'CONSOLE' | 'SCIM'
  description: string
  scopes: Array<
    | 'omni_read_only'
    | 'omni_read_write'
    | 'client_download_config_specs'
    | 'none_hash_enabled'
    | 'can_access_keys'
    | 'client_can_write_user_store'
    | 'personal_read_only'
    | 'personal_read_write'
  >
  environments?: Array<string>
  primaryTargetApp?: string | null
  secondaryTargetApps?: Array<string> | null
  status: 'active' | 'deactivated'
}

export type KeyUpdateContractDto = {
  description?: string
  scopes?: Array<
    | 'omni_read_only'
    | 'omni_read_write'
    | 'client_download_config_specs'
    | 'none_hash_enabled'
    | 'can_access_keys'
    | 'client_can_write_user_store'
    | 'personal_read_only'
    | 'personal_read_write'
  >
  environments?: Array<string>
  targetAppID?: string | null
  secondaryTargetAppIDs?: Array<string> | null
}

export type LayerContractDto = {
  /**
   * ID
   */
  id: string
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * The ID type used for this layer, important for validation.
   */
  idType: string
  /**
   * A detailed description of the layer, explaining its purpose and functionality.
   */
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  /**
   * ID of the user who created the entity.
   */
  creatorID: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  /**
   * Email of the creator.
   */
  creatorEmail: string | null
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * List of target applications that this layer is intended for.
   */
  targetApps?: string | Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * Optional name for the responsible team.
   */
  team?: string | null
  /**
   * Optional ID of the responsible team.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
  /**
   * Indicates if the layer was automatically created by Statsig during experiment creation.
   */
  isImplicitLayer: boolean
  /**
   * An array of parameters associated with the layer, each defining specific attributes.
   */
  parameters: Array<{
    /**
     * The name of this parameter, used for identification within the layer.
     */
    name: string
    /**
     * The data type that this parameter returns. Allowed types include: string, boolean, number, object, and array.
     */
    type: 'string' | 'number' | 'boolean' | 'object' | 'array'
    /**
     * The default value for this parameter, which must match the specified type.
     */
    defaultValue:
      | string
      | number
      | boolean
      | {
          [key: string]: unknown
        }
      | Array<
          | string
          | number
          | boolean
          | {
              [key: string]: unknown
            }
        >
  }>
}

export type LayerCreateContractDto = {
  /**
   * The unique name of the layer, formatted as an ID (e.g., "A Layer" becomes "a_layer").
   */
  name: string
  /**
   * A helpful description of what this layer does, providing context for its purpose.
   */
  description?: string
  /**
   * The type of ID used for this layer, essential for validation in services.
   */
  idType: string
  /**
   * List of target applications that this layer is associated with.
   */
  targetApps?: string | Array<string>
  /**
   * Optional identifier for the team responsible for this layer.
   */
  team?: string
}

export type LayerFullUpdateContractDto = {
  /**
   * A detailed description of the layer, explaining its purpose and functionality.
   */
  description: string
  /**
   * An array of parameters associated with the layer, each defining specific attributes.
   */
  parameters: Array<{
    /**
     * The name of this parameter, used for identification within the layer.
     */
    name: string
    /**
     * The data type that this parameter returns. Allowed types include: string, boolean, number, object, and array.
     */
    type: 'string' | 'number' | 'boolean' | 'object' | 'array'
    /**
     * The default value for this parameter, which must match the specified type.
     */
    defaultValue:
      | string
      | number
      | boolean
      | {
          [key: string]: unknown
        }
      | Array<
          | string
          | number
          | boolean
          | {
              [key: string]: unknown
            }
        >
  }>
  /**
   * List of target applications that this layer is intended for.
   */
  targetApps?: string | Array<string>
}

export type LayerOverridesDto = {
  conditionalOverrides: Array<{
    /**
     * Describes whether layer override is segment or gate
     */
    type: string
    /**
     * Name of override entity
     */
    name: string
    experimentName: string
    groupName: string
  }>
  idOverrides: Array<{
    /**
     * Group that ID is overriden into
     */
    groupName: string
    /**
     * ID being overriden into a particular group
     */
    ids: Array<string>
    idType?: string | null
    environment?: string | null
    experimentName?: string | null
  }>
}

export type LayerOverridesPatchDto = {
  /**
   * Add a layer override
   */
  op: 'add'
  conditionalOverrides: Array<{
    /**
     * Describes whether layer override is segment or gate
     */
    type: string
    /**
     * Name of override entity
     */
    name: string
    experimentName: string
    groupName: string
  }>
  idOverrides: Array<{
    /**
     * Group that ID is overriden into
     */
    groupName: string
    /**
     * ID being overriden into a particular group
     */
    ids: Array<string>
    idType?: string | null
    environment?: string | null
    experimentName?: string | null
  }>
}

export type LayerPartialUpdateContractDto = {
  /**
   * A detailed description of the layer, explaining its purpose and functionality.
   */
  description?: string
  /**
   * An array of parameters associated with the layer, each defining specific attributes.
   */
  parameters?: Array<{
    /**
     * The name of this parameter, used for identification within the layer.
     */
    name: string
    /**
     * The data type that this parameter returns. Allowed types include: string, boolean, number, object, and array.
     */
    type: 'string' | 'number' | 'boolean' | 'object' | 'array'
    /**
     * The default value for this parameter, which must match the specified type.
     */
    defaultValue:
      | string
      | number
      | boolean
      | {
          [key: string]: unknown
        }
      | Array<
          | string
          | number
          | boolean
          | {
              [key: string]: unknown
            }
        >
  }>
  /**
   * List of target applications that this layer is intended for.
   */
  targetApps?: string | Array<string>
}

export type LoggedEventDto = {
  /**
   * The timestamp when the event occurred, represented as a string.
   */
  timestamp: string
  /**
   * The name of the event (e.g., "add_to_cart").
   */
  name: string
  /**
   * The source of the event, indicating where it was triggered from.
   */
  source: string
  /**
   * The value associated with the event, providing additional context.
   */
  value: string
  /**
   * The ID of the user who triggered the event.
   */
  userID: string
}

export type MetricCreationContractDto = {
  /**
   * The name of the new metric, which identifies it within the system.
   */
  name: string
  type:
    | 'ratio'
    | 'mean'
    | 'event_count_custom'
    | 'event_user'
    | 'funnel'
    | 'composite'
    | 'composite_sum'
    | 'sum'
    | 'undefined'
    | 'user_warehouse'
  /**
   * Marks the metric as verified for internal trustworthiness.
   */
  isVerified?: boolean
  /**
   * Set to true to make the metric definition editable only from the Console API.
   */
  isReadOnly?: boolean
  /**
   * Array of unit types associated with the metric, such as stableID or userID.
   */
  unitTypes?: Array<string>
  /**
   * An array of event definitions used to compute the metric.
   */
  metricEvents?: Array<{
    /**
     * The name of the metric event.
     */
    name: string
    /**
     * The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
     */
    type?: 'count' | 'count_distinct' | 'value' | 'metadata'
    /**
     * The key for associated metadata, if applicable.
     */
    metadataKey?: string
    /**
     * Filtering criteria for the metric event, including conditions and values to refine the event data.
     */
    criteria?: Array<MetricEventsCriteriaDto>
  }>
  /**
   * List of input metrics used to calculate the new metric for composite types.
   */
  metricComponentMetrics?: Array<{
    name: string
    type: string
  }>
  /**
   * A description of the new metric, providing context and purpose.
   */
  description?: string
  /**
   * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
   */
  directionality?: 'increase' | 'decrease'
  /**
   * Tags associated with the metric for categorization and searchability.
   */
  tags?: Array<string> | string
  /**
   * Indicates whether the metric is permanent and should not be deleted.
   */
  isPermanent?: boolean
  /**
   * Time window for the metric rollup. Specify "custom" for a customized time window.
   */
  rollupTimeWindow?: string
  /**
   * Custom time window start date in days since exposure.
   */
  customRollUpStart?: number
  /**
   * Custom time window end date in days since exposure.
   */
  customRollUpEnd?: number
  /**
   * List of events used to create funnel metrics.
   */
  funnelEventList?: Array<{
    /**
     * The name of the funnel event used in the metric.
     */
    name: string
    /**
     * The type of funnel event, specifying how the event is tracked.
     */
    type: 'event_dau' | 'event_user' | 'event_count' | 'event_count_custom'
  }>
  /**
   * Specifies whether to count events or distinct users for the funnel metric.
   */
  funnelCountDistinct?: 'events' | 'users'
  /**
   * Defines warehouse native metrics for advanced configurations.
   */
  warehouseNative?: {
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    aggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * For Count, Sum, Mean, User Count aggregation types: the name of metric source
     */
    metricSourceName?: string
    /**
     * Filtering criteria for the metric source
     */
    criteria?: Array<MetricEventsCriteriaDto>
    waitForCohortWindow?: boolean
    /**
     * Filtering criteria for the denominator metric source, if this metric is a ratio
     */
    denominatorCriteria?: Array<MetricEventsCriteriaDto>
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    denominatorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Custom end window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupEnd?: number
    /**
     * Custom start window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupStart?: number
    /**
     * Name of the metric source for the denominator.
     */
    denominatorMetricSourceName?: string
    /**
     * Rollup-mode for ratio denominator unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    denominatorRollupTimeWindow?: string
    /**
     * Column name for the denominatorâ€™s value.
     */
    denominatorValueColumn?: string
    /**
     * Duration for counting funnel events in days.
     */
    funnelCalculationWindow?: number
    /**
     * Allowed: usersâ”ƒsessions for distinct count method in funnel events.
     */
    funnelCountDistinct?: 'sessions' | 'users'
    /**
     * List of funnel events with associated criteria and identifiers.
     */
    funnelEvents?: Array<{
      /**
       * Optional array of criteria to filter the funnel events, defined by various types and conditions.
       */
      criteria?: Array<MetricEventsCriteriaDto>
      /**
       * Optional name of the metric source associated with the funnel event.
       */
      metricSourceName?: string
      /**
       * Optional step name for the funnel event, can be null if not specified.
       */
      name?: string | null
      /**
       * Name of column which being used as session identifier. Funnel event with the same metric source
       */
      sessionIdentifierField?: string | null
    }>
    /**
     * Allowed: start_eventâ”ƒexposure to determine funnel start criteria.
     */
    funnelStartCriteria?: 'start_event' | 'exposure'
    /**
     * Specify metadata columns for breaking down metric analysis.
     */
    metricDimensionColumns?: Array<string>
    /**
     * Number of days for metric baking; specify duration for analysis.
     */
    metricBakeDays?: number
    /**
     * Aggregation type for numerator; Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile.
     */
    numeratorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Column name representing the metricâ€™s value.
     */
    valueColumn?: string
    /**
     * Threshold value for filtering metrics.
     */
    valueThreshold?: number
    /**
     * Include units which do not have a denominator. Only applicable to ratios.
     */
    allowNullRatioDenominator?: boolean
    funnelStrictOrdering?: boolean
    funnelUseExposureAsFirstEvent?: boolean
    funnelTimestampAllowanceMs?: number
    funnelTimeToConvert?: boolean
    /**
     * High threshold for winsorization; must be between 0 and 1.
     */
    winsorizationHigh?: number
    /**
     * Low threshold for winsorization; must be between 0 and 1.
     */
    winsorizationLow?: number
    winsorizationHighDenominator?: number
    winsorizationLowDenominator?: number
    /**
     * Attribution window for CUPED adjustments in days.
     */
    cupedAttributionWindow?: number | null
    /**
     * Rollup-mode for unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    rollupTimeWindow?: string
    /**
     * Custom start window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpStart?: number
    /**
     * Custom end window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpEnd?: number
    /**
     * Flag to include only users with a conversion event in the metric.
     */
    onlyIncludeUsersWithConversionEvent?: boolean
    /**
     * Flag to measure the denominator custom rollup window in minutes instead of days.
     */
    denominatorCustomRollupMeasureInMinutes?: boolean
    /**
     * Flag to measure the custom rollup window in minutes instead of days.
     */
    customRollupMeasureInMinutes?: boolean
    /**
     * Percentile value for statistical calculations.
     */
    percentile?: number
    /**
     * Use log transform for the metric.
     */
    useLogTransform?: boolean
    /**
     * Use secondary retention event.
     */
    useSecondaryRetentionEvent?: boolean
    /**
     * Retention end.
     */
    retentionEnd?: number
    /**
     * Retention length.
     */
    retentionLength?: number
    /**
     * Log transform base to be used for the metric.
     */
    logTransformBase?: number | null
    /**
     * Maximum cap for metric values.
     */
    cap?: number
    /**
     * Mean Squared Error for surrogate metric.
     */
    surrogateMetricMSE?: number | null
  }
  /**
   * The team associated with the metric, applicable for enterprise environments.
   */
  team?: string | null
  /**
   * The team ID associated with the metric, applicable for enterprise environments.
   */
  teamID?: string | null
  /**
   * Skips persisting the metric (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

/**
 * Array of event criteria for defining filtering conditions in metrics analysis.
 */
export type MetricEventsCriteriaDto = {
  /**
   * Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
   */
  type: 'value' | 'metadata' | 'user' | 'user_custom'
  /**
   * Optional column specifying which data attribute to filter on.
   */
  column?: string
  /**
   * sql_filter, start_withs, ends_with, after_exposure, and before_exposure are only applicable in Warehouse Native
   */
  condition:
    | 'in'
    | 'not_in'
    | '='
    | '>'
    | '<'
    | '>='
    | '<='
    | 'is_null'
    | 'non_null'
    | 'contains'
    | 'not_contains'
    | 'sql_filter'
    | 'starts_with'
    | 'ends_with'
    | 'after_exposure'
    | 'before_exposure'
    | 'is_true'
    | 'is_false'
  /**
   * Optional array of values for the criterion to match against.
   */
  values?: Array<string>
  /**
   * If true, overrides null values in criterion evaluation.
   */
  nullVacuousOverride?: boolean
}

export type MetricSourceContractDto = {
  /**
   * The name of the source, serving as its primary identifier.
   */
  name: string
  /**
   * A detailed description of the source, providing context and usage information.
   */
  description: string
  /**
   * Optional tags for categorizing the source and improving searchability.
   */
  tags?: Array<string>
  /**
   * The SQL query or statement used to extract data from the source.
   */
  sql: string
  /**
   * The name of the column containing timestamp data for the source.
   */
  timestampColumn: string
  /**
   * Indicates whether the timestamp should be treated as a day-level granularity.
   */
  timestampAsDay?: boolean
  /**
   * Array defining the mapping between Statsig unit IDs and their respective source columns.
   */
  idTypeMapping: Array<{
    /**
     * The identifier mapping for Statsig units.
     */
    statsigUnitID: string
    /**
     * The corresponding column name in the source that relates to the Statsig unit ID.
     */
    column: string
  }>
  /**
   * The type of source, indicating whether it is a database table or a custom query.
   */
  sourceType?: 'table' | 'query'
  /**
   * The name of the database table if the source type is "table".
   */
  tableName?: string
  /**
   * The name of the date partition column if the source type is "table". Can be undefined.
   */
  datePartitionColumn?: string
  /**
   * Optional array defining mappings for custom fields using specific formulas.
   */
  customFieldMapping?: Array<{
    /**
     * The identifier for the custom field mapping.
     */
    key: string
    /**
     * The formula or expression used to compute the custom field value.
     */
    formula: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
}

export type MetricSourceCreationContractDto = {
  /**
   * The name of the source, serving as its primary identifier.
   */
  name: string
  /**
   * An optional description for the source, providing context and details about its purpose and usage.
   */
  description?: string
  /**
   * Optional array of tags to categorize the source, facilitating easier organization and retrieval.
   */
  tags?: Array<string>
  /**
   * The SQL query or statement used to extract data from the source.
   */
  sql: string
  /**
   * The name of the column containing timestamp data for the source.
   */
  timestampColumn: string
  /**
   * Indicates whether the timestamp should be treated as a day-level granularity.
   */
  timestampAsDay?: boolean
  /**
   * Array defining the mapping between Statsig unit IDs and their respective source columns.
   */
  idTypeMapping: Array<{
    /**
     * The identifier mapping for Statsig units.
     */
    statsigUnitID: string
    /**
     * The corresponding column name in the source that relates to the Statsig unit ID.
     */
    column: string
  }>
  /**
   * The type of source, indicating whether it is a database table or a custom query.
   */
  sourceType?: 'table' | 'query'
  /**
   * The name of the database table if the source type is "table".
   */
  tableName?: string
  /**
   * The name of the date partition column if the source type is "table". Can be undefined.
   */
  datePartitionColumn?: string
  /**
   * Optional array defining mappings for custom fields using specific formulas.
   */
  customFieldMapping?: Array<{
    /**
     * The identifier for the custom field mapping.
     */
    key: string
    /**
     * The formula or expression used to compute the custom field value.
     */
    formula: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting the source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type MetricSourceUpdateContractDto = {
  /**
   * The name of the source cannot be changed in this update, ensuring the identity remains consistent.
   */
  name?: unknown
  /**
   * An optional updated description for the source, providing additional context or changes.
   */
  description?: string
  /**
   * Optional array of tags for categorizing the source, allowing for updates to its categorization.
   */
  tags?: Array<string>
  /**
   * The SQL query or statement used to extract data from the source.
   */
  sql: string
  /**
   * The name of the column containing timestamp data for the source.
   */
  timestampColumn: string
  /**
   * Indicates whether the timestamp should be treated as a day-level granularity.
   */
  timestampAsDay?: boolean
  /**
   * Array defining the mapping between Statsig unit IDs and their respective source columns.
   */
  idTypeMapping: Array<{
    /**
     * The identifier mapping for Statsig units.
     */
    statsigUnitID: string
    /**
     * The corresponding column name in the source that relates to the Statsig unit ID.
     */
    column: string
  }>
  /**
   * The type of source, indicating whether it is a database table or a custom query.
   */
  sourceType?: 'table' | 'query'
  /**
   * The name of the database table if the source type is "table".
   */
  tableName?: string
  /**
   * The name of the date partition column if the source type is "table". Can be undefined.
   */
  datePartitionColumn?: string
  /**
   * Optional array defining mappings for custom fields using specific formulas.
   */
  customFieldMapping?: Array<{
    /**
     * The identifier for the custom field mapping.
     */
    key: string
    /**
     * The formula or expression used to compute the custom field value.
     */
    formula: string
  }>
  /**
   * Specifies if the source can only be edited via the Console API.
   */
  isReadOnly?: boolean
  /**
   * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
   */
  owner?: {
    /**
     * ID of the owner
     */
    ownerID?: string
    /**
     * Type of the owner (e.g., SDK_KEY or USER)
     */
    ownerType?: string
    /**
     * The name of the owner. This field is optional.
     */
    ownerName?: string
    /**
     * The email of the owner. This field is optional.
     */
    ownerEmail?: string
  } | null
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Skips persisting updates to the source (used to validate that inputs are correct)
   */
  dryRun?: boolean
}

export type MetricsUpdateContractDto = {
  /**
   * The name of the metric, serving as its primary identifier.
   */
  name?: string
  /**
   * A detailed description of the metric, providing insights into its purpose and application.
   */
  description?: string
  /**
   * An array of tags associated with the metric, used for categorization and easier retrieval.
   */
  tags?: Array<string>
  /**
   * Flag to mark the metric as verified, ensuring it is deemed trustworthy within the organization.
   */
  isVerified?: boolean
  /**
   * Specifies if the metric definition can only be edited via the Console API, enhancing control over modifications.
   */
  isReadOnly?: boolean
  /**
   * Determines if the metric is permanent, preventing it from being deleted or modified inadvertently.
   */
  isPermanent?: boolean
  /**
   * Optional configuration for metrics utilizing Warehouse Native features, defining specific behaviors and criteria.
   */
  warehouseNative?: {
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    aggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * For Count, Sum, Mean, User Count aggregation types: the name of metric source
     */
    metricSourceName?: string
    /**
     * Filtering criteria for the metric source
     */
    criteria?: Array<MetricEventsCriteriaDto>
    waitForCohortWindow?: boolean
    /**
     * Filtering criteria for the denominator metric source, if this metric is a ratio
     */
    denominatorCriteria?: Array<MetricEventsCriteriaDto>
    /**
     * Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile
     */
    denominatorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Custom end window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupEnd?: number
    /**
     * Custom start window for ratio denominator unit count metrics with "custom" rollup time window. Measured in days or minutes depending on the "denominatorCustomRollupMeasureInMinutes" flag.
     */
    denominatorCustomRollupStart?: number
    /**
     * Name of the metric source for the denominator.
     */
    denominatorMetricSourceName?: string
    /**
     * Rollup-mode for ratio denominator unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    denominatorRollupTimeWindow?: string
    /**
     * Column name for the denominatorâ€™s value.
     */
    denominatorValueColumn?: string
    /**
     * Duration for counting funnel events in days.
     */
    funnelCalculationWindow?: number
    /**
     * Allowed: usersâ”ƒsessions for distinct count method in funnel events.
     */
    funnelCountDistinct?: 'sessions' | 'users'
    /**
     * List of funnel events with associated criteria and identifiers.
     */
    funnelEvents?: Array<{
      /**
       * Optional array of criteria to filter the funnel events, defined by various types and conditions.
       */
      criteria?: Array<MetricEventsCriteriaDto>
      /**
       * Optional name of the metric source associated with the funnel event.
       */
      metricSourceName?: string
      /**
       * Optional step name for the funnel event, can be null if not specified.
       */
      name?: string | null
      /**
       * Name of column which being used as session identifier. Funnel event with the same metric source
       */
      sessionIdentifierField?: string | null
    }>
    /**
     * Allowed: start_eventâ”ƒexposure to determine funnel start criteria.
     */
    funnelStartCriteria?: 'start_event' | 'exposure'
    /**
     * Specify metadata columns for breaking down metric analysis.
     */
    metricDimensionColumns?: Array<string>
    /**
     * Number of days for metric baking; specify duration for analysis.
     */
    metricBakeDays?: number
    /**
     * Aggregation type for numerator; Allowed: countâ”ƒsumâ”ƒmeanâ”ƒdaily_participationâ”ƒratioâ”ƒfunnelâ”ƒcount_distinctâ”ƒpercentile.
     */
    numeratorAggregation?:
      | 'count'
      | 'sum'
      | 'mean'
      | 'daily_participation'
      | 'ratio'
      | 'funnel'
      | 'count_distinct'
      | 'percentile'
      | 'first_value'
      | 'latest_value'
      | 'retention'
      | 'max'
      | 'min'
      | ''
    /**
     * Column name representing the metricâ€™s value.
     */
    valueColumn?: string
    /**
     * Threshold value for filtering metrics.
     */
    valueThreshold?: number
    /**
     * Include units which do not have a denominator. Only applicable to ratios.
     */
    allowNullRatioDenominator?: boolean
    funnelStrictOrdering?: boolean
    funnelUseExposureAsFirstEvent?: boolean
    funnelTimestampAllowanceMs?: number
    funnelTimeToConvert?: boolean
    /**
     * High threshold for winsorization; must be between 0 and 1.
     */
    winsorizationHigh?: number
    /**
     * Low threshold for winsorization; must be between 0 and 1.
     */
    winsorizationLow?: number
    winsorizationHighDenominator?: number
    winsorizationLowDenominator?: number
    /**
     * Attribution window for CUPED adjustments in days.
     */
    cupedAttributionWindow?: number | null
    /**
     * Rollup-mode for unit count metrics. Allowed values: "daily" for daily participation rate, "max" for one-time event, "custom" for a custom attribution window
     */
    rollupTimeWindow?: string
    /**
     * Custom start window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpStart?: number
    /**
     * Custom end window for unit count metrics with "custom" rollup time window, or for other metrics with the "Use Cohort Window in Experiments" option on enabled. Measured in days or minutes depending on the "customRollupMeasureInMinutes" flag.
     */
    customRollUpEnd?: number
    /**
     * Flag to include only users with a conversion event in the metric.
     */
    onlyIncludeUsersWithConversionEvent?: boolean
    /**
     * Flag to measure the denominator custom rollup window in minutes instead of days.
     */
    denominatorCustomRollupMeasureInMinutes?: boolean
    /**
     * Flag to measure the custom rollup window in minutes instead of days.
     */
    customRollupMeasureInMinutes?: boolean
    /**
     * Percentile value for statistical calculations.
     */
    percentile?: number
    /**
     * Use log transform for the metric.
     */
    useLogTransform?: boolean
    /**
     * Use secondary retention event.
     */
    useSecondaryRetentionEvent?: boolean
    /**
     * Retention end.
     */
    retentionEnd?: number
    /**
     * Retention length.
     */
    retentionLength?: number
    /**
     * Log transform base to be used for the metric.
     */
    logTransformBase?: number | null
    /**
     * Maximum cap for metric values.
     */
    cap?: number
    /**
     * Mean Squared Error for surrogate metric.
     */
    surrogateMetricMSE?: number | null
  }
  /**
   * Array of unit types that the metric can utilize, such as stableID, userID, or other custom identifiers.
   */
  unitTypes?: Array<string>
  /**
   * Optional field indicating the team name responsible for the metric, aiding in accountability and management.
   */
  team?: string | null
  /**
   * Optional field indicating the team ID responsible for the metric, aiding in accountability and management.
   */
  teamID?: string | null
  /**
   * Indicates the desired change direction for the metric. Use "increase" for positive changes and "decrease" for negative changes.
   */
  directionality?: 'increase' | 'decrease'
  /**
   * Skips persisting updates to the metric (used to validate that inputs are correct)
   */
  dryRun?: boolean
  owner?: {
    /**
     * Email of the updated owner responsible for the metricâ€™s management.
     */
    email?: string
    /**
     * ID of the updated owner responsible for the metricâ€™s management.
     */
    ownerID?: string
  }
}

export type MetricValueDto = {
  value: number
  unitType: string
  numerator?: number
  denominator?: number
  inputRows?: number
  metricName: string
  metricType: string
}

export type MetricValuesDto = {
  /**
   * Metric value for the given unit_type
   */
  value: number
  /**
   * Unit of the metric: stableID, userID, and other custom ids
   */
  unit_type: string
  /**
   * Row count for imported metric, optional
   */
  row_count?: number
  /**
   * Numerator of a ratio metric, optional
   */
  numerator?: number
  /**
   * Denominator of a ratio metric, optional
   */
  denominator?: number
}

export type MultiRuleDto = {
  rules: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
}

export type MultiRuleUpdateDto = {
  rules: Array<{
    /**
     * The name of this rule.
     */
    name?: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage?: number
    /**
     * An array of Condition objects.
     */
    conditions?: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
}

/**
 * Contract for overrides
 */
export type OverrideDto = {
  /**
   * List of user IDs
   */
  passingUserIDs: Array<string>
  /**
   * List of user IDs
   */
  failingUserIDs: Array<string>
  /**
   * Optional list of custom IDs
   */
  passingCustomIDs?: Array<string>
  /**
   * Optional list of custom IDs
   */
  failingCustomIDs?: Array<string>
  environmentOverrides: Array<{
    /**
     * Environment
     */
    environment?: string | null
    /**
     * Unit ID
     */
    unitID: string | null
    /**
     * List of passing IDs
     */
    passingIDs: Array<string>
    /**
     * List of failing IDs
     */
    failingIDs: Array<string>
  }>
}

export type PaginationResponseMetadataDto = {
  itemsPerPage: number
  pageNumber: number
  nextPage: string | null
  previousPage: string | null
  totalItems?: number
  all?: string
}

export type PaginationResponseWithMessage = {
  /**
   * A simple string explaining the result of the operation.
   */
  message: string
  /**
   * Array of results returned by pagination limit.
   */
  data: Array<{
    [key: string]: unknown
  }>
  /**
   * Pagination metadata for checking if there is next page for example.
   */
  pagination: PaginationResponseMetadataDto
}

export type ParamStoreCreateDto = {
  /**
   * Param Store Name
   */
  name: string
  /**
   * Param Store Description
   */
  description: string
  /**
   * Param Store Display Name
   */
  displayName: string
  /**
   * Target App IDs
   */
  targetAppIDs?: Array<string>
  /**
   * Tags
   */
  tags?: Array<string>
  /**
   * Team
   */
  team?: string
}

export type ParamStoreDto = {
  /**
   * Param Store ID
   */
  id: string
  /**
   * Param Store Name
   */
  name: string
  /**
   * Param Store Display Name
   */
  displayName: string
  /**
   * Param Store Description
   */
  description: string
  /**
   * Param Store Creation Time
   */
  createdTime: number
  /**
   * Creator ID
   */
  creatorID: string
  /**
   * Last Modifier ID
   */
  lastModifierID: string
  /**
   * Parameter Definition
   */
  parameters: Array<
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'boolean'
        value: boolean
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'number'
        value: number
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'string'
        value: string
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'object'
        value: {
          [key: string]: unknown
        }
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'array'
        value: Array<unknown>
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'boolean'
        pass_value: boolean
        fail_value: boolean
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'number'
        pass_value: number
        fail_value: number
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'string'
        pass_value: string
        fail_value: string
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'object'
        pass_value: {
          [key: string]: unknown
        }
        fail_value: {
          [key: string]: unknown
        }
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'array'
        pass_value: Array<unknown>
        fail_value: Array<unknown>
      }
    | {
        ref_type: 'layer'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Layer Name
         */
        layer_name: string
        /**
         * Parameter Name in Layer
         */
        param_name: string
      }
    | {
        ref_type: 'dynamic_config'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Dynamic Config Name
         */
        config_name: string
        /**
         * Parameter Name in Config
         */
        param_name: string
      }
    | {
        ref_type: 'experiment'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Experiment Name
         */
        experiment_name: string
        /**
         * Parameter Name in Experiment
         */
        param_name: string
      }
  >
}

export type ParamStoreUpdateDto = {
  /**
   * Param Store Description
   */
  description?: string
  /**
   * Parameter Definition
   */
  parameters?: Array<
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'boolean'
        value: boolean
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'number'
        value: number
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'string'
        value: string
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'object'
        value: {
          [key: string]: unknown
        }
      }
    | {
        ref_type: 'static'
        /**
         * Parameter Name
         */
        name: string
        param_type: 'array'
        value: Array<unknown>
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'boolean'
        pass_value: boolean
        fail_value: boolean
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'number'
        pass_value: number
        fail_value: number
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'string'
        pass_value: string
        fail_value: string
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'object'
        pass_value: {
          [key: string]: unknown
        }
        fail_value: {
          [key: string]: unknown
        }
      }
    | {
        ref_type: 'gate'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Gate Name
         */
        gate_name: string
        param_type: 'array'
        pass_value: Array<unknown>
        fail_value: Array<unknown>
      }
    | {
        ref_type: 'layer'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Layer Name
         */
        layer_name: string
        /**
         * Parameter Name in Layer
         */
        param_name: string
      }
    | {
        ref_type: 'dynamic_config'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Dynamic Config Name
         */
        config_name: string
        /**
         * Parameter Name in Config
         */
        param_name: string
      }
    | {
        ref_type: 'experiment'
        /**
         * Parameter Name
         */
        name: string
        /**
         * Parameter Type
         */
        param_type: 'string' | 'boolean' | 'number' | 'array' | 'object'
        /**
         * Experiment Name
         */
        experiment_name: string
        /**
         * Parameter Name in Experiment
         */
        param_name: string
      }
  >
}

export type PrecommitHookArgsDto =
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'gate'
      config_name: string
      type: 'rules'
      diffs: Array<unknown> | null
      old_config?: {
        /**
         * ID
         */
        id: string
        name?: string
        idType?: string
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        creatorID?: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        creatorEmail?: string | null
        tags?: Array<string>
        targetApps?: string | Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        team?: string | null
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
        checksPerHour: number | null
        status: 'In Progress' | 'Launched' | 'Disabled' | 'Archived'
        type: 'TEMPORARY' | 'PERMANENT' | 'STALE' | 'TEMPLATE'
        typeReason:
          | 'NONE'
          | 'STALE_PROBABLY_LAUNCHED'
          | 'STALE_PROBABLY_UNLAUNCHED'
          | 'STALE_PROBABLY_FORGOTTEN'
          | 'STALE_NO_RULES'
          | 'STALE_PROBABLY_DEAD_CHECK'
          | 'STALE_EMPTY_CHECKS'
          | 'STALE_ALL_TRUE'
          | 'STALE_ALL_FALSE'
        /**
         * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
         */
        owner?: {
          /**
           * ID of the owner
           */
          ownerID?: string
          /**
           * Type of the owner (e.g., SDK_KEY or USER)
           */
          ownerType?: string
          /**
           * The name of the owner. This field is optional.
           */
          ownerName?: string
          /**
           * The email of the owner. This field is optional.
           */
          ownerEmail?: string
        } | null
        isTemplate?: boolean
        isEnabled: boolean
        rules: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          /**
           * The environments this rule is enabled for.
           */
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          /**
           * The return value of the rule.
           */
          returnValue?: {
            [key: string]: unknown
          }
          completedAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          pendingAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
        }>
        measureMetricLifts?: boolean
        monitoringMetrics?: Array<{
          name: string
          type: string
        }>
        reviewSettings?: {
          requiredReview: boolean
          allowedReviewers?: Array<{
            id: string
            name: string
            email: string
          }> | null
        }
        releasePipelineID?: string | null
        activeReview?: {
          reviewID: string
          reviewStatus: string
          description: string
        }
      }
      new_config?: {
        /**
         * ID
         */
        id: string
        name?: string
        idType?: string
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        creatorID?: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        creatorEmail?: string | null
        tags?: Array<string>
        targetApps?: string | Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        team?: string | null
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
        checksPerHour: number | null
        status: 'In Progress' | 'Launched' | 'Disabled' | 'Archived'
        type: 'TEMPORARY' | 'PERMANENT' | 'STALE' | 'TEMPLATE'
        typeReason:
          | 'NONE'
          | 'STALE_PROBABLY_LAUNCHED'
          | 'STALE_PROBABLY_UNLAUNCHED'
          | 'STALE_PROBABLY_FORGOTTEN'
          | 'STALE_NO_RULES'
          | 'STALE_PROBABLY_DEAD_CHECK'
          | 'STALE_EMPTY_CHECKS'
          | 'STALE_ALL_TRUE'
          | 'STALE_ALL_FALSE'
        /**
         * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
         */
        owner?: {
          /**
           * ID of the owner
           */
          ownerID?: string
          /**
           * Type of the owner (e.g., SDK_KEY or USER)
           */
          ownerType?: string
          /**
           * The name of the owner. This field is optional.
           */
          ownerName?: string
          /**
           * The email of the owner. This field is optional.
           */
          ownerEmail?: string
        } | null
        isTemplate?: boolean
        isEnabled: boolean
        rules: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          /**
           * The environments this rule is enabled for.
           */
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          /**
           * The return value of the rule.
           */
          returnValue?: {
            [key: string]: unknown
          }
          completedAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          pendingAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
        }>
        measureMetricLifts?: boolean
        monitoringMetrics?: Array<{
          name: string
          type: string
        }>
        reviewSettings?: {
          requiredReview: boolean
          allowedReviewers?: Array<{
            id: string
            name: string
            email: string
          }> | null
        }
        releasePipelineID?: string | null
        activeReview?: {
          reviewID: string
          reviewStatus: string
          description: string
        }
      }
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'gate'
      config_name: string
      type: 'update_target_apps'
      old_target_apps: Array<string>
      new_target_apps: Array<string>
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'dynamic_config'
      config_name: string
      type: 'rules'
      diffs: Array<unknown> | null
      old_config?: {
        /**
         * ID
         */
        id: string
        /**
         * Optional name for the configuration.
         */
        name?: string
        /**
         * The type of ID which the dynamic config is based on.
         */
        idType?: string
        /**
         * A brief summary of what the dynamic config is being used for
         */
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        creatorID?: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        creatorEmail?: string | null
        /**
         * The list of tag names attached to the dynamic config
         */
        tags?: Array<string>
        targetApps?: string | Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        /**
         * The team name associated with the dynamic config, Enterprise only.
         */
        team?: string | null
        /**
         * The team ID associated with the dynamic config, Enterprise only.
         */
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
        /**
         * Is the dynamic config enabled
         */
        isEnabled: boolean
        /**
         * An array of Rule objects
         */
        rules: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          returnValue?: {
            [key: string]: unknown
          }
          completedAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          pendingAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          returnValueJson5?: string
          variants?: Array<{
            id?: string
            name: string
            passPercentage: number
            returnValue?: {
              [key: string]: unknown
            }
            returnValueJson5?: string
          }>
        }>
        /**
         * The fallback JSON object when no rules are triggered
         */
        defaultValue?: {
          [key: string]: unknown
        }
        /**
         * Can include comments. If provided with defaultValue, must parse to the same JSON
         */
        defaultValueJson5?: string
        /**
         * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
         */
        owner?: {
          /**
           * ID of the owner
           */
          ownerID?: string
          /**
           * Type of the owner (e.g., SDK_KEY or USER)
           */
          ownerType?: string
          /**
           * The name of the owner. This field is optional.
           */
          ownerName?: string
          /**
           * The email of the owner. This field is optional.
           */
          ownerEmail?: string
        } | null
        /**
         * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
         */
        schema?: string | null
        /**
         * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
         */
        schemaJson5?: string | null
        /**
         * The release pipeline ID associated with the dynamic config
         */
        releasePipelineID?: string | null
        isTemplate?: boolean
      }
      new_config?: {
        /**
         * ID
         */
        id: string
        /**
         * Optional name for the configuration.
         */
        name?: string
        /**
         * The type of ID which the dynamic config is based on.
         */
        idType?: string
        /**
         * A brief summary of what the dynamic config is being used for
         */
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        creatorID?: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        creatorEmail?: string | null
        /**
         * The list of tag names attached to the dynamic config
         */
        tags?: Array<string>
        targetApps?: string | Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        /**
         * The team name associated with the dynamic config, Enterprise only.
         */
        team?: string | null
        /**
         * The team ID associated with the dynamic config, Enterprise only.
         */
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
        /**
         * Is the dynamic config enabled
         */
        isEnabled: boolean
        /**
         * An array of Rule objects
         */
        rules: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          returnValue?: {
            [key: string]: unknown
          }
          completedAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          pendingAutomatedRollouts?: Array<{
            time: number
            passPercent: number
          }>
          returnValueJson5?: string
          variants?: Array<{
            id?: string
            name: string
            passPercentage: number
            returnValue?: {
              [key: string]: unknown
            }
            returnValueJson5?: string
          }>
        }>
        /**
         * The fallback JSON object when no rules are triggered
         */
        defaultValue?: {
          [key: string]: unknown
        }
        /**
         * Can include comments. If provided with defaultValue, must parse to the same JSON
         */
        defaultValueJson5?: string
        /**
         * Schema for owner data including ID, type, name. Note that if Entity is created by CONSOLE API, owner will be undefined.
         */
        owner?: {
          /**
           * ID of the owner
           */
          ownerID?: string
          /**
           * Type of the owner (e.g., SDK_KEY or USER)
           */
          ownerType?: string
          /**
           * The name of the owner. This field is optional.
           */
          ownerName?: string
          /**
           * The email of the owner. This field is optional.
           */
          ownerEmail?: string
        } | null
        /**
         * A schema using JSON Schema Draft 2020-12 to enforce return values of this dynamic config's rules.
         */
        schema?: string | null
        /**
         * `schema` except with Json5 comments. Optional and should parse to same json as `schema`.
         */
        schemaJson5?: string | null
        /**
         * The release pipeline ID associated with the dynamic config
         */
        releasePipelineID?: string | null
        isTemplate?: boolean
      }
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'dynamic_config'
      config_name: string
      type: 'update_target_apps'
      old_target_apps: Array<string>
      new_target_apps: Array<string>
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'segment'
      config_name: string
      type: 'rules'
      diffs: Array<unknown> | null
      old_config?: {
        /**
         * Is the segment enabled.
         */
        isEnabled: boolean
        type: 'id_list' | 'rule_based' | 'analysis_list' | 'user_store_id_list'
        /**
         * For id_list segments: the length of the ID list
         */
        count?: number
        /**
         * Rule Object
         */
        rules?: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          /**
           * The environments this rule is enabled for.
           */
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          /**
           * The return value of the rule.
           */
          returnValue?: {
            [key: string]: unknown
          }
        }>
        /**
         * Optional tags for categorization.
         */
        tags?: Array<string>
        /**
         * ID
         */
        id: string
        /**
         * Optional name for the configuration.
         */
        name?: string
        /**
         * Type of ID
         */
        idType: string
        /**
         * Detailed description of the configurationâ€™s purpose.
         */
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        /**
         * ID of the user who created the entity.
         */
        creatorID: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        /**
         * Email of the creator.
         */
        creatorEmail: string | null
        /**
         * List of target applications associated with this configuration.
         */
        targetApps?: Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        /**
         * Optional name for the responsible team.
         */
        team?: string | null
        /**
         * Optional ID of the responsible team.
         */
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
      }
      new_config?: {
        /**
         * Is the segment enabled.
         */
        isEnabled: boolean
        type: 'id_list' | 'rule_based' | 'analysis_list' | 'user_store_id_list'
        /**
         * For id_list segments: the length of the ID list
         */
        count?: number
        /**
         * Rule Object
         */
        rules?: Array<{
          /**
           * The name of this rule.
           */
          name: string
          /**
           * Of the users that meet the conditions of this rule, what percent should return true.
           */
          passPercentage: number
          /**
           * An array of Condition objects.
           */
          conditions: Array<{
            targetValue?: Array<string> | Array<number> | string | number | null
            operator?: string
            field?: string | null
            customID?: string | null
            type:
              | 'app_version'
              | 'browser_name'
              | 'browser_version'
              | 'country'
              | 'custom_field'
              | 'email'
              | 'environment_tier'
              | 'fails_gate'
              | 'fails_segment'
              | 'ip_address'
              | 'locale'
              | 'os_name'
              | 'os_version'
              | 'passes_gate'
              | 'passes_segment'
              | 'public'
              | 'time'
              | 'unit_id'
              | 'user_id'
              | 'url'
              | 'javascript'
              | 'device_model'
              | 'target_app'
          }>
          /**
           * The environments this rule is enabled for.
           */
          environments?: Array<string> | null
          /**
           * The Statsig ID of this rule.
           */
          id?: string
          /**
           * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
           */
          baseID?: string
          /**
           * The return value of the rule.
           */
          returnValue?: {
            [key: string]: unknown
          }
        }>
        /**
         * Optional tags for categorization.
         */
        tags?: Array<string>
        /**
         * ID
         */
        id: string
        /**
         * Optional name for the configuration.
         */
        name?: string
        /**
         * Type of ID
         */
        idType: string
        /**
         * Detailed description of the configurationâ€™s purpose.
         */
        description: string
        /**
         * ID of the last modifier.
         */
        lastModifierID: string | null
        /**
         * Time of the last modification.
         */
        lastModifiedTime: number | null
        /**
         * Email of the last modifier.
         */
        lastModifierEmail: string | null
        /**
         * Name of the last modifier.
         */
        lastModifierName: string | null
        /**
         * ID of the user who created the entity.
         */
        creatorID: string | null
        /**
         * Timestamp when the entity was created.
         */
        createdTime: number
        /**
         * Name of the creator.
         */
        creatorName: string | null
        /**
         * Email of the creator.
         */
        creatorEmail: string | null
        /**
         * List of target applications associated with this configuration.
         */
        targetApps?: Array<string>
        /**
         * Holdouts applied to this configuration.
         */
        holdoutIDs?: Array<string>
        /**
         * Optional name for the responsible team.
         */
        team?: string | null
        /**
         * Optional ID of the responsible team.
         */
        teamID?: string | null
        /**
         * Version number
         */
        version?: number
      }
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'segment'
      config_name: string
      type: 'update_target_apps'
      old_target_apps: Array<string>
      new_target_apps: Array<string>
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'update_allocation'
      old_allocation: number
      new_allocation: number
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'start_experiment'
      new_allocation: number
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'ship_experiment'
      group: string
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'abandon_experiment'
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'update_target_apps'
      old_target_apps: Array<string>
      new_target_apps: Array<string>
    }
  | {
      review_id: string
      submitter: string
      committer: string
      config_type: 'experiment'
      experiment_name: string
      type: 'update_experiment_settings'
      old_settings: {
        groups: Array<{
          name: string
          parameterValuesJSON: string
          size: number
        }>
        allocation: number
        targetingGateID: string | null
        inlineTargetingRulesJSON: string | null
      }
      new_settings: {
        groups: Array<{
          name: string
          parameterValuesJSON: string
          size: number
        }>
        allocation: number
        targetingGateID: string | null
        inlineTargetingRulesJSON: string | null
      }
    }

export type ProjectDto = {
  id: string
}

export type PulseLoadHistoryDto = {
  creatorName?: string
  createdTime: number
  finishedTime?: number
  finishedState?: 'success' | 'failure' | 'partial_failure' | 'cancelled' | 'timeout'
  startDs: string
  endDs: string
  reloadType: 'incremental' | 'full' | 'metric'
  turboMode: boolean
}

export type ReleasePipelineCreateDto = {
  /**
   * Pipeline Name
   */
  name: string
  /**
   * Phases of the release pipeline that will be executed in order.
   */
  phases?: Array<{
    /**
     * Phase ID
     */
    id?: string
    /**
     * Phase Name
     */
    name: string
    /**
     * Time interval in milliseconds for this phase
     */
    timeIntervalMs: number
    /**
     * Whether this phase requires review to proceed
     */
    requiredReview: boolean
    /**
     * Rules to apply in this phase
     */
    rules: Array<{
      /**
       * The Statsig ID of this rule.
       */
      id?: string
      /**
       * The name of this rule.
       */
      name: string
      /**
       * An array of Condition objects.
       */
      conditions: Array<{
        targetValue?: Array<string> | Array<number> | string | number | null
        operator?: string
        field?: string | null
        customID?: string | null
        type:
          | 'app_version'
          | 'browser_name'
          | 'browser_version'
          | 'country'
          | 'custom_field'
          | 'email'
          | 'environment_tier'
          | 'fails_gate'
          | 'fails_segment'
          | 'ip_address'
          | 'locale'
          | 'os_name'
          | 'os_version'
          | 'passes_gate'
          | 'passes_segment'
          | 'public'
          | 'time'
          | 'unit_id'
          | 'user_id'
          | 'url'
          | 'javascript'
          | 'device_model'
          | 'target_app'
      }>
      /**
       * The environments this rule is enabled for.
       */
      environments?: Array<string> | null
    }>
  }>
}

export type ReleasePipelineDto = {
  /**
   * Pipeline ID
   */
  id: string
  /**
   * Pipeline Name
   */
  name: string
  /**
   * Pipeline Creator ID
   */
  creatorID: string
  /**
   * Pipeline Creation Time
   */
  createdTime: number
  /**
   * Last Modifier ID
   */
  lastModifierID: string
  /**
   * Phases of the release pipeline that will be executed in order.
   */
  phases?: Array<{
    /**
     * Phase ID
     */
    id?: string
    /**
     * Phase Name
     */
    name: string
    /**
     * Time interval in milliseconds for this phase
     */
    timeIntervalMs: number
    /**
     * Whether this phase requires review to proceed
     */
    requiredReview: boolean
    /**
     * Rules to apply in this phase
     */
    rules: Array<{
      /**
       * The Statsig ID of this rule.
       */
      id?: string
      /**
       * The name of this rule.
       */
      name: string
      /**
       * An array of Condition objects.
       */
      conditions: Array<{
        targetValue?: Array<string> | Array<number> | string | number | null
        operator?: string
        field?: string | null
        customID?: string | null
        type:
          | 'app_version'
          | 'browser_name'
          | 'browser_version'
          | 'country'
          | 'custom_field'
          | 'email'
          | 'environment_tier'
          | 'fails_gate'
          | 'fails_segment'
          | 'ip_address'
          | 'locale'
          | 'os_name'
          | 'os_version'
          | 'passes_gate'
          | 'passes_segment'
          | 'public'
          | 'time'
          | 'unit_id'
          | 'user_id'
          | 'url'
          | 'javascript'
          | 'device_model'
          | 'target_app'
      }>
      /**
       * The environments this rule is enabled for.
       */
      environments?: Array<string> | null
    }>
  }>
}

export type ReleasePipelineTriggerActionBodyDto = {
  /**
   * Phase ID to ensure the correct state of the pipeline is updated
   */
  phaseID: string
}

export type ReleasePipelineTriggerResponseDto = {
  /**
   * Trigger ID
   */
  id: string
  /**
   * Release Pipeline ID
   */
  releasePipelineID: string
  /**
   * Actions
   */
  actions: Array<{
    type: 'STARTED' | 'ABORTED' | 'PAUSED' | 'UNPAUSED' | 'APPROVED_FOR' | 'SKIPPED' | 'FULL_ROLL_OUT' | 'CLEANED_UP'
    timeMs: number
    phaseID: string
    actorID: string
    actorName: string
  }>
  /**
   * Trigger Creator ID
   */
  creatorID: string
  /**
   * Trigger Creation Time
   */
  createdTime: number
  /**
   * Optional description for this trigger
   */
  description?: string
  /**
   * Gate ID
   */
  gateID?: string
  /**
   * Dynamic Config ID
   */
  dynamicConfigID?: string
  /**
   * Last modifier ID
   */
  lastModifierID: string
  /**
   * Last modifier name
   */
  lastModifierName: string
  /**
   * Pipeline status with this trigger
   */
  status: string
  /**
   * Current phase
   */
  currentPhase: string | null
  /**
   * Current phase ID
   */
  currentPhaseID: string | null
}

export type ReleasePipelineUpdateDto = {
  /**
   * Pipeline Name
   */
  name?: string
  /**
   * Phases of the release pipeline that will be executed in order.
   */
  phases?: Array<{
    /**
     * Phase ID
     */
    id?: string
    /**
     * Phase Name
     */
    name: string
    /**
     * Time interval in milliseconds for this phase
     */
    timeIntervalMs: number
    /**
     * Whether this phase requires review to proceed
     */
    requiredReview: boolean
    /**
     * Rules to apply in this phase
     */
    rules: Array<{
      /**
       * The Statsig ID of this rule.
       */
      id?: string
      /**
       * The name of this rule.
       */
      name: string
      /**
       * An array of Condition objects.
       */
      conditions: Array<{
        targetValue?: Array<string> | Array<number> | string | number | null
        operator?: string
        field?: string | null
        customID?: string | null
        type:
          | 'app_version'
          | 'browser_name'
          | 'browser_version'
          | 'country'
          | 'custom_field'
          | 'email'
          | 'environment_tier'
          | 'fails_gate'
          | 'fails_segment'
          | 'ip_address'
          | 'locale'
          | 'os_name'
          | 'os_version'
          | 'passes_gate'
          | 'passes_segment'
          | 'public'
          | 'time'
          | 'unit_id'
          | 'user_id'
          | 'url'
          | 'javascript'
          | 'device_model'
          | 'target_app'
      }>
      /**
       * The environments this rule is enabled for.
       */
      environments?: Array<string> | null
    }>
  }>
}

export type ReportDto = {
  /**
   * URL to the report
   */
  url: string
}

export type RoleContractDto = {
  /**
   * The name of the role.
   */
  name: string
  /**
   * The permissions of the role.
   */
  permissions: {
    [key: string]: boolean
  }
}

export type RoleUpdateContractDto = {
  /**
   * The permissions of the role.
   */
  permissions: {
    [key: string]: boolean
  }
}

export type RuleDto = {
  /**
   * The name of this rule.
   */
  name: string
  /**
   * Of the users that meet the conditions of this rule, what percent should return true.
   */
  passPercentage: number
  /**
   * An array of Condition objects.
   */
  conditions: Array<{
    targetValue?: Array<string> | Array<number> | string | number | null
    operator?: string
    field?: string | null
    customID?: string | null
    type:
      | 'app_version'
      | 'browser_name'
      | 'browser_version'
      | 'country'
      | 'custom_field'
      | 'email'
      | 'environment_tier'
      | 'fails_gate'
      | 'fails_segment'
      | 'ip_address'
      | 'locale'
      | 'os_name'
      | 'os_version'
      | 'passes_gate'
      | 'passes_segment'
      | 'public'
      | 'time'
      | 'unit_id'
      | 'user_id'
      | 'url'
      | 'javascript'
      | 'device_model'
      | 'target_app'
  }>
  /**
   * The environments this rule is enabled for.
   */
  environments?: Array<string> | null
  /**
   * The Statsig ID of this rule.
   */
  id?: string
  /**
   * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
   */
  baseID?: string
  /**
   * The return value of the rule.
   */
  returnValue?: {
    [key: string]: unknown
  }
  completedAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  pendingAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
}

export type RuleUpdateDto = {
  /**
   * The name of this rule.
   */
  name?: string
  /**
   * Of the users that meet the conditions of this rule, what percent should return true.
   */
  passPercentage?: number
  /**
   * An array of Condition objects.
   */
  conditions?: Array<{
    targetValue?: Array<string> | Array<number> | string | number | null
    operator?: string
    field?: string | null
    customID?: string | null
    type:
      | 'app_version'
      | 'browser_name'
      | 'browser_version'
      | 'country'
      | 'custom_field'
      | 'email'
      | 'environment_tier'
      | 'fails_gate'
      | 'fails_segment'
      | 'ip_address'
      | 'locale'
      | 'os_name'
      | 'os_version'
      | 'passes_gate'
      | 'passes_segment'
      | 'public'
      | 'time'
      | 'unit_id'
      | 'user_id'
      | 'url'
      | 'javascript'
      | 'device_model'
      | 'target_app'
  }>
  /**
   * The environments this rule is enabled for.
   */
  environments?: Array<string> | null
  /**
   * The Statsig ID of this rule.
   */
  id?: string
  /**
   * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
   */
  baseID?: string
  /**
   * The return value of the rule.
   */
  returnValue?: {
    [key: string]: unknown
  }
  completedAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  pendingAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
}

export type SegmentCreateContractDto = {
  /**
   * name of the segment
   */
  name: string
  /**
   * optional id of the segment (defaults to name)
   */
  id?: string
  /**
   * description of the segment
   */
  description?: string
  /**
   * type of the segment
   */
  type: 'id_list' | 'rule_based' | 'analysis_list' | 'user_store_id_list'
  /**
   * type of id
   */
  idType?: string
  /**
   * optional tags for categorization
   */
  tags?: Array<string>
  /**
   * the Statsig ID of the creator of this experiment
   */
  creatorID?: string | null
  /**
   * the email of the creator of this experiment
   */
  creatorEmail?: string | null
  /**
   * optional name identifier for the responsible team (enterprise only)
   */
  team?: string | null
  /**
   * optional identifier for the responsible team (enterprise only)
   */
  teamID?: string | null
  /**
   * Rule Object
   */
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_segment'
        | 'ip_address'
        | 'os_name'
        | 'os_version'
        | 'passes_segment'
        | 'unit_id'
        | 'user_id'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
    completedAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
    pendingAutomatedRollouts?: Array<{
      time: number
      passPercent: number
    }>
  }>
}

export type SegmentDto = {
  /**
   * Is the segment enabled.
   */
  isEnabled: boolean
  type: 'id_list' | 'rule_based' | 'analysis_list' | 'user_store_id_list'
  /**
   * For id_list segments: the length of the ID list
   */
  count?: number
  /**
   * Rule Object
   */
  rules?: Array<{
    /**
     * The name of this rule.
     */
    name: string
    /**
     * Of the users that meet the conditions of this rule, what percent should return true.
     */
    passPercentage: number
    /**
     * An array of Condition objects.
     */
    conditions: Array<{
      targetValue?: Array<string> | Array<number> | string | number | null
      operator?: string
      field?: string | null
      customID?: string | null
      type:
        | 'app_version'
        | 'browser_name'
        | 'browser_version'
        | 'country'
        | 'custom_field'
        | 'email'
        | 'environment_tier'
        | 'fails_gate'
        | 'fails_segment'
        | 'ip_address'
        | 'locale'
        | 'os_name'
        | 'os_version'
        | 'passes_gate'
        | 'passes_segment'
        | 'public'
        | 'time'
        | 'unit_id'
        | 'user_id'
        | 'url'
        | 'javascript'
        | 'device_model'
        | 'target_app'
    }>
    /**
     * The environments this rule is enabled for.
     */
    environments?: Array<string> | null
    /**
     * The Statsig ID of this rule.
     */
    id?: string
    /**
     * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
     */
    baseID?: string
    /**
     * The return value of the rule.
     */
    returnValue?: {
      [key: string]: unknown
    }
  }>
  /**
   * Optional tags for categorization.
   */
  tags?: Array<string>
  /**
   * ID
   */
  id: string
  /**
   * Optional name for the configuration.
   */
  name?: string
  /**
   * Type of ID
   */
  idType: string
  /**
   * Detailed description of the configurationâ€™s purpose.
   */
  description: string
  /**
   * ID of the last modifier.
   */
  lastModifierID: string | null
  /**
   * Time of the last modification.
   */
  lastModifiedTime: number | null
  /**
   * Email of the last modifier.
   */
  lastModifierEmail: string | null
  /**
   * Name of the last modifier.
   */
  lastModifierName: string | null
  /**
   * ID of the user who created the entity.
   */
  creatorID: string | null
  /**
   * Timestamp when the entity was created.
   */
  createdTime: number
  /**
   * Name of the creator.
   */
  creatorName: string | null
  /**
   * Email of the creator.
   */
  creatorEmail: string | null
  /**
   * List of target applications associated with this configuration.
   */
  targetApps?: Array<string>
  /**
   * Holdouts applied to this configuration.
   */
  holdoutIDs?: Array<string>
  /**
   * Optional name for the responsible team.
   */
  team?: string | null
  /**
   * Optional ID of the responsible team.
   */
  teamID?: string | null
  /**
   * Version number
   */
  version?: number
}

export type SegmentIdListContractDto = {
  ids: Array<string>
}

export type SegmentIdListResetContractDto = {
  ids: Array<string>
}

export type SegmentIdListUserStoreContractDto = {
  ids: Array<string>
  version?: number
}

export type SegmentRulesDto = Array<{
  /**
   * The name of this rule.
   */
  name: string
  /**
   * Of the users that meet the conditions of this rule, what percent should return true.
   */
  passPercentage: number
  conditions: Array<{
    targetValue?: Array<string> | Array<number> | string | number | null
    operator?: string
    field?: string | null
    customID?: string | null
    type:
      | 'app_version'
      | 'browser_name'
      | 'browser_version'
      | 'country'
      | 'custom_field'
      | 'email'
      | 'environment_tier'
      | 'fails_segment'
      | 'ip_address'
      | 'os_name'
      | 'os_version'
      | 'passes_segment'
      | 'unit_id'
      | 'user_id'
  }>
  /**
   * The environments this rule is enabled for.
   */
  environments?: Array<string> | null
  /**
   * The Statsig ID of this rule.
   */
  id?: string
  /**
   * The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
   */
  baseID?: string
  /**
   * The return value of the rule.
   */
  returnValue?: {
    [key: string]: unknown
  }
  completedAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
  pendingAutomatedRollouts?: Array<{
    time: number
    passPercent: number
  }>
}>

export type SettingsProjectContractDto = {
  /**
   * The name of the project.
   */
  name: string
  /**
   * The visibility type of the project.
   */
  visibility: 'OPEN' | 'CLOSED' | 'EXTERNAL'
  /**
   * The default unit ID type of the project for newly created gates, experiments, and metrics. If not provided, there will be no default unit type.
   */
  default_unit_type?: string
}

export type SettingsReviewsContractDto = {
  /**
   * Whether config reviews are required.
   */
  is_config_review_required: boolean
  /**
   * Whether metric reviews are required.
   */
  is_metric_review_required: boolean
  /**
   * Whether metric reviews are only required for verified metrics.
   */
  is_metric_review_required_on_verified_only: boolean
  /**
   * Whether analysis-only experiment reviews are required. Only applicable to WHN projects.
   */
  is_whn_analysis_only_review_required?: boolean
  /**
   * Whether metric/assignment/entity property source reviews are required. Only applicable to WHN projects.
   */
  is_whn_source_review_required?: boolean
}

export type SettingsRolesContractDto = {
  /**
   * The name of the default project role. This is the role that will be initially assigned to new users joining the project.
   */
  default_project_role: string
}

export type SettingsTeamsContractDto = {
  /**
   * Whether a team is required on each new config.
   */
  require_teams_on_configs: boolean
}

export type SingleDataResponse = {
  /**
   * A simple string explaining the result of the operation.
   */
  message: string
  /**
   * A single result.
   */
  data: {
    [key: string]: unknown
  }
}

export type TagCreateDto = {
  name: string
  description: string
  isCore?: boolean
}

export type TagDto = {
  /**
   * id of the tag
   */
  id: string
  /**
   * name of the tag
   */
  name: string
  /**
   * description of the tag
   */
  description: string
  /**
   * is this a core tag
   */
  isCore: boolean
}

export type TagUpdateDto = {
  name?: string
  description?: string
  isCore?: boolean
}

export type TargetAppCreateDto = {
  /**
   * name of the target app
   */
  name: string
  /**
   * a description of the target app
   */
  description: string
  /**
   * Gate IDs to assign to target app(s)
   */
  gates?: Array<string>
  /**
   * Dynamic Config IDs to assign to target app(s)
   */
  dynamicConfigs?: Array<string>
  /**
   * Experiment IDs to assign to target app(s)
   */
  experiments?: Array<string>
}

export type TargetAppDto = {
  /**
   * id of target app
   */
  id?: string
  /**
   * name of the target app
   */
  name: string
}

export type TeamCreationDto = {
  /**
   * The name of the team.
   */
  name: string
  /**
   * Description of the team.
   */
  description?: string
  /**
   * Array of member email addresses in the team.
   */
  members: Array<string>
  /**
   * Array of admin email addresses in the team.
   */
  admins: Array<string>
  /**
   * Default gate metrics for the team.
   */
  defaultGateMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default primary metrics for experiments in the team.
   */
  defaultExperimentPrimaryMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default secondary metrics for experiments in the team.
   */
  defaultExperimentSecondaryMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default holdout metrics for the team.
   */
  defaultHoldoutMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Who can change team configurations: "anyone" or "team_only".
   */
  changeTeamConfigs: 'anyone' | 'team_only'
  /**
   * Who can review and approve changes: "anyone", "team_only", or "admin_only".
   */
  reviewApproval: 'anyone' | 'team_only' | 'admin_only'
  /**
   * Default target applications for the team.
   */
  defaultTargetApplications: Array<string>
  /**
   * Default holdout ID for the team, if applicable.
   */
  defaultHoldoutID?: string | null
  /**
   * Whether reviews are required for changes, if applicable.
   */
  requireReviews?: boolean | null
  /**
   * Whether gate templates are required for the team, if applicable.
   */
  requireGateTemplates?: boolean | null
  /**
   * Whether experiment templates are required for the team, if applicable.
   */
  requireExperimentTemplates?: boolean | null
  /**
   * Whether dynamic config templates are required for the team, if applicable.
   */
  requireDynamicConfigTemplates?: boolean | null
}

export type TeamDto = {
  /**
   * The name of the team.
   */
  name: string
  /**
   * Description of the team.
   */
  description?: string
  /**
   * The ID of the team.
   */
  id: string
  /**
   * Default gate metrics for the team.
   */
  defaultGateMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default primary metrics for experiments in the team.
   */
  defaultExperimentPrimaryMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default secondary metrics for experiments in the team.
   */
  defaultExperimentSecondaryMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default holdout metrics for the team.
   */
  defaultHoldoutMetrics: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Who can change team configurations: "anyone" or "team_only".
   */
  changeTeamConfigs: 'anyone' | 'team_only'
  /**
   * Who can review and approve changes: "anyone", "team_only", or "admin_only".
   */
  reviewApproval: 'anyone' | 'team_only' | 'admin_only'
  /**
   * Default target applications for the team.
   */
  defaultTargetApplications: Array<string>
  /**
   * Default holdout ID for the team, if applicable.
   */
  defaultHoldoutID?: string | null
  /**
   * Whether reviews are required for changes, if applicable.
   */
  requireReviews?: boolean | null
  /**
   * Whether gate templates are required for the team, if applicable.
   */
  requireGateTemplates?: boolean | null
  /**
   * Whether experiment templates are required for the team, if applicable.
   */
  requireExperimentTemplates?: boolean | null
  /**
   * Whether dynamic config templates are required for the team, if applicable.
   */
  requireDynamicConfigTemplates?: boolean | null
  members: Array<{
    /**
     * The email address of the user.
     */
    email: string
    /**
     * The user's first name.
     */
    firstName: string
    /**
     * The user's last name.
     */
    lastName: string
    /**
     * The user's role, which can be 'Admin', 'Read Only', 'Member', or any custom role name.
     */
    role: string
  }>
  admins: Array<{
    /**
     * The email address of the user.
     */
    email: string
    /**
     * The user's first name.
     */
    firstName: string
    /**
     * The user's last name.
     */
    lastName: string
    /**
     * The user's role, which can be 'Admin', 'Read Only', 'Member', or any custom role name.
     */
    role: string
  }>
}

export type TeamPartialUpdateDto = {
  /**
   * The name of the team.
   */
  name?: string
  /**
   * Description of the team.
   */
  description?: string
  /**
   * The ID of the team.
   */
  id?: string
  /**
   * Array of member email addresses in the team.
   */
  members?: Array<string>
  /**
   * Array of admin email addresses in the team.
   */
  admins?: Array<string>
  /**
   * Default gate metrics for the team.
   */
  defaultGateMetrics?: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default primary metrics for experiments in the team.
   */
  defaultExperimentPrimaryMetrics?: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default secondary metrics for experiments in the team.
   */
  defaultExperimentSecondaryMetrics?: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Default holdout metrics for the team.
   */
  defaultHoldoutMetrics?: Array<{
    /**
     * The name of the metric.
     */
    name: string
    /**
     * The type of the metric.
     */
    type: string
  }>
  /**
   * Who can change team configurations: "anyone" or "team_only".
   */
  changeTeamConfigs?: 'anyone' | 'team_only'
  /**
   * Who can review and approve changes: "anyone", "team_only", or "admin_only".
   */
  reviewApproval?: 'anyone' | 'team_only' | 'admin_only'
  /**
   * Default target applications for the team.
   */
  defaultTargetApplications?: Array<string>
  /**
   * Default holdout ID for the team, if applicable.
   */
  defaultHoldoutID?: string | null
  /**
   * Whether reviews are required for changes, if applicable.
   */
  requireReviews?: boolean | null
  /**
   * Whether gate templates are required for the team, if applicable.
   */
  requireGateTemplates?: boolean | null
  /**
   * Whether experiment templates are required for the team, if applicable.
   */
  requireExperimentTemplates?: boolean | null
  /**
   * Whether dynamic config templates are required for the team, if applicable.
   */
  requireDynamicConfigTemplates?: boolean | null
}

export type UnarchiveSchemaDto = {
  /**
   * The reason for unarchiving the gate
   */
  unarchiveReason?: string
}

export type UnitIdTypeContractDto = {
  /**
   * The name of the unit id type.
   */
  name: string
  /**
   * The description of the unit id type.
   */
  description?: string
}

export type UnitIdTypeUpdateContractDto = {
  /**
   * The description of the unit id type.
   */
  description: string
}

/**
 * Contract for updating overrides
 */
export type UpdateOverridesContractDto =
  | {
      environmentOverrides: Array<{
        /**
         * Environment
         */
        environment?: string | null
        /**
         * Unit ID
         */
        unitID: string | null
        /**
         * List of passing IDs
         */
        passingIDs: Array<string>
        /**
         * List of failing IDs
         */
        failingIDs: Array<string>
      }>
    }
  | {
      /**
       * List of user IDs
       */
      passingUserIDs: Array<string>
      /**
       * List of user IDs
       */
      failingUserIDs: Array<string>
      /**
       * Optional list of custom IDs
       */
      passingCustomIDs?: Array<string>
      /**
       * Optional list of custom IDs
       */
      failingCustomIDs?: Array<string>
    }

export type UpdateTargetAppDto = {
  /**
   * name of the target app
   */
  name?: string
  /**
   * a description of the target app
   */
  description?: string
}

export type UserContractDto = {
  /**
   * The email address of the user.
   */
  email: string
  /**
   * The user's first name.
   */
  firstName: string
  /**
   * The user's last name.
   */
  lastName: string
  /**
   * The user's role, which can be 'Admin', 'Read Only', 'Member', or any custom role name.
   */
  role: string
}

export type UserInvitesDto = {
  /**
   * Role assigned to the invited users. Can be 'Admin', 'Read Only', 'Member', or any custom role name.
   */
  role: string
  /**
   * List of email addresses to send invitations to. Invitee Emails must have the same domain to your company email domain.
   */
  emails: Array<string>
  /**
   * Optional list of teams that the invited users will be associated with.
   */
  teams?: Array<string>
}

/**
 * Schema for updating user information.
 */
export type UserUpdateDto = {
  /**
   * Update the user's role. Can be 'Admin', 'Read Only', 'Member', or any custom role name.
   */
  role?: string
  /**
   * Update the user's first name.
   */
  firstName?: string
  /**
   * Update the user's last name.
   */
  lastName?: string
}

export type WhConnectionUpdateDto = {
  databricks?: {
    host?: string
    path?: string
    accessToken?: string
    /**
     * Statsig will use this Database to save intermediate tables in the experimentation pipeline. Must be a database that the service user has write access to.
     */
    stagingDatabase?: string
    oauthClientID?: string | null
    /**
     * An optional separate path that Statsig will use to run interactive queries made from the Console.
     */
    consoleComputePath?: string | null
  }
  snowflake?: {
    accountName?: string
    serviceUserName?: string
    serviceUserPassword?: string
    privateKey?: string | null
    keyPassPhrase?: string | null
    /**
     * The database containing the staging schema
     */
    stagingDatabaseName?: string
    /**
     * Statsig will use this Schema to save intermediate tables in the experimentation pipeline. Must be a schema that the service user has write access to.
     */
    stagingSchemaName?: string
    /**
     * The warehouse that Statsig will use to run queries. Must be a warehouse that the service user has access to.
     */
    computeWarehouse?: string
    /**
     * An optional warehouse that Statsig will use to run interactive queries made from the Console.
     */
    consoleComputeWarehouse?: string | null
  }
}

export type GetConsoleV1AlertsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/alerts'
}

export type GetConsoleV1AlertsErrors = {
  /**
   * Forbidden resource
   */
  403: {
    status: 403
    message: 'Forbidden resource'
  }
}

export type GetConsoleV1AlertsError = GetConsoleV1AlertsErrors[keyof GetConsoleV1AlertsErrors]

export type GetConsoleV1AlertsResponses = {
  /**
   * List Alerts success response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<AlertSchemaDto>
  }
}

export type GetConsoleV1AlertsResponse = GetConsoleV1AlertsResponses[keyof GetConsoleV1AlertsResponses]

export type GetConsoleV1AuditLogsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    id?: string
    sortKey?: 'id' | 'name' | 'changeLog' | 'actionType' | 'date' | 'time' | 'updatedBy' | 'updatedByUserID'
    sortOrder?: 'asc' | 'desc'
    latestID?: string
    tags?: string | Array<string>
    actionType?:
      | 'start_ai_config_version_evaluation_job'
      | 'clone_ai_config'
      | 'edit_ai_config_version'
      | 'delete_ai_config_version'
      | 'clone_ai_config_version'
      | 'ai_config_create'
      | 'create_ai_config_version'
      | 'upsert_ai_config_version'
      | 'create_ai_config_eval_grader'
      | 'edit_ai_config_eval_grader'
      | 'delete_ai_config_eval_grader'
      | 'set_enable_id_resolution_toggle'
      | 'dynamic_config_create'
      | 'dynamic_config_template_create'
      | 'dynamic_config_update_owners'
      | 'gate_overrides_update'
      | 'gate_template_create'
      | 'gate_create'
      | 'gate_update'
      | 'set_user_sampling_rate_for_gate'
      | 'gate_update_owners'
      | 'update_store_0_100_exposures'
      | 'update_gate_analytics_enabled'
      | 'update_gate_display_name'
      | 'release_pipeline_create'
      | 'release_pipeline_update'
      | 'release_pipeline_delete'
      | 'update_config_release_pipeline'
      | 'release_pipeline_trigger_create'
      | 'apply_experiment_review'
      | 'extend_experiment_pulse_end_date'
      | 'restart_experiment_pulse'
      | 'autotune_experiment_create'
      | 'autotune_experiment_delete'
      | 'autotune_experiment_snapshot_delete'
      | 'autotune_experiment_edit'
      | 'autotune_experiment_update_target_apps'
      | 'autotune_experiment_update_pulse_paused'
      | 'autotune_overrides_edit'
      | 'autotune_reviews_on'
      | 'experiment_data_report_delete'
      | 'experiment_discussion_post_create'
      | 'experiment_discussion_post_delete'
      | 'experiment_abandon'
      | 'experiment_pause_assignment'
      | 'experiment_stopped'
      | 'experiment_review_accept'
      | 'experiment_review_reject'
      | 'experiment_template_create'
      | 'update_template_decision_framework'
      | 'remove_template_decision_framework'
      | 'experiment_create'
      | 'experiment_review_create'
      | 'experiment_delete'
      | 'experiment_review_delete'
      | 'experiment_review_update_team'
      | 'experiment_snapshot_delete'
      | 'experiment_group_disable'
      | 'experiment_description_edit'
      | 'experiment_display_name_edit'
      | 'experiment_edit'
      | 'experiment_overrides_edit'
      | 'hypothesis_edit'
      | 'key_experiment_metrics_edit'
      | 'experiment_advanced_settings_edit'
      | 'experiment_decision_make'
      | 'experiment_restart'
      | 'experiment_rollout'
      | 'experiment_schedule_rollout'
      | 'experiment_reviews_on'
      | 'experiment_start'
      | 'schedule_experiment_start'
      | 'experiment_follow_toggle'
      | 'experiment_allowed_reviewers_update'
      | 'experiment_review_info_update'
      | 'update_experiment_enabled_non_prod_environments'
      | 'archive_experiment'
      | 'unarchive_experiment'
      | 'experiment_update_owners'
      | 'update_echidna_subtype'
      | 'setup_stratified_sampling'
      | 'experiment_update_target_apps'
      | 'experiment_update_subdimension_filter'
      | 'experiment_review_update_overrides'
      | 'experiment_review_update_owners'
      | 'experiment_update_decision_note'
      | 'experiment_update_summary_sections'
      | 'unattach_experiment_to_power_analysis_report'
      | 'attach_experiment_to_power_analysis_report'
      | 'pin_chart_to_summary'
      | 'set_geotest_design'
      | 'delete_geotest_design'
      | 'create_geotest_design'
      | 'experiment_assigned_to_layer'
      | 'holdout_create'
      | 'holdout_delete'
      | 'holdout_layer_parameter_values_update'
      | 'holdout_update'
      | 'holdout_update_owners'
      | 'metric_edit_definition'
      | 'metric_edit_description'
      | 'metric_add_tag'
      | 'metric_remove_tag'
      | 'schedule_delete_metric'
      | 'schedule_archive_metric'
      | 'update_metric_is_permanent'
      | 'update_metric_is_verified'
      | 'metric_reviews_on'
      | 'metric_disable_reviews_locally'
      | 'custom_metric_definition_edit'
      | 'custom_metric_definition_create'
      | 'custom_metric_definition_delete'
      | 'custom_metric_update_owners'
      | 'tag_metrics_bulk'
      | 'tag_create'
      | 'tag_delete'
      | 'tag_edit'
      | 'segment_create'
      | 'segment_update_owners'
      | 'layer_update_owners'
      | 'layer_review_commit'
      | 'layer_review_accept'
      | 'layer_parameter_add'
      | 'layer_create'
      | 'layer_review_create'
      | 'layer_review_delete'
      | 'layer_delete'
      | 'layer_snapshot_delete'
      | 'layer_description_edit'
      | 'layer_edit'
      | 'layer_overrides_edit'
      | 'layer_parameters_edit'
      | 'layer_review_reject'
      | 'layer_allowed_reviewers_update'
      | 'layer_review_info_update'
      | 'layer_update_target_apps'
      | 'delete_layer_parameter'
      | 'update_layer_parameter'
      | 'config_review_accept'
      | 'config_review_commit'
      | 'config_review_create'
      | 'config_delete'
      | 'config_review_delete'
      | 'config_reviews_disable'
      | 'config_review_reject'
      | 'config_resalt'
      | 'config_revert'
      | 'config_require_reviews'
      | 'config_state_toggle'
      | 'config_allowed_reviewers_update'
      | 'config_conditions_update'
      | 'config_default_value_update'
      | 'config_description_update'
      | 'config_display_name_update'
      | 'config_environments_update'
      | 'config_review_info_update'
      | 'config_review_update'
      | 'config_review_required_update'
      | 'config_add_tag'
      | 'config_edit_tags'
      | 'config_remove_tag'
      | 'config_monitoring_metrics_update'
      | 'config_edit_target_apps'
      | 'update_config_analytics_enabled'
      | 'set_self_approvals_blocked'
      | 'release_pipeline_completed'
      | 'pin_dashboard_for_company'
      | 'add_dashboard_widget'
      | 'create_dashboard'
      | 'delete_dashboard_widget'
      | 'edit_dashboard_widget'
      | 'delete_dashboard'
      | 'edit_dashboard_description'
      | 'edit_dashboard_name'
      | 'restore_dashboard'
      | 'update_dashboard_widgets_from_generated_tags'
      | 'dashboard_update_owners'
      | 'update_dashboard_settings'
      | 'create_topline_alert'
      | 'update_topline_alert'
      | 'delete_topline_alert'
      | 'active_user_definition_update'
      | 'company_create'
      | 'company_metric_management_update'
      | 'metric_allowed_reviewers_update'
      | 'metric_review_commit'
      | 'metric_review_create'
      | 'metric_review_info_update'
      | 'set_metric_directionality'
      | 'custom_metric_edit'
      | 'custom_metric_name_edit'
      | 'custom_metric_review_accept'
      | 'custom_metric_review_delete'
      | 'custom_metric_review_reject'
      | 'delete_metric'
      | 'archive_metric'
      | 'unarchive_metric'
      | 'cancel_delete_metric'
      | 'cancel_archive_metric'
      | 'edit_guardrail_metric_alert'
      | 'create_guardrail_metric_alert'
      | 'delete_guardrail_metric_alert'
      | 'resolve_guardrail_metric_alert'
      | 'unsnooze_guardrail_metric_alert'
      | 'update_echidna_metric_loading_window'
      | 'update_metric_review_required'
      | 'layer_reviews_on'
      | 'delete_tag'
      | 'ID_list_update'
      | 'update_gate_is_permanent'
      | 'load_echidna_metric'
      | 'update_server_sdk_configuration_rollback'
      | 'company_ID_type_add'
      | 'update_echidna_source_review_required'
      | 'AWS_marketplace_account_delete'
      | 'batch_cancel_company_invites'
      | 'batch_user_role_update'
      | 'company_basic_info_edit'
      | 'company_delete'
      | 'company_email_domain_config_delete'
      | 'company_environments_edit'
      | 'add_geo_type'
      | 'delete_geo_type'
      | 'company_ID_type_delete'
      | 'company_ID_type_edit'
      | 'company_invite_access_update'
      | 'update_entities_require_teams'
      | 'update_company_user_store_enabled'
      | 'company_member_remove'
      | 'company_metric_delete'
      | 'company_snapshot_delete'
      | 'config_id_type_update'
      | 'config_update_owners'
      | 'create_customer_app'
      | 'edit_target_app'
      | 'delete_target_app'
      | 'source_allowed_reviewers_update'
      | 'create_echidna_assignment_source'
      | 'create_echidna_entity_property_source'
      | 'create_echidna_metric_source'
      | 'create_echidna_data_quality_checks'
      | 'create_echidna_source_review'
      | 'accept_echidna_source_review'
      | 'commit_echidna_source_review'
      | 'reject_echidna_source_review'
      | 'update_echidna_source_review'
      | 'delete_echidna_source_review'
      | 'create_power_analysis_gate_query'
      | 'create_power_analysis_custom_query'
      | 'custom_pulse_query_create'
      | 'custom_pulse_query_delete'
      | 'custom_pulse_query_name_edit'
      | 'custom_query_toggle_favorite'
      | 'custom_sankey_delete'
      | 'delete_echidna_assignment_source'
      | 'delete_echidna_entity_property_source'
      | 'delete_echidna_metric_source'
      | 'delete_payment_method'
      | 'tag_update_owners'
      | 'modify_override_config'
      | 'modify_overrides'
      | 'remove_override_config'
      | 'scheduled_custom_pulse_query_create'
      | 'integration_delete'
      | 'integration_create'
      | 'integration_update'
      | 'scheduled_pulse_custom_query_delete'
      | 'scheduled_pulse_query_name_edit'
      | 'user_data_load'
      | 'organization_member_remove'
      | 'shared_report_link_upsert'
      | 'scheduled_pulse_rollups_update'
      | 'OIDC_configuration_delete'
      | 'project_review_group_delete'
      | 'SSO_disable'
      | 'project_description_edit'
      | 'project_owner_set'
      | 'user_role_update'
      | 'OIDC_configuration_upsert'
      | 'payment_entitlements_upsert'
      | 'project_review_group_upsert'
      | 'project_review_group_remove'
      | 'update_team_settings'
      | 'update_team_admins'
      | 'update_team_name'
      | 'update_team_description'
      | 'update_team'
      | 'shared_report_link_delete'
      | 'experiment_data_report_rename'
      | 'experiment_data_report_update_parameters'
      | 'event_dimension_update'
      | 'integration_set_enabled'
      | 'integration_update_disabled_events'
      | 'integration_update_outgoing_config'
      | 'integration_update_rate_limits'
      | 'integration_upsert'
      | 'ingestion_source_delete'
      | 'tag_configs_bulk'
      | 'org_api_key_create'
      | 'sdk_key_create'
      | 'sdk_key_deactivate'
      | 'sdk_key_delete'
      | 'secret_key_regenerate'
      | 'sdk_key_update_description'
      | 'set_api_share_key_access'
      | 'set_plan_type'
      | 'generate_integration_webhook_secret'
      | 'set_default_payment_method'
      | 'set_user_sampling_rate'
      | 'sdk_key_update_environments'
      | 'upsert_trigger_integration'
      | 'delete_trigger_integration'
      | 'dismiss_runaway_entity'
      | 'update_echidna_metric_source'
      | 'update_echidna_metric_source_name'
      | 'update_echidna_metric_tag_or_description'
      | 'update_echidna_assignment_source'
      | 'update_echidna_assignment_source_name'
      | 'update_echidna_assignment_source_loading_window'
      | 'update_echidna_entity_property_source'
      | 'update_echidna_entity_property_source_name'
      | 'update_echidna_source_owner'
      | 'update_precommit_hook'
      | 'load_echidna_pulse'
      | 'load_echidna_autotune_pulse'
      | 'load_echidna_assignment_source'
      | 'set_echidna_schedule_hour'
      | 'echidna_drop_tables'
      | 'upsert_user_role'
      | 'delete_user_role'
      | 'sdk_key_update_target_app'
      | 'set_gate_analytics_enabled_by_default'
      | 'set_dynamic_config_analytics_enabled_by_default'
      | 'set_gate_analytics_0_100_exposures_enabled'
      | 'update_bv3_subscription'
      | 'upsert_experiment_settings'
      | 'upsert_gate_settings'
      | 'sdk_key_update_scopes'
      | 'user_login'
      | 'param_store_create'
      | 'param_store_update'
      | 'set_bv3_plan_type'
      | 'set_echidna_project_pulse_schedule'
      | 'set_echidna_project_metric_schedule'
      | 'set_company_default_user_role'
      | 'set_company_session_replay_sampling_rate'
      | 'set_company_session_replay_settings'
      | 'cancel_echidna_dag'
      | 'set_require_target_app_for_new_entity'
      | 'add_segments_of_interest_property'
      | 'delete_segments_of_interest_property'
      | 'add_srm_debugger_custom_dimension'
      | 'delete_srm_debugger_custom_dimension'
      | 'param_store_delete'
      | 'setup_external_opt_in'
      | 'param_store_update_owners'
      | 'create_statsig_proxy'
      | 'update_echidna_assignment_source_is_verified'
      | 'update_echidna_metric_source_is_verified'
      | 'update_echidna_entity_property_source_is_verified'
      | 'update_echidna_source_is_verified'
      | 'set_automated_bot_removals'
      | 'pulse_results_export'
      | 'update_company_auto_capture_settings'
      | 'update_company_experiment_exclusion_segment'
      | 'set_stop_new_assignment_toggle'
      | 'set_stop_experiment_enabled'
      | 'update_company_remove_default_gates_setting'
      | 'set_whn_results_export_setting'
      | 'update_experiment_quality_score_settings'
      | 'update_experiment_salt'
      | 'update_precommit_webhook_key'
      | 'set_whn_table_ttls'
      | 'set_id_resolution_inferred_id'
      | 'set_id_resolution_labeled_id'
      | 'add_session_recordings_to_playlist'
      | 'delete_session_recordings_from_playlist'
      | 'delete_session_replay_playlist'
      | 'backfill_metric_results'
      | 'cancel_metric_backfills'
      | 'archive_org_project'
      | 'update_ai_assistance_enabled'
      | 'update_ai_business_context'
      | 'update_experiment_ai_settings'
      | 'upsert_ai_config_eval_groups'
      | 'upsert_user_store_client_targeting_properties'
      | 'set_ai_config_baseline_version'
      | 'update_experiment_quality_score_criteria'
    actionTypes?: Array<
      | 'start_ai_config_version_evaluation_job'
      | 'clone_ai_config'
      | 'edit_ai_config_version'
      | 'delete_ai_config_version'
      | 'clone_ai_config_version'
      | 'ai_config_create'
      | 'create_ai_config_version'
      | 'upsert_ai_config_version'
      | 'create_ai_config_eval_grader'
      | 'edit_ai_config_eval_grader'
      | 'delete_ai_config_eval_grader'
      | 'set_enable_id_resolution_toggle'
      | 'dynamic_config_create'
      | 'dynamic_config_template_create'
      | 'dynamic_config_update_owners'
      | 'gate_overrides_update'
      | 'gate_template_create'
      | 'gate_create'
      | 'gate_update'
      | 'set_user_sampling_rate_for_gate'
      | 'gate_update_owners'
      | 'update_store_0_100_exposures'
      | 'update_gate_analytics_enabled'
      | 'update_gate_display_name'
      | 'release_pipeline_create'
      | 'release_pipeline_update'
      | 'release_pipeline_delete'
      | 'update_config_release_pipeline'
      | 'release_pipeline_trigger_create'
      | 'apply_experiment_review'
      | 'extend_experiment_pulse_end_date'
      | 'restart_experiment_pulse'
      | 'autotune_experiment_create'
      | 'autotune_experiment_delete'
      | 'autotune_experiment_snapshot_delete'
      | 'autotune_experiment_edit'
      | 'autotune_experiment_update_target_apps'
      | 'autotune_experiment_update_pulse_paused'
      | 'autotune_overrides_edit'
      | 'autotune_reviews_on'
      | 'experiment_data_report_delete'
      | 'experiment_discussion_post_create'
      | 'experiment_discussion_post_delete'
      | 'experiment_abandon'
      | 'experiment_pause_assignment'
      | 'experiment_stopped'
      | 'experiment_review_accept'
      | 'experiment_review_reject'
      | 'experiment_template_create'
      | 'update_template_decision_framework'
      | 'remove_template_decision_framework'
      | 'experiment_create'
      | 'experiment_review_create'
      | 'experiment_delete'
      | 'experiment_review_delete'
      | 'experiment_review_update_team'
      | 'experiment_snapshot_delete'
      | 'experiment_group_disable'
      | 'experiment_description_edit'
      | 'experiment_display_name_edit'
      | 'experiment_edit'
      | 'experiment_overrides_edit'
      | 'hypothesis_edit'
      | 'key_experiment_metrics_edit'
      | 'experiment_advanced_settings_edit'
      | 'experiment_decision_make'
      | 'experiment_restart'
      | 'experiment_rollout'
      | 'experiment_schedule_rollout'
      | 'experiment_reviews_on'
      | 'experiment_start'
      | 'schedule_experiment_start'
      | 'experiment_follow_toggle'
      | 'experiment_allowed_reviewers_update'
      | 'experiment_review_info_update'
      | 'update_experiment_enabled_non_prod_environments'
      | 'archive_experiment'
      | 'unarchive_experiment'
      | 'experiment_update_owners'
      | 'update_echidna_subtype'
      | 'setup_stratified_sampling'
      | 'experiment_update_target_apps'
      | 'experiment_update_subdimension_filter'
      | 'experiment_review_update_overrides'
      | 'experiment_review_update_owners'
      | 'experiment_update_decision_note'
      | 'experiment_update_summary_sections'
      | 'unattach_experiment_to_power_analysis_report'
      | 'attach_experiment_to_power_analysis_report'
      | 'pin_chart_to_summary'
      | 'set_geotest_design'
      | 'delete_geotest_design'
      | 'create_geotest_design'
      | 'experiment_assigned_to_layer'
      | 'holdout_create'
      | 'holdout_delete'
      | 'holdout_layer_parameter_values_update'
      | 'holdout_update'
      | 'holdout_update_owners'
      | 'metric_edit_definition'
      | 'metric_edit_description'
      | 'metric_add_tag'
      | 'metric_remove_tag'
      | 'schedule_delete_metric'
      | 'schedule_archive_metric'
      | 'update_metric_is_permanent'
      | 'update_metric_is_verified'
      | 'metric_reviews_on'
      | 'metric_disable_reviews_locally'
      | 'custom_metric_definition_edit'
      | 'custom_metric_definition_create'
      | 'custom_metric_definition_delete'
      | 'custom_metric_update_owners'
      | 'tag_metrics_bulk'
      | 'tag_create'
      | 'tag_delete'
      | 'tag_edit'
      | 'segment_create'
      | 'segment_update_owners'
      | 'layer_update_owners'
      | 'layer_review_commit'
      | 'layer_review_accept'
      | 'layer_parameter_add'
      | 'layer_create'
      | 'layer_review_create'
      | 'layer_review_delete'
      | 'layer_delete'
      | 'layer_snapshot_delete'
      | 'layer_description_edit'
      | 'layer_edit'
      | 'layer_overrides_edit'
      | 'layer_parameters_edit'
      | 'layer_review_reject'
      | 'layer_allowed_reviewers_update'
      | 'layer_review_info_update'
      | 'layer_update_target_apps'
      | 'delete_layer_parameter'
      | 'update_layer_parameter'
      | 'config_review_accept'
      | 'config_review_commit'
      | 'config_review_create'
      | 'config_delete'
      | 'config_review_delete'
      | 'config_reviews_disable'
      | 'config_review_reject'
      | 'config_resalt'
      | 'config_revert'
      | 'config_require_reviews'
      | 'config_state_toggle'
      | 'config_allowed_reviewers_update'
      | 'config_conditions_update'
      | 'config_default_value_update'
      | 'config_description_update'
      | 'config_display_name_update'
      | 'config_environments_update'
      | 'config_review_info_update'
      | 'config_review_update'
      | 'config_review_required_update'
      | 'config_add_tag'
      | 'config_edit_tags'
      | 'config_remove_tag'
      | 'config_monitoring_metrics_update'
      | 'config_edit_target_apps'
      | 'update_config_analytics_enabled'
      | 'set_self_approvals_blocked'
      | 'release_pipeline_completed'
      | 'pin_dashboard_for_company'
      | 'add_dashboard_widget'
      | 'create_dashboard'
      | 'delete_dashboard_widget'
      | 'edit_dashboard_widget'
      | 'delete_dashboard'
      | 'edit_dashboard_description'
      | 'edit_dashboard_name'
      | 'restore_dashboard'
      | 'update_dashboard_widgets_from_generated_tags'
      | 'dashboard_update_owners'
      | 'update_dashboard_settings'
      | 'create_topline_alert'
      | 'update_topline_alert'
      | 'delete_topline_alert'
      | 'active_user_definition_update'
      | 'company_create'
      | 'company_metric_management_update'
      | 'metric_allowed_reviewers_update'
      | 'metric_review_commit'
      | 'metric_review_create'
      | 'metric_review_info_update'
      | 'set_metric_directionality'
      | 'custom_metric_edit'
      | 'custom_metric_name_edit'
      | 'custom_metric_review_accept'
      | 'custom_metric_review_delete'
      | 'custom_metric_review_reject'
      | 'delete_metric'
      | 'archive_metric'
      | 'unarchive_metric'
      | 'cancel_delete_metric'
      | 'cancel_archive_metric'
      | 'edit_guardrail_metric_alert'
      | 'create_guardrail_metric_alert'
      | 'delete_guardrail_metric_alert'
      | 'resolve_guardrail_metric_alert'
      | 'unsnooze_guardrail_metric_alert'
      | 'update_echidna_metric_loading_window'
      | 'update_metric_review_required'
      | 'layer_reviews_on'
      | 'delete_tag'
      | 'ID_list_update'
      | 'update_gate_is_permanent'
      | 'load_echidna_metric'
      | 'update_server_sdk_configuration_rollback'
      | 'company_ID_type_add'
      | 'update_echidna_source_review_required'
      | 'AWS_marketplace_account_delete'
      | 'batch_cancel_company_invites'
      | 'batch_user_role_update'
      | 'company_basic_info_edit'
      | 'company_delete'
      | 'company_email_domain_config_delete'
      | 'company_environments_edit'
      | 'add_geo_type'
      | 'delete_geo_type'
      | 'company_ID_type_delete'
      | 'company_ID_type_edit'
      | 'company_invite_access_update'
      | 'update_entities_require_teams'
      | 'update_company_user_store_enabled'
      | 'company_member_remove'
      | 'company_metric_delete'
      | 'company_snapshot_delete'
      | 'config_id_type_update'
      | 'config_update_owners'
      | 'create_customer_app'
      | 'edit_target_app'
      | 'delete_target_app'
      | 'source_allowed_reviewers_update'
      | 'create_echidna_assignment_source'
      | 'create_echidna_entity_property_source'
      | 'create_echidna_metric_source'
      | 'create_echidna_data_quality_checks'
      | 'create_echidna_source_review'
      | 'accept_echidna_source_review'
      | 'commit_echidna_source_review'
      | 'reject_echidna_source_review'
      | 'update_echidna_source_review'
      | 'delete_echidna_source_review'
      | 'create_power_analysis_gate_query'
      | 'create_power_analysis_custom_query'
      | 'custom_pulse_query_create'
      | 'custom_pulse_query_delete'
      | 'custom_pulse_query_name_edit'
      | 'custom_query_toggle_favorite'
      | 'custom_sankey_delete'
      | 'delete_echidna_assignment_source'
      | 'delete_echidna_entity_property_source'
      | 'delete_echidna_metric_source'
      | 'delete_payment_method'
      | 'tag_update_owners'
      | 'modify_override_config'
      | 'modify_overrides'
      | 'remove_override_config'
      | 'scheduled_custom_pulse_query_create'
      | 'integration_delete'
      | 'integration_create'
      | 'integration_update'
      | 'scheduled_pulse_custom_query_delete'
      | 'scheduled_pulse_query_name_edit'
      | 'user_data_load'
      | 'organization_member_remove'
      | 'shared_report_link_upsert'
      | 'scheduled_pulse_rollups_update'
      | 'OIDC_configuration_delete'
      | 'project_review_group_delete'
      | 'SSO_disable'
      | 'project_description_edit'
      | 'project_owner_set'
      | 'user_role_update'
      | 'OIDC_configuration_upsert'
      | 'payment_entitlements_upsert'
      | 'project_review_group_upsert'
      | 'project_review_group_remove'
      | 'update_team_settings'
      | 'update_team_admins'
      | 'update_team_name'
      | 'update_team_description'
      | 'update_team'
      | 'shared_report_link_delete'
      | 'experiment_data_report_rename'
      | 'experiment_data_report_update_parameters'
      | 'event_dimension_update'
      | 'integration_set_enabled'
      | 'integration_update_disabled_events'
      | 'integration_update_outgoing_config'
      | 'integration_update_rate_limits'
      | 'integration_upsert'
      | 'ingestion_source_delete'
      | 'tag_configs_bulk'
      | 'org_api_key_create'
      | 'sdk_key_create'
      | 'sdk_key_deactivate'
      | 'sdk_key_delete'
      | 'secret_key_regenerate'
      | 'sdk_key_update_description'
      | 'set_api_share_key_access'
      | 'set_plan_type'
      | 'generate_integration_webhook_secret'
      | 'set_default_payment_method'
      | 'set_user_sampling_rate'
      | 'sdk_key_update_environments'
      | 'upsert_trigger_integration'
      | 'delete_trigger_integration'
      | 'dismiss_runaway_entity'
      | 'update_echidna_metric_source'
      | 'update_echidna_metric_source_name'
      | 'update_echidna_metric_tag_or_description'
      | 'update_echidna_assignment_source'
      | 'update_echidna_assignment_source_name'
      | 'update_echidna_assignment_source_loading_window'
      | 'update_echidna_entity_property_source'
      | 'update_echidna_entity_property_source_name'
      | 'update_echidna_source_owner'
      | 'update_precommit_hook'
      | 'load_echidna_pulse'
      | 'load_echidna_autotune_pulse'
      | 'load_echidna_assignment_source'
      | 'set_echidna_schedule_hour'
      | 'echidna_drop_tables'
      | 'upsert_user_role'
      | 'delete_user_role'
      | 'sdk_key_update_target_app'
      | 'set_gate_analytics_enabled_by_default'
      | 'set_dynamic_config_analytics_enabled_by_default'
      | 'set_gate_analytics_0_100_exposures_enabled'
      | 'update_bv3_subscription'
      | 'upsert_experiment_settings'
      | 'upsert_gate_settings'
      | 'sdk_key_update_scopes'
      | 'user_login'
      | 'param_store_create'
      | 'param_store_update'
      | 'set_bv3_plan_type'
      | 'set_echidna_project_pulse_schedule'
      | 'set_echidna_project_metric_schedule'
      | 'set_company_default_user_role'
      | 'set_company_session_replay_sampling_rate'
      | 'set_company_session_replay_settings'
      | 'cancel_echidna_dag'
      | 'set_require_target_app_for_new_entity'
      | 'add_segments_of_interest_property'
      | 'delete_segments_of_interest_property'
      | 'add_srm_debugger_custom_dimension'
      | 'delete_srm_debugger_custom_dimension'
      | 'param_store_delete'
      | 'setup_external_opt_in'
      | 'param_store_update_owners'
      | 'create_statsig_proxy'
      | 'update_echidna_assignment_source_is_verified'
      | 'update_echidna_metric_source_is_verified'
      | 'update_echidna_entity_property_source_is_verified'
      | 'update_echidna_source_is_verified'
      | 'set_automated_bot_removals'
      | 'pulse_results_export'
      | 'update_company_auto_capture_settings'
      | 'update_company_experiment_exclusion_segment'
      | 'set_stop_new_assignment_toggle'
      | 'set_stop_experiment_enabled'
      | 'update_company_remove_default_gates_setting'
      | 'set_whn_results_export_setting'
      | 'update_experiment_quality_score_settings'
      | 'update_experiment_salt'
      | 'update_precommit_webhook_key'
      | 'set_whn_table_ttls'
      | 'set_id_resolution_inferred_id'
      | 'set_id_resolution_labeled_id'
      | 'add_session_recordings_to_playlist'
      | 'delete_session_recordings_from_playlist'
      | 'delete_session_replay_playlist'
      | 'backfill_metric_results'
      | 'cancel_metric_backfills'
      | 'archive_org_project'
      | 'update_ai_assistance_enabled'
      | 'update_ai_business_context'
      | 'update_experiment_ai_settings'
      | 'upsert_ai_config_eval_groups'
      | 'upsert_user_store_client_targeting_properties'
      | 'set_ai_config_baseline_version'
      | 'update_experiment_quality_score_criteria'
    >
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    startDate?: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    endDate?: string
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/audit_logs'
}

export type GetConsoleV1AuditLogsResponses = {
  /**
   * Audit logs listed successfully.
   */
  200: PaginationResponseWithMessage & {
    data?: Array<AuditLogDto>
  }
}

export type GetConsoleV1AuditLogsResponse = GetConsoleV1AuditLogsResponses[keyof GetConsoleV1AuditLogsResponses]

export type GetConsoleV1AutotunesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/autotunes'
}

export type GetConsoleV1AutotunesResponses = {
  /**
   * Autotune Experiments listed successfully.
   */
  200: PaginationResponseWithMessage & {
    data?: Array<AutotuneExperimentDto>
  }
}

export type GetConsoleV1AutotunesResponse = GetConsoleV1AutotunesResponses[keyof GetConsoleV1AutotunesResponses]

export type PostConsoleV1AutotunesData = {
  body: AutotuneCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/autotunes'
}

export type PostConsoleV1AutotunesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1AutotunesError = PostConsoleV1AutotunesErrors[keyof PostConsoleV1AutotunesErrors]

export type PostConsoleV1AutotunesResponses = {
  /**
   * Create Autotune Success
   */
  201: SingleDataResponse & {
    data?: AutotuneExperimentDto
  }
}

export type PostConsoleV1AutotunesResponse = PostConsoleV1AutotunesResponses[keyof PostConsoleV1AutotunesResponses]

export type DeleteConsoleV1AutotunesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}'
}

export type DeleteConsoleV1AutotunesByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1AutotunesByIdError =
  DeleteConsoleV1AutotunesByIdErrors[keyof DeleteConsoleV1AutotunesByIdErrors]

export type DeleteConsoleV1AutotunesByIdResponses = {
  /**
   * Delete Autotune Success
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1AutotunesByIdResponse =
  DeleteConsoleV1AutotunesByIdResponses[keyof DeleteConsoleV1AutotunesByIdResponses]

export type GetConsoleV1AutotunesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}'
}

export type GetConsoleV1AutotunesByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1AutotunesByIdError = GetConsoleV1AutotunesByIdErrors[keyof GetConsoleV1AutotunesByIdErrors]

export type GetConsoleV1AutotunesByIdResponses = {
  /**
   * Read Autotune Success
   */
  200: SingleDataResponse & {
    data?: AutotuneExperimentDto
  }
}

export type GetConsoleV1AutotunesByIdResponse =
  GetConsoleV1AutotunesByIdResponses[keyof GetConsoleV1AutotunesByIdResponses]

export type PatchConsoleV1AutotunesByIdData = {
  body: AutotunePartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}'
}

export type PatchConsoleV1AutotunesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1AutotunesByIdError =
  PatchConsoleV1AutotunesByIdErrors[keyof PatchConsoleV1AutotunesByIdErrors]

export type PatchConsoleV1AutotunesByIdResponses = {
  /**
   * Partially Update Autotune Success
   */
  200: SingleDataResponse & {
    data?: AutotuneExperimentDto
  }
}

export type PatchConsoleV1AutotunesByIdResponse =
  PatchConsoleV1AutotunesByIdResponses[keyof PatchConsoleV1AutotunesByIdResponses]

export type PostConsoleV1AutotunesByIdData = {
  body: AutotuneFullUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}'
}

export type PostConsoleV1AutotunesByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1AutotunesByIdError = PostConsoleV1AutotunesByIdErrors[keyof PostConsoleV1AutotunesByIdErrors]

export type PostConsoleV1AutotunesByIdResponses = {
  /**
   * Fully Update Autotune Success
   */
  200: SingleDataResponse & {
    data?: AutotuneExperimentDto
  }
}

export type PostConsoleV1AutotunesByIdResponse =
  PostConsoleV1AutotunesByIdResponses[keyof PostConsoleV1AutotunesByIdResponses]

export type PutConsoleV1AutotunesByIdMakeDecisionData = {
  body: ExperimentStatusUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}/make_decision'
}

export type PutConsoleV1AutotunesByIdMakeDecisionErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1AutotunesByIdMakeDecisionError =
  PutConsoleV1AutotunesByIdMakeDecisionErrors[keyof PutConsoleV1AutotunesByIdMakeDecisionErrors]

export type PutConsoleV1AutotunesByIdMakeDecisionResponses = {
  /**
   * Finish Experiment Early Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1AutotunesByIdMakeDecisionResponse =
  PutConsoleV1AutotunesByIdMakeDecisionResponses[keyof PutConsoleV1AutotunesByIdMakeDecisionResponses]

export type PutConsoleV1AutotunesByIdResetData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}/reset'
}

export type PutConsoleV1AutotunesByIdResetErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1AutotunesByIdResetError =
  PutConsoleV1AutotunesByIdResetErrors[keyof PutConsoleV1AutotunesByIdResetErrors]

export type PutConsoleV1AutotunesByIdResetResponses = {
  /**
   * Reset Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1AutotunesByIdResetResponse =
  PutConsoleV1AutotunesByIdResetResponses[keyof PutConsoleV1AutotunesByIdResetResponses]

export type PutConsoleV1AutotunesByIdStartData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/autotunes/{id}/start'
}

export type PutConsoleV1AutotunesByIdStartResponses = {
  /**
   * Start Autotune Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1AutotunesByIdStartResponse =
  PutConsoleV1AutotunesByIdStartResponses[keyof PutConsoleV1AutotunesByIdStartResponses]

export type PostConsoleV1ChangeValidationData = {
  body: ChangeValidationDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/change_validation'
}

export type PostConsoleV1ChangeValidationResponses = {
  /**
   * Change Validation Success
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1ChangeValidationResponse =
  PostConsoleV1ChangeValidationResponses[keyof PostConsoleV1ChangeValidationResponses]

export type PatchConsoleV1ChangeValidationMessageData = {
  body: ChangeValidationUpdateMessageDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/change_validation/message'
}

export type PatchConsoleV1ChangeValidationMessageResponses = {
  /**
   * Update Change Validation Message Success
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1ChangeValidationMessageResponse =
  PatchConsoleV1ChangeValidationMessageResponses[keyof PatchConsoleV1ChangeValidationMessageResponses]

export type GetConsoleV1CompanyData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/company'
}

export type GetConsoleV1CompanyErrors = {
  /**
   * Forbidden resource
   */
  403: {
    status: 403
    message: 'Forbidden resource'
  }
}

export type GetConsoleV1CompanyError = GetConsoleV1CompanyErrors[keyof GetConsoleV1CompanyErrors]

export type GetConsoleV1CompanyResponses = {
  /**
   * Get company info response
   */
  200: SingleDataResponse & {
    data?: CompanyInfoResponseDto
  }
}

export type GetConsoleV1CompanyResponse = GetConsoleV1CompanyResponses[keyof GetConsoleV1CompanyResponses]

export type GetConsoleV1DynamicConfigsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * The release pipeline ID associated with the dynamic config
     */
    releasePipelineID?: string | null
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/dynamic_configs'
}

export type GetConsoleV1DynamicConfigsErrors = {
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1DynamicConfigsError = GetConsoleV1DynamicConfigsErrors[keyof GetConsoleV1DynamicConfigsErrors]

export type GetConsoleV1DynamicConfigsResponses = {
  /**
   * List Dynamic Configs Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<DynamicConfigDto>
  }
}

export type GetConsoleV1DynamicConfigsResponse =
  GetConsoleV1DynamicConfigsResponses[keyof GetConsoleV1DynamicConfigsResponses]

export type PostConsoleV1DynamicConfigsData = {
  body: DynamicConfigCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/dynamic_configs'
}

export type PostConsoleV1DynamicConfigsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Forbidden. The request was valid, but the server is refusing action. You might not have the necessary permissions to access the resource.
   */
  403: {
    status: 403
    message: string
  }
}

export type PostConsoleV1DynamicConfigsError =
  PostConsoleV1DynamicConfigsErrors[keyof PostConsoleV1DynamicConfigsErrors]

export type PostConsoleV1DynamicConfigsResponses = {
  /**
   * Create gate response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PostConsoleV1DynamicConfigsResponse =
  PostConsoleV1DynamicConfigsResponses[keyof PostConsoleV1DynamicConfigsResponses]

export type DeleteConsoleV1DynamicConfigsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}'
}

export type DeleteConsoleV1DynamicConfigsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1DynamicConfigsByIdError =
  DeleteConsoleV1DynamicConfigsByIdErrors[keyof DeleteConsoleV1DynamicConfigsByIdErrors]

export type DeleteConsoleV1DynamicConfigsByIdResponses = {
  /**
   * Delete Dynamic Config Response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1DynamicConfigsByIdResponse =
  DeleteConsoleV1DynamicConfigsByIdResponses[keyof DeleteConsoleV1DynamicConfigsByIdResponses]

export type GetConsoleV1DynamicConfigsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}'
}

export type GetConsoleV1DynamicConfigsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1DynamicConfigsByIdError =
  GetConsoleV1DynamicConfigsByIdErrors[keyof GetConsoleV1DynamicConfigsByIdErrors]

export type GetConsoleV1DynamicConfigsByIdResponses = {
  /**
   * Get Dynamic Config Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type GetConsoleV1DynamicConfigsByIdResponse =
  GetConsoleV1DynamicConfigsByIdResponses[keyof GetConsoleV1DynamicConfigsByIdResponses]

export type PatchConsoleV1DynamicConfigsByIdData = {
  body: DynamicConfigPartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}'
}

export type PatchConsoleV1DynamicConfigsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1DynamicConfigsByIdError =
  PatchConsoleV1DynamicConfigsByIdErrors[keyof PatchConsoleV1DynamicConfigsByIdErrors]

export type PatchConsoleV1DynamicConfigsByIdResponses = {
  /**
   * Partially Update Dynamic Config Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PatchConsoleV1DynamicConfigsByIdResponse =
  PatchConsoleV1DynamicConfigsByIdResponses[keyof PatchConsoleV1DynamicConfigsByIdResponses]

export type PostConsoleV1DynamicConfigsByIdData = {
  body: DynamicConfigFullUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}'
}

export type PostConsoleV1DynamicConfigsByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Forbidden. The request was valid, but the server is refusing action. You might not have the necessary permissions to access the resource.
   */
  403: {
    status: 403
    message: string
  }
}

export type PostConsoleV1DynamicConfigsByIdError =
  PostConsoleV1DynamicConfigsByIdErrors[keyof PostConsoleV1DynamicConfigsByIdErrors]

export type PostConsoleV1DynamicConfigsByIdResponses = {
  /**
   * Fully Update Dynamic Config Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PostConsoleV1DynamicConfigsByIdResponse =
  PostConsoleV1DynamicConfigsByIdResponses[keyof PostConsoleV1DynamicConfigsByIdResponses]

export type PutConsoleV1DynamicConfigsByIdDisableData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/disable'
}

export type PutConsoleV1DynamicConfigsByIdDisableResponses = {
  /**
   * Disable Dynamic Config Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PutConsoleV1DynamicConfigsByIdDisableResponse =
  PutConsoleV1DynamicConfigsByIdDisableResponses[keyof PutConsoleV1DynamicConfigsByIdDisableResponses]

export type PutConsoleV1DynamicConfigsByIdEnableData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/enable'
}

export type PutConsoleV1DynamicConfigsByIdEnableResponses = {
  /**
   * Enable Dynamic Config Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PutConsoleV1DynamicConfigsByIdEnableResponse =
  PutConsoleV1DynamicConfigsByIdEnableResponses[keyof PutConsoleV1DynamicConfigsByIdEnableResponses]

export type DeleteConsoleV1DynamicConfigsByIdRuleByRuleIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Dynamic Config ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleId: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/rule/{ruleId}'
}

export type DeleteConsoleV1DynamicConfigsByIdRuleByRuleIdResponses = {
  /**
   * Delete Dynamic Config Rule Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type DeleteConsoleV1DynamicConfigsByIdRuleByRuleIdResponse =
  DeleteConsoleV1DynamicConfigsByIdRuleByRuleIdResponses[keyof DeleteConsoleV1DynamicConfigsByIdRuleByRuleIdResponses]

export type GetConsoleV1DynamicConfigsByIdRuleByRuleIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Dynamic Config ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleId: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/rule/{ruleId}'
}

export type GetConsoleV1DynamicConfigsByIdRuleByRuleIdResponses = {
  /**
   * Get Specific Dynamic Config Rule Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigRuleDto
  }
}

export type GetConsoleV1DynamicConfigsByIdRuleByRuleIdResponse =
  GetConsoleV1DynamicConfigsByIdRuleByRuleIdResponses[keyof GetConsoleV1DynamicConfigsByIdRuleByRuleIdResponses]

export type PatchConsoleV1DynamicConfigsByIdRuleByRuleIdData = {
  body: DynamicConfigRulePartialDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Dynamic Config ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleId: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/rule/{ruleId}'
}

export type PatchConsoleV1DynamicConfigsByIdRuleByRuleIdResponses = {
  /**
   * Update Dynamic Config Rule Response
   */
  200: SingleDataResponse & {
    data?: DynamicConfigDto
  }
}

export type PatchConsoleV1DynamicConfigsByIdRuleByRuleIdResponse =
  PatchConsoleV1DynamicConfigsByIdRuleByRuleIdResponses[keyof PatchConsoleV1DynamicConfigsByIdRuleByRuleIdResponses]

export type GetConsoleV1DynamicConfigsByIdRulesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/dynamic_configs/{id}/rules'
}

export type GetConsoleV1DynamicConfigsByIdRulesResponses = {
  /**
   * Get Dynamic Config Rules Response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<DynamicConfigRulesDto>
  }
}

export type GetConsoleV1DynamicConfigsByIdRulesResponse =
  GetConsoleV1DynamicConfigsByIdRulesResponses[keyof GetConsoleV1DynamicConfigsByIdRulesResponses]

export type GetConsoleV1DynamicConfigsByIdVersionsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/dynamic_configs/{id}/versions'
}

export type GetConsoleV1DynamicConfigsByIdVersionsErrors = {
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1DynamicConfigsByIdVersionsError =
  GetConsoleV1DynamicConfigsByIdVersionsErrors[keyof GetConsoleV1DynamicConfigsByIdVersionsErrors]

export type GetConsoleV1DynamicConfigsByIdVersionsResponses = {
  /**
   * List Dynamic Config Versions Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<DynamicConfigDto>
  }
}

export type GetConsoleV1DynamicConfigsByIdVersionsResponse =
  GetConsoleV1DynamicConfigsByIdVersionsResponses[keyof GetConsoleV1DynamicConfigsByIdVersionsResponses]

export type GetConsoleV1EnvironmentsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/environments'
}

export type GetConsoleV1EnvironmentsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1EnvironmentsError = GetConsoleV1EnvironmentsErrors[keyof GetConsoleV1EnvironmentsErrors]

export type GetConsoleV1EnvironmentsResponses = {
  /**
   * Get Environments Response
   */
  200: SingleDataResponse & {
    data?: EnvironmentsContractDto
  }
}

export type GetConsoleV1EnvironmentsResponse =
  GetConsoleV1EnvironmentsResponses[keyof GetConsoleV1EnvironmentsResponses]

export type PostConsoleV1EnvironmentsData = {
  body: EnvironmentsUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/environments'
}

export type PostConsoleV1EnvironmentsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1EnvironmentsError = PostConsoleV1EnvironmentsErrors[keyof PostConsoleV1EnvironmentsErrors]

export type PostConsoleV1EnvironmentsResponses = {
  /**
   * Update Environments Response
   */
  200: SingleDataResponse & {
    data?: EnvironmentsContractDto
  }
}

export type PostConsoleV1EnvironmentsResponse =
  PostConsoleV1EnvironmentsResponses[keyof PostConsoleV1EnvironmentsResponses]

export type GetConsoleV1EventsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/events'
}

export type GetConsoleV1EventsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1EventsError = GetConsoleV1EventsErrors[keyof GetConsoleV1EventsErrors]

export type GetConsoleV1EventsResponses = {
  /**
   * List Events response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<LoggedEventDto>
  }
}

export type GetConsoleV1EventsResponse = GetConsoleV1EventsResponses[keyof GetConsoleV1EventsResponses]

export type GetConsoleV1EventsByEventNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    eventName: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/events/{eventName}'
}

export type GetConsoleV1EventsByEventNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1EventsByEventNameError =
  GetConsoleV1EventsByEventNameErrors[keyof GetConsoleV1EventsByEventNameErrors]

export type GetConsoleV1EventsByEventNameResponses = {
  /**
   * Get specific events response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<LoggedEventDto>
  }
}

export type GetConsoleV1EventsByEventNameResponse =
  GetConsoleV1EventsByEventNameResponses[keyof GetConsoleV1EventsByEventNameResponses]

export type GetConsoleV1EventsByEventNameMetricsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    eventName: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/events/{eventName}/metrics'
}

export type GetConsoleV1EventsByEventNameMetricsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1EventsByEventNameMetricsError =
  GetConsoleV1EventsByEventNameMetricsErrors[keyof GetConsoleV1EventsByEventNameMetricsErrors]

export type GetConsoleV1EventsByEventNameMetricsResponses = {
  /**
   * Get metrics from events response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalMetricDefinitionContractDto>
  }
}

export type GetConsoleV1EventsByEventNameMetricsResponse =
  GetConsoleV1EventsByEventNameMetricsResponses[keyof GetConsoleV1EventsByEventNameMetricsResponses]

export type GetConsoleV1ExperimentsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Which layer to place the experiment into.
     */
    layerID?: string
    /**
     * The idType the experiment will be performed on
     */
    idType?: string
    /**
     * The team ID associated with the experiment, Enterprise only.
     */
    teamID?: string | null
    /**
     * The current status of the experiment
     */
    status?:
      | 'active'
      | 'setup'
      | 'decision_made'
      | 'abandoned'
      | 'archived'
      | 'experiment_stopped'
      | 'assignment_stopped'
      | Array<
          'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
        >
    targetAppID?: string
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/experiments'
}

export type GetConsoleV1ExperimentsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsError = GetConsoleV1ExperimentsErrors[keyof GetConsoleV1ExperimentsErrors]

export type GetConsoleV1ExperimentsResponses = {
  /**
   * List Experiments Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalExperimentDto>
  }
}

export type GetConsoleV1ExperimentsResponse = GetConsoleV1ExperimentsResponses[keyof GetConsoleV1ExperimentsResponses]

export type PostConsoleV1ExperimentsData = {
  body: ExperimentCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/experiments'
}

export type PostConsoleV1ExperimentsErrors = {
  /**
   * Name is already in use
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsError = PostConsoleV1ExperimentsErrors[keyof PostConsoleV1ExperimentsErrors]

export type PostConsoleV1ExperimentsResponses = {
  /**
   * Create Experiment Success
   */
  201: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type PostConsoleV1ExperimentsResponse =
  PostConsoleV1ExperimentsResponses[keyof PostConsoleV1ExperimentsResponses]

export type DeleteConsoleV1ExperimentsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}'
}

export type DeleteConsoleV1ExperimentsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1ExperimentsByIdError =
  DeleteConsoleV1ExperimentsByIdErrors[keyof DeleteConsoleV1ExperimentsByIdErrors]

export type DeleteConsoleV1ExperimentsByIdResponses = {
  /**
   * Delete Experiment Success
   */
  200: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type DeleteConsoleV1ExperimentsByIdResponse =
  DeleteConsoleV1ExperimentsByIdResponses[keyof DeleteConsoleV1ExperimentsByIdResponses]

export type GetConsoleV1ExperimentsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}'
}

export type GetConsoleV1ExperimentsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1ExperimentsByIdError =
  GetConsoleV1ExperimentsByIdErrors[keyof GetConsoleV1ExperimentsByIdErrors]

export type GetConsoleV1ExperimentsByIdResponses = {
  /**
   * Get Experiment Success
   */
  200: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type GetConsoleV1ExperimentsByIdResponse =
  GetConsoleV1ExperimentsByIdResponses[keyof GetConsoleV1ExperimentsByIdResponses]

export type PatchConsoleV1ExperimentsByIdData = {
  body: ExperimentPartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}'
}

export type PatchConsoleV1ExperimentsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1ExperimentsByIdError =
  PatchConsoleV1ExperimentsByIdErrors[keyof PatchConsoleV1ExperimentsByIdErrors]

export type PatchConsoleV1ExperimentsByIdResponses = {
  /**
   * Partially Update Experiment Success
   */
  200: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type PatchConsoleV1ExperimentsByIdResponse =
  PatchConsoleV1ExperimentsByIdResponses[keyof PatchConsoleV1ExperimentsByIdResponses]

export type PostConsoleV1ExperimentsByIdData = {
  body: ExperimentFullUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}'
}

export type PostConsoleV1ExperimentsByIdErrors = {
  /**
   * Name is already in use
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsByIdError =
  PostConsoleV1ExperimentsByIdErrors[keyof PostConsoleV1ExperimentsByIdErrors]

export type PostConsoleV1ExperimentsByIdResponses = {
  /**
   * Fully Update Experiment Success
   */
  200: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type PostConsoleV1ExperimentsByIdResponse =
  PostConsoleV1ExperimentsByIdResponses[keyof PostConsoleV1ExperimentsByIdResponses]

export type PutConsoleV1ExperimentsByIdAbandonData = {
  body: ExperimentAbandonDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/abandon'
}

export type PutConsoleV1ExperimentsByIdAbandonErrors = {
  /**
   * Experiment has not yet started
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdAbandonError =
  PutConsoleV1ExperimentsByIdAbandonErrors[keyof PutConsoleV1ExperimentsByIdAbandonErrors]

export type PutConsoleV1ExperimentsByIdAbandonResponses = {
  /**
   * Abandon Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdAbandonResponse =
  PutConsoleV1ExperimentsByIdAbandonResponses[keyof PutConsoleV1ExperimentsByIdAbandonResponses]

export type PutConsoleV1ExperimentsByIdArchiveData = {
  body: ExperimentArchiveDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/archive'
}

export type PutConsoleV1ExperimentsByIdArchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdArchiveError =
  PutConsoleV1ExperimentsByIdArchiveErrors[keyof PutConsoleV1ExperimentsByIdArchiveErrors]

export type PutConsoleV1ExperimentsByIdArchiveResponses = {
  /**
   * Archive Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdArchiveResponse =
  PutConsoleV1ExperimentsByIdArchiveResponses[keyof PutConsoleV1ExperimentsByIdArchiveResponses]

export type GetConsoleV1ExperimentsByIdCumulativeExposuresData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/cumulative_exposures'
}

export type GetConsoleV1ExperimentsByIdCumulativeExposuresResponses = {
  /**
   * Get cumulative exposures success
   */
  200: SingleDataResponse & {
    data?: CumulativeExposureResponseDto
  }
}

export type GetConsoleV1ExperimentsByIdCumulativeExposuresResponse =
  GetConsoleV1ExperimentsByIdCumulativeExposuresResponses[keyof GetConsoleV1ExperimentsByIdCumulativeExposuresResponses]

export type PostConsoleV1ExperimentsByIdDisableGroupsData = {
  body: EnableDisableGroupsDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/disable_groups'
}

export type PostConsoleV1ExperimentsByIdDisableGroupsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsByIdDisableGroupsError =
  PostConsoleV1ExperimentsByIdDisableGroupsErrors[keyof PostConsoleV1ExperimentsByIdDisableGroupsErrors]

export type PostConsoleV1ExperimentsByIdDisableGroupsResponses = {
  /**
   * Disable experiment groups
   */
  201: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type PostConsoleV1ExperimentsByIdDisableGroupsResponse =
  PostConsoleV1ExperimentsByIdDisableGroupsResponses[keyof PostConsoleV1ExperimentsByIdDisableGroupsResponses]

export type PostConsoleV1ExperimentsByIdEnableGroupsData = {
  body: EnableDisableGroupsDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/enable_groups'
}

export type PostConsoleV1ExperimentsByIdEnableGroupsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsByIdEnableGroupsError =
  PostConsoleV1ExperimentsByIdEnableGroupsErrors[keyof PostConsoleV1ExperimentsByIdEnableGroupsErrors]

export type PostConsoleV1ExperimentsByIdEnableGroupsResponses = {
  /**
   * Enable experiment groups
   */
  201: SingleDataResponse & {
    data?: ExternalExperimentDto
  }
}

export type PostConsoleV1ExperimentsByIdEnableGroupsResponse =
  PostConsoleV1ExperimentsByIdEnableGroupsResponses[keyof PostConsoleV1ExperimentsByIdEnableGroupsResponses]

export type PostConsoleV1ExperimentsByIdLoadPulseData = {
  body: EchidnaLoadPulseQueryDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    refresh?: 'full' | 'incremental' | 'metric'
    metricIDs?: Array<string>
    ruleId?: string
    turboMode?: boolean
  }
  url: '/console/v1/experiments/{id}/load_pulse'
}

export type PostConsoleV1ExperimentsByIdLoadPulseErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsByIdLoadPulseError =
  PostConsoleV1ExperimentsByIdLoadPulseErrors[keyof PostConsoleV1ExperimentsByIdLoadPulseErrors]

export type PostConsoleV1ExperimentsByIdLoadPulseResponses = {
  /**
   * Load Pulse Success
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1ExperimentsByIdLoadPulseResponse =
  PostConsoleV1ExperimentsByIdLoadPulseResponses[keyof PostConsoleV1ExperimentsByIdLoadPulseResponses]

export type PutConsoleV1ExperimentsByIdMakeDecisionData = {
  body: ExperimentStatusUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/make_decision'
}

export type PutConsoleV1ExperimentsByIdMakeDecisionErrors = {
  /**
   * Experiment has not yet started
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdMakeDecisionError =
  PutConsoleV1ExperimentsByIdMakeDecisionErrors[keyof PutConsoleV1ExperimentsByIdMakeDecisionErrors]

export type PutConsoleV1ExperimentsByIdMakeDecisionResponses = {
  /**
   * Make Experiment Decision Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdMakeDecisionResponse =
  PutConsoleV1ExperimentsByIdMakeDecisionResponses[keyof PutConsoleV1ExperimentsByIdMakeDecisionResponses]

export type DeleteConsoleV1ExperimentsByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/overrides'
}

export type DeleteConsoleV1ExperimentsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1ExperimentsByIdOverridesError =
  DeleteConsoleV1ExperimentsByIdOverridesErrors[keyof DeleteConsoleV1ExperimentsByIdOverridesErrors]

export type DeleteConsoleV1ExperimentsByIdOverridesResponses = {
  /**
   * Delete Update Experiment Overrides Success
   */
  200: SingleDataResponse & {
    data?: ExperimentOverridesDto
  }
}

export type DeleteConsoleV1ExperimentsByIdOverridesResponse =
  DeleteConsoleV1ExperimentsByIdOverridesResponses[keyof DeleteConsoleV1ExperimentsByIdOverridesResponses]

export type GetConsoleV1ExperimentsByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/overrides'
}

export type GetConsoleV1ExperimentsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1ExperimentsByIdOverridesError =
  GetConsoleV1ExperimentsByIdOverridesErrors[keyof GetConsoleV1ExperimentsByIdOverridesErrors]

export type GetConsoleV1ExperimentsByIdOverridesResponses = {
  /**
   * Get Experiment Overrides Success
   */
  200: SingleDataResponse & {
    data?: ExperimentOverridesDto
  }
}

export type GetConsoleV1ExperimentsByIdOverridesResponse =
  GetConsoleV1ExperimentsByIdOverridesResponses[keyof GetConsoleV1ExperimentsByIdOverridesResponses]

export type PatchConsoleV1ExperimentsByIdOverridesData = {
  body: ExperimentOverridesDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/overrides'
}

export type PatchConsoleV1ExperimentsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1ExperimentsByIdOverridesError =
  PatchConsoleV1ExperimentsByIdOverridesErrors[keyof PatchConsoleV1ExperimentsByIdOverridesErrors]

export type PatchConsoleV1ExperimentsByIdOverridesResponses = {
  /**
   * Partially Update Experiment Overrides Success
   */
  200: SingleDataResponse & {
    data?: ExperimentOverridesDto
  }
}

export type PatchConsoleV1ExperimentsByIdOverridesResponse =
  PatchConsoleV1ExperimentsByIdOverridesResponses[keyof PatchConsoleV1ExperimentsByIdOverridesResponses]

export type PostConsoleV1ExperimentsByIdOverridesData = {
  body: ExperimentOverridesDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/overrides'
}

export type PostConsoleV1ExperimentsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsByIdOverridesError =
  PostConsoleV1ExperimentsByIdOverridesErrors[keyof PostConsoleV1ExperimentsByIdOverridesErrors]

export type PostConsoleV1ExperimentsByIdOverridesResponses = {
  /**
   * Update Experiment Overrides Success
   */
  200: SingleDataResponse & {
    data?: ExperimentOverridesDto
  }
}

export type PostConsoleV1ExperimentsByIdOverridesResponse =
  PostConsoleV1ExperimentsByIdOverridesResponses[keyof PostConsoleV1ExperimentsByIdOverridesResponses]

export type GetConsoleV1ExperimentsByIdPulseLoadHistoryData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/experiments/{id}/pulse_load_history'
}

export type GetConsoleV1ExperimentsByIdPulseLoadHistoryErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsByIdPulseLoadHistoryError =
  GetConsoleV1ExperimentsByIdPulseLoadHistoryErrors[keyof GetConsoleV1ExperimentsByIdPulseLoadHistoryErrors]

export type GetConsoleV1ExperimentsByIdPulseLoadHistoryResponses = {
  /**
   * List Pulse Load History
   */
  200: PaginationResponseWithMessage & {
    data?: Array<PulseLoadHistoryDto>
  }
}

export type GetConsoleV1ExperimentsByIdPulseLoadHistoryResponse =
  GetConsoleV1ExperimentsByIdPulseLoadHistoryResponses[keyof GetConsoleV1ExperimentsByIdPulseLoadHistoryResponses]

export type GetConsoleV1ExperimentsByIdPulseResultsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query: {
    /**
     * Control Group ID
     */
    control: string
    /**
     * Test Group ID
     */
    test: string
    /**
     * Whether to apply CUPED. Allowed values are "true" or "false".
     */
    cuped?: string
    /**
     * Confidence interval (0-100)
     */
    confidence?: string
    /**
     * Whether to apply Bonferroni Per Variant. Allowed values are "true" or "false".
     */
    applyBonferroniPerVariant?: string
    /**
     * Whether to apply Bonferroni Per Metric. Allowed values are "true" or "false".
     */
    applyBonferroniPerMetric?: string
    /**
     * Î± allocated to primary metrics
     */
    bonferroniPrimaryMetricWeight?: string
    /**
     * Whether to apply Benjamini-Hochberg Correction Per Metric. Allowed values are "true" or "false".
     */
    applyBenjaminiHochbergPerMetric?: string
    /**
     * Whether to apply Benjamini-Hochberg Correction Per Variant. Allowed values are "true" or "false".
     */
    applyBenjaminiHochbergPerVariant?: string
    /**
     * Date for pulse results. format must be YYYY-MM-DD
     */
    date?: string
  }
  url: '/console/v1/experiments/{id}/pulse_results'
}

export type GetConsoleV1ExperimentsByIdPulseResultsResponses = {
  /**
   * Get Pulse Results Success
   */
  200: SingleDataResponse & {
    data?: ExperimentPulseResultsDto
  }
}

export type GetConsoleV1ExperimentsByIdPulseResultsResponse =
  GetConsoleV1ExperimentsByIdPulseResultsResponses[keyof GetConsoleV1ExperimentsByIdPulseResultsResponses]

export type PutConsoleV1ExperimentsByIdResetData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/reset'
}

export type PutConsoleV1ExperimentsByIdResetErrors = {
  /**
   * Experiment has not yet started
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdResetError =
  PutConsoleV1ExperimentsByIdResetErrors[keyof PutConsoleV1ExperimentsByIdResetErrors]

export type PutConsoleV1ExperimentsByIdResetResponses = {
  /**
   * Reset Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdResetResponse =
  PutConsoleV1ExperimentsByIdResetResponses[keyof PutConsoleV1ExperimentsByIdResetResponses]

export type PutConsoleV1ExperimentsByIdStartData = {
  body: ExperimentStartDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/start'
}

export type PutConsoleV1ExperimentsByIdStartErrors = {
  /**
   * Experiment has not yet started
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdStartError =
  PutConsoleV1ExperimentsByIdStartErrors[keyof PutConsoleV1ExperimentsByIdStartErrors]

export type PutConsoleV1ExperimentsByIdStartResponses = {
  /**
   * Start Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdStartResponse =
  PutConsoleV1ExperimentsByIdStartResponses[keyof PutConsoleV1ExperimentsByIdStartResponses]

export type PutConsoleV1ExperimentsByIdUnarchiveData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/experiments/{id}/unarchive'
}

export type PutConsoleV1ExperimentsByIdUnarchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Experiment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1ExperimentsByIdUnarchiveError =
  PutConsoleV1ExperimentsByIdUnarchiveErrors[keyof PutConsoleV1ExperimentsByIdUnarchiveErrors]

export type PutConsoleV1ExperimentsByIdUnarchiveResponses = {
  /**
   * Unarchive Experiment Success
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1ExperimentsByIdUnarchiveResponse =
  PutConsoleV1ExperimentsByIdUnarchiveResponses[keyof PutConsoleV1ExperimentsByIdUnarchiveResponses]

export type DeleteConsoleV1ExperimentsAssignmentSourceByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Name of the assignment source
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/assignment_source/{name}'
}

export type DeleteConsoleV1ExperimentsAssignmentSourceByNameResponses = {
  /**
   * Delete Assignment Source response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1ExperimentsAssignmentSourceByNameResponse =
  DeleteConsoleV1ExperimentsAssignmentSourceByNameResponses[keyof DeleteConsoleV1ExperimentsAssignmentSourceByNameResponses]

export type PatchConsoleV1ExperimentsAssignmentSourceByNameData = {
  body: AssignmentSourcePartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Name of the assignment source
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/assignment_source/{name}'
}

export type PatchConsoleV1ExperimentsAssignmentSourceByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1ExperimentsAssignmentSourceByNameError =
  PatchConsoleV1ExperimentsAssignmentSourceByNameErrors[keyof PatchConsoleV1ExperimentsAssignmentSourceByNameErrors]

export type PatchConsoleV1ExperimentsAssignmentSourceByNameResponses = {
  /**
   * Patch Assignment Source response
   */
  200: SingleDataResponse & {
    data?: AssignmentSourceContractDto
  }
}

export type PatchConsoleV1ExperimentsAssignmentSourceByNameResponse =
  PatchConsoleV1ExperimentsAssignmentSourceByNameResponses[keyof PatchConsoleV1ExperimentsAssignmentSourceByNameResponses]

export type PostConsoleV1ExperimentsAssignmentSourceByNameData = {
  body: AssignmentSourceQueryUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Name of the assignment source
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/assignment_source/{name}'
}

export type PostConsoleV1ExperimentsAssignmentSourceByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsAssignmentSourceByNameError =
  PostConsoleV1ExperimentsAssignmentSourceByNameErrors[keyof PostConsoleV1ExperimentsAssignmentSourceByNameErrors]

export type PostConsoleV1ExperimentsAssignmentSourceByNameResponses = {
  /**
   * Post Assignment Source response
   */
  200: SingleDataResponse & {
    data?: AssignmentSourceContractDto
  }
}

export type PostConsoleV1ExperimentsAssignmentSourceByNameResponse =
  PostConsoleV1ExperimentsAssignmentSourceByNameResponses[keyof PostConsoleV1ExperimentsAssignmentSourceByNameResponses]

export type GetConsoleV1ExperimentsAssignmentSourcesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/experiments/assignment_sources'
}

export type GetConsoleV1ExperimentsAssignmentSourcesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsAssignmentSourcesError =
  GetConsoleV1ExperimentsAssignmentSourcesErrors[keyof GetConsoleV1ExperimentsAssignmentSourcesErrors]

export type GetConsoleV1ExperimentsAssignmentSourcesResponses = {
  /**
   * List Assignment Sources response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<AssignmentSourceContractDto>
  }
}

export type GetConsoleV1ExperimentsAssignmentSourcesResponse =
  GetConsoleV1ExperimentsAssignmentSourcesResponses[keyof GetConsoleV1ExperimentsAssignmentSourcesResponses]

export type PostConsoleV1ExperimentsAssignmentSourcesData = {
  body: AssignmentSourceCreationDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/experiments/assignment_sources'
}

export type PostConsoleV1ExperimentsAssignmentSourcesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsAssignmentSourcesError =
  PostConsoleV1ExperimentsAssignmentSourcesErrors[keyof PostConsoleV1ExperimentsAssignmentSourcesErrors]

export type PostConsoleV1ExperimentsAssignmentSourcesResponses = {
  /**
   * Create Assignment Source response
   */
  201: SingleDataResponse & {
    data?: AssignmentSourceContractDto
  }
}

export type PostConsoleV1ExperimentsAssignmentSourcesResponse =
  PostConsoleV1ExperimentsAssignmentSourcesResponses[keyof PostConsoleV1ExperimentsAssignmentSourcesResponses]

export type GetConsoleV1ExperimentsEntityPropertiesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/experiments/entity_properties'
}

export type GetConsoleV1ExperimentsEntityPropertiesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsEntityPropertiesError =
  GetConsoleV1ExperimentsEntityPropertiesErrors[keyof GetConsoleV1ExperimentsEntityPropertiesErrors]

export type GetConsoleV1ExperimentsEntityPropertiesResponses = {
  /**
   * List Entity Property Sources response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<EntityPropertySourceDto>
  }
}

export type GetConsoleV1ExperimentsEntityPropertiesResponse =
  GetConsoleV1ExperimentsEntityPropertiesResponses[keyof GetConsoleV1ExperimentsEntityPropertiesResponses]

export type PostConsoleV1ExperimentsEntityPropertiesData = {
  body: EntityPropertySourceCreationDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/experiments/entity_properties'
}

export type PostConsoleV1ExperimentsEntityPropertiesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsEntityPropertiesError =
  PostConsoleV1ExperimentsEntityPropertiesErrors[keyof PostConsoleV1ExperimentsEntityPropertiesErrors]

export type PostConsoleV1ExperimentsEntityPropertiesResponses = {
  /**
   * Create Entity Property Source response
   */
  201: SingleDataResponse & {
    data?: EntityPropertySourceDto
  }
}

export type PostConsoleV1ExperimentsEntityPropertiesResponse =
  PostConsoleV1ExperimentsEntityPropertiesResponses[keyof PostConsoleV1ExperimentsEntityPropertiesResponses]

export type DeleteConsoleV1ExperimentsEntityPropertyByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/entity_property/{name}'
}

export type DeleteConsoleV1ExperimentsEntityPropertyByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1ExperimentsEntityPropertyByNameError =
  DeleteConsoleV1ExperimentsEntityPropertyByNameErrors[keyof DeleteConsoleV1ExperimentsEntityPropertyByNameErrors]

export type DeleteConsoleV1ExperimentsEntityPropertyByNameResponses = {
  /**
   * Delete Entity Property Source response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1ExperimentsEntityPropertyByNameResponse =
  DeleteConsoleV1ExperimentsEntityPropertyByNameResponses[keyof DeleteConsoleV1ExperimentsEntityPropertyByNameResponses]

export type GetConsoleV1ExperimentsEntityPropertyByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Name of entity property source
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/entity_property/{name}'
}

export type GetConsoleV1ExperimentsEntityPropertyByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsEntityPropertyByNameError =
  GetConsoleV1ExperimentsEntityPropertyByNameErrors[keyof GetConsoleV1ExperimentsEntityPropertyByNameErrors]

export type GetConsoleV1ExperimentsEntityPropertyByNameResponses = {
  /**
   * Get Entity Property Source response
   */
  200: SingleDataResponse & {
    data?: EntityPropertySourceDto
  }
}

export type GetConsoleV1ExperimentsEntityPropertyByNameResponse =
  GetConsoleV1ExperimentsEntityPropertyByNameResponses[keyof GetConsoleV1ExperimentsEntityPropertyByNameResponses]

export type PatchConsoleV1ExperimentsEntityPropertyByNameData = {
  body: EntityPropertySourcePartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Name of entity property source
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/entity_property/{name}'
}

export type PatchConsoleV1ExperimentsEntityPropertyByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1ExperimentsEntityPropertyByNameError =
  PatchConsoleV1ExperimentsEntityPropertyByNameErrors[keyof PatchConsoleV1ExperimentsEntityPropertyByNameErrors]

export type PatchConsoleV1ExperimentsEntityPropertyByNameResponses = {
  /**
   * Patch Entity Property Source response
   */
  200: SingleDataResponse & {
    data?: EntityPropertySourceDto
  }
}

export type PatchConsoleV1ExperimentsEntityPropertyByNameResponse =
  PatchConsoleV1ExperimentsEntityPropertyByNameResponses[keyof PatchConsoleV1ExperimentsEntityPropertyByNameResponses]

export type PostConsoleV1ExperimentsEntityPropertyByNameData = {
  body: EntityPropertySourceQueryUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/entity_property/{name}'
}

export type PostConsoleV1ExperimentsEntityPropertyByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1ExperimentsEntityPropertyByNameError =
  PostConsoleV1ExperimentsEntityPropertyByNameErrors[keyof PostConsoleV1ExperimentsEntityPropertyByNameErrors]

export type PostConsoleV1ExperimentsEntityPropertyByNameResponses = {
  /**
   * Post Entity Property Source response
   */
  200: SingleDataResponse & {
    data?: EntityPropertySourceDto
  }
}

export type PostConsoleV1ExperimentsEntityPropertyByNameResponse =
  PostConsoleV1ExperimentsEntityPropertyByNameResponses[keyof PostConsoleV1ExperimentsEntityPropertyByNameResponses]

export type GetConsoleV1ExperimentsQualifyingEventsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/experiments/qualifying_events'
}

export type GetConsoleV1ExperimentsQualifyingEventsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsQualifyingEventsError =
  GetConsoleV1ExperimentsQualifyingEventsErrors[keyof GetConsoleV1ExperimentsQualifyingEventsErrors]

export type GetConsoleV1ExperimentsQualifyingEventsResponses = {
  /**
   * List metric source response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<MetricSourceContractDto>
  }
}

export type GetConsoleV1ExperimentsQualifyingEventsResponse =
  GetConsoleV1ExperimentsQualifyingEventsResponses[keyof GetConsoleV1ExperimentsQualifyingEventsResponses]

export type PostConsoleV1ExperimentsQualifyingEventsData = {
  body: MetricSourceCreationContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/experiments/qualifying_events'
}

export type PostConsoleV1ExperimentsQualifyingEventsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsQualifyingEventsError =
  PostConsoleV1ExperimentsQualifyingEventsErrors[keyof PostConsoleV1ExperimentsQualifyingEventsErrors]

export type PostConsoleV1ExperimentsQualifyingEventsResponses = {
  /**
   * Create qualifying event response
   */
  201: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type PostConsoleV1ExperimentsQualifyingEventsResponse =
  PostConsoleV1ExperimentsQualifyingEventsResponses[keyof PostConsoleV1ExperimentsQualifyingEventsResponses]

export type DeleteConsoleV1ExperimentsQualifyingEventsByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/qualifying_events/{name}'
}

export type DeleteConsoleV1ExperimentsQualifyingEventsByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type DeleteConsoleV1ExperimentsQualifyingEventsByNameError =
  DeleteConsoleV1ExperimentsQualifyingEventsByNameErrors[keyof DeleteConsoleV1ExperimentsQualifyingEventsByNameErrors]

export type DeleteConsoleV1ExperimentsQualifyingEventsByNameResponses = {
  /**
   * Delete Qualifying Event response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1ExperimentsQualifyingEventsByNameResponse =
  DeleteConsoleV1ExperimentsQualifyingEventsByNameResponses[keyof DeleteConsoleV1ExperimentsQualifyingEventsByNameResponses]

export type GetConsoleV1ExperimentsQualifyingEventsByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/qualifying_events/{name}'
}

export type GetConsoleV1ExperimentsQualifyingEventsByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExperimentsQualifyingEventsByNameError =
  GetConsoleV1ExperimentsQualifyingEventsByNameErrors[keyof GetConsoleV1ExperimentsQualifyingEventsByNameErrors]

export type GetConsoleV1ExperimentsQualifyingEventsByNameResponses = {
  /**
   * Read Qualifying Event response
   */
  200: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type GetConsoleV1ExperimentsQualifyingEventsByNameResponse =
  GetConsoleV1ExperimentsQualifyingEventsByNameResponses[keyof GetConsoleV1ExperimentsQualifyingEventsByNameResponses]

export type PostConsoleV1ExperimentsQualifyingEventsByNameData = {
  body: MetricSourceUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/experiments/qualifying_events/{name}'
}

export type PostConsoleV1ExperimentsQualifyingEventsByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1ExperimentsQualifyingEventsByNameError =
  PostConsoleV1ExperimentsQualifyingEventsByNameErrors[keyof PostConsoleV1ExperimentsQualifyingEventsByNameErrors]

export type PostConsoleV1ExperimentsQualifyingEventsByNameResponses = {
  /**
   * Update Qualifying Event response
   */
  200: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type PostConsoleV1ExperimentsQualifyingEventsByNameResponse =
  PostConsoleV1ExperimentsQualifyingEventsByNameResponses[keyof PostConsoleV1ExperimentsQualifyingEventsByNameResponses]

export type GetConsoleV1ExposureCountData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    experiments?: string | Array<string>
    gates?: string | Array<string>
    dynamicConfigs?: string | Array<string>
  }
  url: '/console/v1/exposure_count'
}

export type GetConsoleV1ExposureCountErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ExposureCountError = GetConsoleV1ExposureCountErrors[keyof GetConsoleV1ExposureCountErrors]

export type GetConsoleV1ExposureCountResponses = {
  /**
   * Get Experiment Success
   */
  200: SingleDataResponse & {
    data?: ExposureCountDto
  }
}

export type GetConsoleV1ExposureCountResponse =
  GetConsoleV1ExposureCountResponses[keyof GetConsoleV1ExposureCountResponses]

export type GetConsoleV1GatesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Filter by idType
     */
    idType?: string | Array<string>
    /**
     * Filter by type
     */
    type?: 'TEMPORARY' | 'PERMANENT' | 'STALE' | 'TEMPLATE'
    /**
     * Filter by typeReason
     */
    typeReason?:
      | 'NONE'
      | 'STALE_PROBABLY_LAUNCHED'
      | 'STALE_PROBABLY_UNLAUNCHED'
      | 'STALE_PROBABLY_FORGOTTEN'
      | 'STALE_NO_RULES'
      | 'STALE_PROBABLY_DEAD_CHECK'
      | 'STALE_EMPTY_CHECKS'
      | 'STALE_ALL_TRUE'
      | 'STALE_ALL_FALSE'
    /**
     * Filter by pass rate of the gates, as determined by a sampling of overall true/false values returned: 0, 100, or INBETWEEN (pass rate greater than zero but less than 100)
     */
    passRate?: '0' | '100' | 'INBETWEEN' | Array<'0' | '100' | 'INBETWEEN'>
    /**
     * Filter by rollout rate of the gates: 0 (all rules are set to pass 0%), 100 (all rules pass 100% including an "everyone" catch all rule), or INBETWEEN (at least one rule has a pass rate greater than 0 but less than 100)
     */
    rolloutRate?: '0' | '100' | 'INBETWEEN' | Array<'0' | '100' | 'INBETWEEN'>
    /**
     * Filter by release pipeline ID
     */
    releasePipelineID?: string | null
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/gates'
}

export type GetConsoleV1GatesErrors = {
  /**
   * Forbidden resource
   */
  403: {
    status: 403
    message: 'Forbidden resource'
  }
}

export type GetConsoleV1GatesError = GetConsoleV1GatesErrors[keyof GetConsoleV1GatesErrors]

export type GetConsoleV1GatesResponses = {
  /**
   * List gates success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalGateDto>
  }
}

export type GetConsoleV1GatesResponse = GetConsoleV1GatesResponses[keyof GetConsoleV1GatesResponses]

export type PostConsoleV1GatesData = {
  body: GateCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/gates'
}

export type PostConsoleV1GatesResponses = {
  /**
   * Create gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PostConsoleV1GatesResponse = PostConsoleV1GatesResponses[keyof PostConsoleV1GatesResponses]

export type DeleteConsoleV1GatesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}'
}

export type DeleteConsoleV1GatesByIdResponses = {
  /**
   * Delete gate response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1GatesByIdResponse =
  DeleteConsoleV1GatesByIdResponses[keyof DeleteConsoleV1GatesByIdResponses]

export type GetConsoleV1GatesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}'
}

export type GetConsoleV1GatesByIdResponses = {
  /**
   * Get gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type GetConsoleV1GatesByIdResponse = GetConsoleV1GatesByIdResponses[keyof GetConsoleV1GatesByIdResponses]

export type PatchConsoleV1GatesByIdData = {
  body: GatePartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}'
}

export type PatchConsoleV1GatesByIdResponses = {
  /**
   * Update gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PatchConsoleV1GatesByIdResponse = PatchConsoleV1GatesByIdResponses[keyof PatchConsoleV1GatesByIdResponses]

export type PostConsoleV1GatesByIdData = {
  body: GateFullUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}'
}

export type PostConsoleV1GatesByIdResponses = {
  /**
   * Update gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PostConsoleV1GatesByIdResponse = PostConsoleV1GatesByIdResponses[keyof PostConsoleV1GatesByIdResponses]

export type PutConsoleV1GatesByIdArchiveData = {
  body: ArchiveSchemaDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/archive'
}

export type PutConsoleV1GatesByIdArchiveResponses = {
  /**
   * Archive gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PutConsoleV1GatesByIdArchiveResponse =
  PutConsoleV1GatesByIdArchiveResponses[keyof PutConsoleV1GatesByIdArchiveResponses]

export type PutConsoleV1GatesByIdDisableData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/disable'
}

export type PutConsoleV1GatesByIdDisableResponses = {
  /**
   * Launch gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PutConsoleV1GatesByIdDisableResponse =
  PutConsoleV1GatesByIdDisableResponses[keyof PutConsoleV1GatesByIdDisableResponses]

export type PutConsoleV1GatesByIdEnableData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/enable'
}

export type PutConsoleV1GatesByIdEnableResponses = {
  /**
   * Enable gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PutConsoleV1GatesByIdEnableResponse =
  PutConsoleV1GatesByIdEnableResponses[keyof PutConsoleV1GatesByIdEnableResponses]

export type PutConsoleV1GatesByIdLaunchData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/launch'
}

export type PutConsoleV1GatesByIdLaunchResponses = {
  /**
   * Launch gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PutConsoleV1GatesByIdLaunchResponse =
  PutConsoleV1GatesByIdLaunchResponses[keyof PutConsoleV1GatesByIdLaunchResponses]

export type PostConsoleV1GatesByIdLoadPulseData = {
  body: EchidnaGateLoadPulseQueryDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/load_pulse'
}

export type PostConsoleV1GatesByIdLoadPulseResponses = {
  /**
   * Load Pulse Gate Response
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1GatesByIdLoadPulseResponse =
  PostConsoleV1GatesByIdLoadPulseResponses[keyof PostConsoleV1GatesByIdLoadPulseResponses]

export type DeleteConsoleV1GatesByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/overrides'
}

export type DeleteConsoleV1GatesByIdOverridesResponses = {
  /**
   * Delete Gate Override Success
   */
  201: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type DeleteConsoleV1GatesByIdOverridesResponse =
  DeleteConsoleV1GatesByIdOverridesResponses[keyof DeleteConsoleV1GatesByIdOverridesResponses]

export type GetConsoleV1GatesByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/overrides'
}

export type GetConsoleV1GatesByIdOverridesResponses = {
  /**
   * Get Gate Override Success
   */
  201: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type GetConsoleV1GatesByIdOverridesResponse =
  GetConsoleV1GatesByIdOverridesResponses[keyof GetConsoleV1GatesByIdOverridesResponses]

export type PatchConsoleV1GatesByIdOverridesData = {
  body: UpdateOverridesContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/overrides'
}

export type PatchConsoleV1GatesByIdOverridesResponses = {
  /**
   * Add Gate Override Success
   */
  201: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type PatchConsoleV1GatesByIdOverridesResponse =
  PatchConsoleV1GatesByIdOverridesResponses[keyof PatchConsoleV1GatesByIdOverridesResponses]

export type PostConsoleV1GatesByIdOverridesData = {
  body: UpdateOverridesContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/overrides'
}

export type PostConsoleV1GatesByIdOverridesResponses = {
  /**
   * Update Gate Override Success
   */
  201: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type PostConsoleV1GatesByIdOverridesResponse =
  PostConsoleV1GatesByIdOverridesResponses[keyof PostConsoleV1GatesByIdOverridesResponses]

export type PostConsoleV1GatesByIdRuleData = {
  body: RuleDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rule'
}

export type PostConsoleV1GatesByIdRuleResponses = {
  /**
   * Add Gate Rule Response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PostConsoleV1GatesByIdRuleResponse =
  PostConsoleV1GatesByIdRuleResponses[keyof PostConsoleV1GatesByIdRuleResponses]

export type GetConsoleV1GatesByIdRulesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rules'
}

export type GetConsoleV1GatesByIdRulesResponses = {
  /**
   * Get gate rules response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<GateRulesDto>
  }
}

export type GetConsoleV1GatesByIdRulesResponse =
  GetConsoleV1GatesByIdRulesResponses[keyof GetConsoleV1GatesByIdRulesResponses]

export type PatchConsoleV1GatesByIdRulesData = {
  body: MultiRuleUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rules'
}

export type PatchConsoleV1GatesByIdRulesResponses = {
  /**
   * Update gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PatchConsoleV1GatesByIdRulesResponse =
  PatchConsoleV1GatesByIdRulesResponses[keyof PatchConsoleV1GatesByIdRulesResponses]

export type PostConsoleV1GatesByIdRulesData = {
  body: MultiRuleDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rules'
}

export type PostConsoleV1GatesByIdRulesResponses = {
  /**
   * Add Multiple Gate Rules Response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PostConsoleV1GatesByIdRulesResponse =
  PostConsoleV1GatesByIdRulesResponses[keyof PostConsoleV1GatesByIdRulesResponses]

export type DeleteConsoleV1GatesByIdRulesByRuleIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Gate ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleID: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rules/{ruleID}'
}

export type DeleteConsoleV1GatesByIdRulesByRuleIdResponses = {
  /**
   * Update gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type DeleteConsoleV1GatesByIdRulesByRuleIdResponse =
  DeleteConsoleV1GatesByIdRulesByRuleIdResponses[keyof DeleteConsoleV1GatesByIdRulesByRuleIdResponses]

export type PatchConsoleV1GatesByIdRulesByRuleIdData = {
  body: RuleUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Gate ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleID: string
  }
  query?: never
  url: '/console/v1/gates/{id}/rules/{ruleID}'
}

export type PatchConsoleV1GatesByIdRulesByRuleIdResponses = {
  /**
   * Update gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PatchConsoleV1GatesByIdRulesByRuleIdResponse =
  PatchConsoleV1GatesByIdRulesByRuleIdResponses[keyof PatchConsoleV1GatesByIdRulesByRuleIdResponses]

export type GetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Gate ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleID: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/gates/{id}/rules/{ruleID}/pulse_load_history'
}

export type GetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryResponses = {
  /**
   * List Pulse Load History
   */
  200: PaginationResponseWithMessage & {
    data?: Array<PulseLoadHistoryDto>
  }
}

export type GetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryResponse =
  GetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryResponses[keyof GetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryResponses]

export type GetConsoleV1GatesByIdRulesByRuleIdPulseResultsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * Gate ID
     */
    id: string
    /**
     * Rule ID
     */
    ruleID: string
  }
  query?: {
    /**
     * Whether to apply CUPED. Allowed values are "true" or "false".
     */
    cuped?: string
    /**
     * Confidence interval (0-100)
     */
    confidence?: string
  }
  url: '/console/v1/gates/{id}/rules/{ruleID}/pulse_results'
}

export type GetConsoleV1GatesByIdRulesByRuleIdPulseResultsResponses = {
  /**
   * Get Pulse Results Success
   */
  200: SingleDataResponse & {
    data?: GatePulseResultsDto
  }
}

export type GetConsoleV1GatesByIdRulesByRuleIdPulseResultsResponse =
  GetConsoleV1GatesByIdRulesByRuleIdPulseResultsResponses[keyof GetConsoleV1GatesByIdRulesByRuleIdPulseResultsResponses]

export type PutConsoleV1GatesByIdUnarchiveData = {
  body: UnarchiveSchemaDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/gates/{id}/unarchive'
}

export type PutConsoleV1GatesByIdUnarchiveResponses = {
  /**
   * Unarchive gate response
   */
  200: SingleDataResponse & {
    data?: ExternalGateDto
  }
}

export type PutConsoleV1GatesByIdUnarchiveResponse =
  PutConsoleV1GatesByIdUnarchiveResponses[keyof PutConsoleV1GatesByIdUnarchiveResponses]

export type GetConsoleV1GatesByIdVersionsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/gates/{id}/versions'
}

export type GetConsoleV1GatesByIdVersionsErrors = {
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1GatesByIdVersionsError =
  GetConsoleV1GatesByIdVersionsErrors[keyof GetConsoleV1GatesByIdVersionsErrors]

export type GetConsoleV1GatesByIdVersionsResponses = {
  /**
   * List Gate Versions Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalGateDto>
  }
}

export type GetConsoleV1GatesByIdVersionsResponse =
  GetConsoleV1GatesByIdVersionsResponses[keyof GetConsoleV1GatesByIdVersionsResponses]

export type GetConsoleV1HoldoutsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/holdouts'
}

export type GetConsoleV1HoldoutsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1HoldoutsError = GetConsoleV1HoldoutsErrors[keyof GetConsoleV1HoldoutsErrors]

export type GetConsoleV1HoldoutsResponses = {
  /**
   * List holdouts response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<HoldoutDto>
  }
}

export type GetConsoleV1HoldoutsResponse = GetConsoleV1HoldoutsResponses[keyof GetConsoleV1HoldoutsResponses]

export type PostConsoleV1HoldoutsData = {
  body: HoldoutCreateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/holdouts'
}

export type PostConsoleV1HoldoutsErrors = {
  /**
   * Name is already in use
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found Exception
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1HoldoutsError = PostConsoleV1HoldoutsErrors[keyof PostConsoleV1HoldoutsErrors]

export type PostConsoleV1HoldoutsResponses = {
  /**
   * Create holdout response
   */
  200: SingleDataResponse & {
    data?: HoldoutDto
  }
}

export type PostConsoleV1HoldoutsResponse = PostConsoleV1HoldoutsResponses[keyof PostConsoleV1HoldoutsResponses]

export type DeleteConsoleV1HoldoutsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}'
}

export type DeleteConsoleV1HoldoutsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Holdout not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1HoldoutsByIdError =
  DeleteConsoleV1HoldoutsByIdErrors[keyof DeleteConsoleV1HoldoutsByIdErrors]

export type DeleteConsoleV1HoldoutsByIdResponses = {
  /**
   * Delete holdout response
   */
  200: SingleDataResponse & {
    data?: HoldoutDto
  }
}

export type DeleteConsoleV1HoldoutsByIdResponse =
  DeleteConsoleV1HoldoutsByIdResponses[keyof DeleteConsoleV1HoldoutsByIdResponses]

export type GetConsoleV1HoldoutsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}'
}

export type GetConsoleV1HoldoutsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1HoldoutsByIdError = GetConsoleV1HoldoutsByIdErrors[keyof GetConsoleV1HoldoutsByIdErrors]

export type GetConsoleV1HoldoutsByIdResponses = {
  /**
   * Get holdout by id response
   */
  200: SingleDataResponse & {
    data?: HoldoutDto
  }
}

export type GetConsoleV1HoldoutsByIdResponse =
  GetConsoleV1HoldoutsByIdResponses[keyof GetConsoleV1HoldoutsByIdResponses]

export type PatchConsoleV1HoldoutsByIdData = {
  body: HoldoutPartialUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}'
}

export type PatchConsoleV1HoldoutsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Holdout not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1HoldoutsByIdError = PatchConsoleV1HoldoutsByIdErrors[keyof PatchConsoleV1HoldoutsByIdErrors]

export type PatchConsoleV1HoldoutsByIdResponses = {
  /**
   * Update holdout response
   */
  200: SingleDataResponse & {
    data?: HoldoutDto
  }
}

export type PatchConsoleV1HoldoutsByIdResponse =
  PatchConsoleV1HoldoutsByIdResponses[keyof PatchConsoleV1HoldoutsByIdResponses]

export type PostConsoleV1HoldoutsByIdData = {
  body: HoldoutFullUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}'
}

export type PostConsoleV1HoldoutsByIdErrors = {
  /**
   * Name is already in use
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1HoldoutsByIdError = PostConsoleV1HoldoutsByIdErrors[keyof PostConsoleV1HoldoutsByIdErrors]

export type PostConsoleV1HoldoutsByIdResponses = {
  /**
   * Update holdout response
   */
  200: SingleDataResponse & {
    data?: HoldoutDto
  }
}

export type PostConsoleV1HoldoutsByIdResponse =
  PostConsoleV1HoldoutsByIdResponses[keyof PostConsoleV1HoldoutsByIdResponses]

export type DeleteConsoleV1HoldoutsByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}/overrides'
}

export type DeleteConsoleV1HoldoutsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1HoldoutsByIdOverridesError =
  DeleteConsoleV1HoldoutsByIdOverridesErrors[keyof DeleteConsoleV1HoldoutsByIdOverridesErrors]

export type DeleteConsoleV1HoldoutsByIdOverridesResponses = {
  /**
   * Remove Holdout Overrides Success
   */
  200: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type DeleteConsoleV1HoldoutsByIdOverridesResponse =
  DeleteConsoleV1HoldoutsByIdOverridesResponses[keyof DeleteConsoleV1HoldoutsByIdOverridesResponses]

export type GetConsoleV1HoldoutsByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}/overrides'
}

export type GetConsoleV1HoldoutsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1HoldoutsByIdOverridesError =
  GetConsoleV1HoldoutsByIdOverridesErrors[keyof GetConsoleV1HoldoutsByIdOverridesErrors]

export type GetConsoleV1HoldoutsByIdOverridesResponses = {
  /**
   * Read Holdout Overrides Success
   */
  200: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type GetConsoleV1HoldoutsByIdOverridesResponse =
  GetConsoleV1HoldoutsByIdOverridesResponses[keyof GetConsoleV1HoldoutsByIdOverridesResponses]

export type PatchConsoleV1HoldoutsByIdOverridesData = {
  body: UpdateOverridesContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}/overrides'
}

export type PatchConsoleV1HoldoutsByIdOverridesResponses = {
  /**
   * Add Holdout Overrides Success
   */
  200: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type PatchConsoleV1HoldoutsByIdOverridesResponse =
  PatchConsoleV1HoldoutsByIdOverridesResponses[keyof PatchConsoleV1HoldoutsByIdOverridesResponses]

export type PostConsoleV1HoldoutsByIdOverridesData = {
  body: UpdateOverridesContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/holdouts/{id}/overrides'
}

export type PostConsoleV1HoldoutsByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1HoldoutsByIdOverridesError =
  PostConsoleV1HoldoutsByIdOverridesErrors[keyof PostConsoleV1HoldoutsByIdOverridesErrors]

export type PostConsoleV1HoldoutsByIdOverridesResponses = {
  /**
   * Update Holdout Overrides Success
   */
  200: SingleDataResponse & {
    data?: OverrideDto
  }
}

export type PostConsoleV1HoldoutsByIdOverridesResponse =
  PostConsoleV1HoldoutsByIdOverridesResponses[keyof PostConsoleV1HoldoutsByIdOverridesResponses]

export type GetConsoleV1HoldoutsByIdPulseResultsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Whether to apply CUPED. Allowed values are "true" or "false".
     */
    cuped?: string
    /**
     * Confidence interval (0-100)
     */
    confidence?: string
  }
  url: '/console/v1/holdouts/{id}/pulse_results'
}

export type GetConsoleV1HoldoutsByIdPulseResultsResponses = {
  /**
   * Get Pulse Results Success
   */
  200: SingleDataResponse & {
    data?: GatePulseResultsDto
  }
}

export type GetConsoleV1HoldoutsByIdPulseResultsResponse =
  GetConsoleV1HoldoutsByIdPulseResultsResponses[keyof GetConsoleV1HoldoutsByIdPulseResultsResponses]

export type DeleteConsoleV1IngestionData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
    dataset: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
    source_name?: string
  }
  url: '/console/v1/ingestion'
}

export type DeleteConsoleV1IngestionResponses = {
  /**
   * Delete Ingestion Success
   */
  200: SingleDataResponse & {
    data?: IngestionDto
  }
}

export type DeleteConsoleV1IngestionResponse =
  DeleteConsoleV1IngestionResponses[keyof DeleteConsoleV1IngestionResponses]

export type GetConsoleV1IngestionData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    type: 'redshift' | 'bigquery-v2' | 'snowflake-v2' | 'databricks' | 'azure-synapse' | 's3' | 'athena' | 'adls'
    dataset: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
    source_name?: string
  }
  url: '/console/v1/ingestion'
}

export type GetConsoleV1IngestionResponses = {
  /**
   * Read Ingestion Success
   */
  200: SingleDataResponse & {
    data?: IngestionDto
  }
}

export type GetConsoleV1IngestionResponse = GetConsoleV1IngestionResponses[keyof GetConsoleV1IngestionResponses]

export type PatchConsoleV1IngestionData = {
  body: IngestionUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/ingestion'
}

export type PatchConsoleV1IngestionResponses = {
  /**
   * Update Ingestion Success
   */
  200: SingleDataResponse & {
    data?: IngestionDto
  }
}

export type PatchConsoleV1IngestionResponse = PatchConsoleV1IngestionResponses[keyof PatchConsoleV1IngestionResponses]

export type PostConsoleV1IngestionData = {
  body: IngestionSourceCreateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/ingestion'
}

export type PostConsoleV1IngestionErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1IngestionError = PostConsoleV1IngestionErrors[keyof PostConsoleV1IngestionErrors]

export type PostConsoleV1IngestionResponses = {
  /**
   * Create Ingestion Success
   */
  200: SingleDataResponse & {
    data?: IngestionDto
  }
}

export type PostConsoleV1IngestionResponse = PostConsoleV1IngestionResponses[keyof PostConsoleV1IngestionResponses]

export type PostConsoleV1IngestionBackfillData = {
  body: IngestionBackfillContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/ingestion/backfill'
}

export type PostConsoleV1IngestionBackfillErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
}

export type PostConsoleV1IngestionBackfillError =
  PostConsoleV1IngestionBackfillErrors[keyof PostConsoleV1IngestionBackfillErrors]

export type PostConsoleV1IngestionBackfillResponses = {
  /**
   * Backfill Ingestion Success
   */
  200: SingleDataResponse & {
    data?: IngestionBackfillDataDto
  }
}

export type PostConsoleV1IngestionBackfillResponse =
  PostConsoleV1IngestionBackfillResponses[keyof PostConsoleV1IngestionBackfillResponses]

export type PostConsoleV1IngestionConnectionDatabricksData = {
  body: IngestionCreateDatabricksConnectionContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/ingestion/connection/databricks'
}

export type PostConsoleV1IngestionConnectionDatabricksResponses = {
  /**
   * Create Ingestion Databricks Success
   */
  200: SingleDataResponse & {
    data?: IngestionDto
  }
}

export type PostConsoleV1IngestionConnectionDatabricksResponse =
  PostConsoleV1IngestionConnectionDatabricksResponses[keyof PostConsoleV1IngestionConnectionDatabricksResponses]

export type GetConsoleV1IngestionEventsCountData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    source_name?: string
    event_name?: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    start_date: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    end_date: string
  }
  url: '/console/v1/ingestion/events/count'
}

export type GetConsoleV1IngestionEventsCountResponses = {
  /**
   * Get Ingestion Event Count Success
   */
  200: SingleDataResponse & {
    data?: IngestionEventCountResponseDto
  }
}

export type GetConsoleV1IngestionEventsCountResponse =
  GetConsoleV1IngestionEventsCountResponses[keyof GetConsoleV1IngestionEventsCountResponses]

export type GetConsoleV1IngestionEventsDeltaData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    source_name?: string
    event_name?: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    start_date: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    end_date: string
  }
  url: '/console/v1/ingestion/events/delta'
}

export type GetConsoleV1IngestionEventsDeltaResponses = {
  /**
   * Get Ingestion Event Delta Ledger Success
   */
  200: SingleDataResponse & {
    data?: IngestionEventDeltaResponseDto
  }
}

export type GetConsoleV1IngestionEventsDeltaResponse =
  GetConsoleV1IngestionEventsDeltaResponses[keyof GetConsoleV1IngestionEventsDeltaResponses]

export type GetConsoleV1IngestionRunsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    page?: string | number
  }
  url: '/console/v1/ingestion/runs'
}

export type GetConsoleV1IngestionRunsResponses = {
  /**
   * List Ingestion Runs Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<IngestionRunDataContractDto>
  }
}

export type GetConsoleV1IngestionRunsResponse =
  GetConsoleV1IngestionRunsResponses[keyof GetConsoleV1IngestionRunsResponses]

export type GetConsoleV1IngestionRunsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/ingestion/runs/{id}'
}

export type GetConsoleV1IngestionRunsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1IngestionRunsByIdError =
  GetConsoleV1IngestionRunsByIdErrors[keyof GetConsoleV1IngestionRunsByIdErrors]

export type GetConsoleV1IngestionRunsByIdResponses = {
  /**
   * Read Ingestion Run Success
   */
  200: SingleDataResponse & {
    data?: IngestionRunDataContractDto
  }
}

export type GetConsoleV1IngestionRunsByIdResponse =
  GetConsoleV1IngestionRunsByIdResponses[keyof GetConsoleV1IngestionRunsByIdResponses]

export type GetConsoleV1IngestionScheduleData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    dataset: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
  }
  url: '/console/v1/ingestion/schedule'
}

export type GetConsoleV1IngestionScheduleResponses = {
  /**
   * Read Ingestion Schedule Success
   */
  200: SingleDataResponse & {
    data?: IngestionScheduleDto
  }
}

export type GetConsoleV1IngestionScheduleResponse =
  GetConsoleV1IngestionScheduleResponses[keyof GetConsoleV1IngestionScheduleResponses]

export type PostConsoleV1IngestionScheduleData = {
  body: IngestionScheduleUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/ingestion/schedule'
}

export type PostConsoleV1IngestionScheduleResponses = {
  /**
   * Update Ingestion Schedule Success
   */
  200: SingleDataResponse & {
    data?: IngestionScheduleDto
  }
}

export type PostConsoleV1IngestionScheduleResponse =
  PostConsoleV1IngestionScheduleResponses[keyof PostConsoleV1IngestionScheduleResponses]

export type GetConsoleV1IngestionStatusData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    startDate: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    endDate: string
    source?: string
    dataset?: 'Events' | 'Metrics' | 'export_exposures' | 'entity_properties'
    status?:
      | 'IMPORT_SUCCESSFUL'
      | 'LOADED_EMPTY_DATA'
      | 'IMPORT_SCHEDULED'
      | 'IMPORT_RESCHEDULED'
      | 'IMPORT_STARTED'
      | 'BACKFILL_REQUESTED'
      | 'CONNECTION_CONFIG_ERROR'
      | 'SSH_ERROR'
      | 'QUERY_CONSTRUCTION_ERROR'
      | 'INTERNAL_WRITE_ERROR_METRICS'
      | 'INTERNAL_WRITE_ERROR_EVENTS'
      | 'INTERNAL_WRITE_ERROR_EXPOSURES'
      | 'QUERY_ERROR'
      | 'SETUP_ERROR'
      | 'AUTHENTICATION_ERROR'
      | 'CONNECTION_ERROR'
      | 'BULK_LOAD_ERROR'
      | 'BULK_LOAD_SUCCESSFUL'
      | '%Other'
    statuses?: Array<
      | 'IMPORT_SUCCESSFUL'
      | 'LOADED_EMPTY_DATA'
      | 'IMPORT_SCHEDULED'
      | 'IMPORT_RESCHEDULED'
      | 'IMPORT_STARTED'
      | 'BACKFILL_REQUESTED'
      | 'CONNECTION_CONFIG_ERROR'
      | 'SSH_ERROR'
      | 'QUERY_CONSTRUCTION_ERROR'
      | 'INTERNAL_WRITE_ERROR_METRICS'
      | 'INTERNAL_WRITE_ERROR_EVENTS'
      | 'INTERNAL_WRITE_ERROR_EXPOSURES'
      | 'QUERY_ERROR'
      | 'SETUP_ERROR'
      | 'AUTHENTICATION_ERROR'
      | 'CONNECTION_ERROR'
      | 'BULK_LOAD_ERROR'
      | 'BULK_LOAD_SUCCESSFUL'
      | '%Other'
    >
  }
  url: '/console/v1/ingestion/status'
}

export type GetConsoleV1IngestionStatusErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1IngestionStatusError =
  GetConsoleV1IngestionStatusErrors[keyof GetConsoleV1IngestionStatusErrors]

export type GetConsoleV1IngestionStatusResponses = {
  /**
   * List Ingestions Status Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<IngestionStatusDto>
  }
}

export type GetConsoleV1IngestionStatusResponse =
  GetConsoleV1IngestionStatusResponses[keyof GetConsoleV1IngestionStatusResponses]

export type GetConsoleV1KeysData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    primaryTargetApp?: string
    environment?: string
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/keys'
}

export type GetConsoleV1KeysErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
}

export type GetConsoleV1KeysError = GetConsoleV1KeysErrors[keyof GetConsoleV1KeysErrors]

export type GetConsoleV1KeysResponses = {
  /**
   * Keys listed successfully
   */
  200: PaginationResponseWithMessage & {
    data?: Array<KeyDto>
  }
}

export type GetConsoleV1KeysResponse = GetConsoleV1KeysResponses[keyof GetConsoleV1KeysResponses]

export type PostConsoleV1KeysData = {
  body: KeyCreateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/keys'
}

export type PostConsoleV1KeysErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
}

export type PostConsoleV1KeysError = PostConsoleV1KeysErrors[keyof PostConsoleV1KeysErrors]

export type PostConsoleV1KeysResponses = {
  /**
   * Key created successfully
   */
  200: SingleDataResponse & {
    data?: KeyDto
  }
}

export type PostConsoleV1KeysResponse = PostConsoleV1KeysResponses[keyof PostConsoleV1KeysResponses]

export type DeleteConsoleV1KeysByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/keys/{id}'
}

export type DeleteConsoleV1KeysByIdErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Key not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1KeysByIdError = DeleteConsoleV1KeysByIdErrors[keyof DeleteConsoleV1KeysByIdErrors]

export type DeleteConsoleV1KeysByIdResponses = {
  /**
   * Key deleted successfully
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1KeysByIdResponse = DeleteConsoleV1KeysByIdResponses[keyof DeleteConsoleV1KeysByIdResponses]

export type GetConsoleV1KeysByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/keys/{id}'
}

export type GetConsoleV1KeysByIdErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Key not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1KeysByIdError = GetConsoleV1KeysByIdErrors[keyof GetConsoleV1KeysByIdErrors]

export type GetConsoleV1KeysByIdResponses = {
  /**
   * Key read successfully
   */
  200: SingleDataResponse & {
    data?: KeyDto
  }
}

export type GetConsoleV1KeysByIdResponse = GetConsoleV1KeysByIdResponses[keyof GetConsoleV1KeysByIdResponses]

export type PatchConsoleV1KeysByIdData = {
  body: KeyUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/keys/{id}'
}

export type PatchConsoleV1KeysByIdErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Key not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1KeysByIdError = PatchConsoleV1KeysByIdErrors[keyof PatchConsoleV1KeysByIdErrors]

export type PatchConsoleV1KeysByIdResponses = {
  /**
   * Key updated successfully
   */
  200: SingleDataResponse & {
    data?: KeyDto
  }
}

export type PatchConsoleV1KeysByIdResponse = PatchConsoleV1KeysByIdResponses[keyof PatchConsoleV1KeysByIdResponses]

export type PatchConsoleV1KeysByIdDeactivateData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/keys/{id}/deactivate'
}

export type PatchConsoleV1KeysByIdDeactivateErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Key not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1KeysByIdDeactivateError =
  PatchConsoleV1KeysByIdDeactivateErrors[keyof PatchConsoleV1KeysByIdDeactivateErrors]

export type PatchConsoleV1KeysByIdDeactivateResponses = {
  /**
   * Key deactivated successfully
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1KeysByIdDeactivateResponse =
  PatchConsoleV1KeysByIdDeactivateResponses[keyof PatchConsoleV1KeysByIdDeactivateResponses]

export type PatchConsoleV1KeysByIdRotateData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/keys/{id}/rotate'
}

export type PatchConsoleV1KeysByIdRotateErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Key not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1KeysByIdRotateError =
  PatchConsoleV1KeysByIdRotateErrors[keyof PatchConsoleV1KeysByIdRotateErrors]

export type PatchConsoleV1KeysByIdRotateResponses = {
  /**
   * Key rotated successfully
   */
  200: SingleDataResponse & {
    data?: KeyDto
  }
}

export type PatchConsoleV1KeysByIdRotateResponse =
  PatchConsoleV1KeysByIdRotateResponses[keyof PatchConsoleV1KeysByIdRotateResponses]

export type GetConsoleV1LayersData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/layers'
}

export type GetConsoleV1LayersErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1LayersError = GetConsoleV1LayersErrors[keyof GetConsoleV1LayersErrors]

export type GetConsoleV1LayersResponses = {
  /**
   * Get Layers response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<LayerContractDto>
  }
}

export type GetConsoleV1LayersResponse = GetConsoleV1LayersResponses[keyof GetConsoleV1LayersResponses]

export type PostConsoleV1LayersData = {
  body: LayerCreateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/layers'
}

export type PostConsoleV1LayersErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1LayersError = PostConsoleV1LayersErrors[keyof PostConsoleV1LayersErrors]

export type PostConsoleV1LayersResponses = {
  /**
   * Create Layer Response
   */
  201: SingleDataResponse & {
    data?: LayerContractDto
  }
}

export type PostConsoleV1LayersResponse = PostConsoleV1LayersResponses[keyof PostConsoleV1LayersResponses]

export type DeleteConsoleV1LayersByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}'
}

export type DeleteConsoleV1LayersByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1LayersByIdError = DeleteConsoleV1LayersByIdErrors[keyof DeleteConsoleV1LayersByIdErrors]

export type DeleteConsoleV1LayersByIdResponses = {
  /**
   * Delete layer repsonse
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1LayersByIdResponse =
  DeleteConsoleV1LayersByIdResponses[keyof DeleteConsoleV1LayersByIdResponses]

export type GetConsoleV1LayersByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}'
}

export type GetConsoleV1LayersByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1LayersByIdError = GetConsoleV1LayersByIdErrors[keyof GetConsoleV1LayersByIdErrors]

export type GetConsoleV1LayersByIdResponses = {
  /**
   * Get one layer response
   */
  200: SingleDataResponse & {
    data?: LayerContractDto
  }
}

export type GetConsoleV1LayersByIdResponse = GetConsoleV1LayersByIdResponses[keyof GetConsoleV1LayersByIdResponses]

export type PatchConsoleV1LayersByIdData = {
  body: LayerPartialUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}'
}

export type PatchConsoleV1LayersByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PatchConsoleV1LayersByIdError = PatchConsoleV1LayersByIdErrors[keyof PatchConsoleV1LayersByIdErrors]

export type PatchConsoleV1LayersByIdResponses = {
  /**
   * Partial update layer response
   */
  200: SingleDataResponse & {
    data?: LayerContractDto
  }
}

export type PatchConsoleV1LayersByIdResponse =
  PatchConsoleV1LayersByIdResponses[keyof PatchConsoleV1LayersByIdResponses]

export type PostConsoleV1LayersByIdData = {
  body: LayerFullUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}'
}

export type PostConsoleV1LayersByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1LayersByIdError = PostConsoleV1LayersByIdErrors[keyof PostConsoleV1LayersByIdErrors]

export type PostConsoleV1LayersByIdResponses = {
  /**
   * Update layer response
   */
  200: SingleDataResponse & {
    data?: LayerContractDto
  }
}

export type PostConsoleV1LayersByIdResponse = PostConsoleV1LayersByIdResponses[keyof PostConsoleV1LayersByIdResponses]

export type GetConsoleV1LayersByIdExperimentsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/layers/{id}/experiments'
}

export type GetConsoleV1LayersByIdExperimentsResponses = {
  /**
   * List Experiment related to Layer Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalExperimentDto>
  }
}

export type GetConsoleV1LayersByIdExperimentsResponse =
  GetConsoleV1LayersByIdExperimentsResponses[keyof GetConsoleV1LayersByIdExperimentsResponses]

export type DeleteConsoleV1LayersByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}/overrides'
}

export type DeleteConsoleV1LayersByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Layer not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1LayersByIdOverridesError =
  DeleteConsoleV1LayersByIdOverridesErrors[keyof DeleteConsoleV1LayersByIdOverridesErrors]

export type DeleteConsoleV1LayersByIdOverridesResponses = {
  /**
   * Delete Update Layer Overrides Success
   */
  200: SingleDataResponse & {
    data?: LayerOverridesDto
  }
}

export type DeleteConsoleV1LayersByIdOverridesResponse =
  DeleteConsoleV1LayersByIdOverridesResponses[keyof DeleteConsoleV1LayersByIdOverridesResponses]

export type GetConsoleV1LayersByIdOverridesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}/overrides'
}

export type GetConsoleV1LayersByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Layer not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1LayersByIdOverridesError =
  GetConsoleV1LayersByIdOverridesErrors[keyof GetConsoleV1LayersByIdOverridesErrors]

export type GetConsoleV1LayersByIdOverridesResponses = {
  /**
   * Get Layer Overrides Success
   */
  200: SingleDataResponse & {
    data?: LayerOverridesDto
  }
}

export type GetConsoleV1LayersByIdOverridesResponse =
  GetConsoleV1LayersByIdOverridesResponses[keyof GetConsoleV1LayersByIdOverridesResponses]

export type PatchConsoleV1LayersByIdOverridesData = {
  body: LayerOverridesPatchDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}/overrides'
}

export type PatchConsoleV1LayersByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Layer not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1LayersByIdOverridesError =
  PatchConsoleV1LayersByIdOverridesErrors[keyof PatchConsoleV1LayersByIdOverridesErrors]

export type PatchConsoleV1LayersByIdOverridesResponses = {
  /**
   * Add Layer Overrides Success
   */
  200: SingleDataResponse & {
    data?: LayerOverridesDto
  }
}

export type PatchConsoleV1LayersByIdOverridesResponse =
  PatchConsoleV1LayersByIdOverridesResponses[keyof PatchConsoleV1LayersByIdOverridesResponses]

export type PostConsoleV1LayersByIdOverridesData = {
  body: LayerOverridesDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/layers/{id}/overrides'
}

export type PostConsoleV1LayersByIdOverridesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Layer not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1LayersByIdOverridesError =
  PostConsoleV1LayersByIdOverridesErrors[keyof PostConsoleV1LayersByIdOverridesErrors]

export type PostConsoleV1LayersByIdOverridesResponses = {
  /**
   * Update Layer Overrides Success
   */
  200: SingleDataResponse & {
    data?: LayerOverridesDto
  }
}

export type PostConsoleV1LayersByIdOverridesResponse =
  PostConsoleV1LayersByIdOverridesResponses[keyof PostConsoleV1LayersByIdOverridesResponses]

export type GetConsoleV1MetricsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    /**
     * The unique identifier of the metric with format <metric_id>::<type>
     */
    id: string
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    date: string
  }
  url: '/console/v1/metrics'
}

export type GetConsoleV1MetricsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsError = GetConsoleV1MetricsErrors[keyof GetConsoleV1MetricsErrors]

export type GetConsoleV1MetricsResponses = {
  /**
   * Get metric data on given date response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<MetricValuesDto>
  }
}

export type GetConsoleV1MetricsResponse = GetConsoleV1MetricsResponses[keyof GetConsoleV1MetricsResponses]

export type PostConsoleV1MetricsData = {
  body: MetricCreationContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/metrics'
}

export type PostConsoleV1MetricsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1MetricsError = PostConsoleV1MetricsErrors[keyof PostConsoleV1MetricsErrors]

export type PostConsoleV1MetricsResponses = {
  /**
   * Create metric response
   */
  201: SingleDataResponse & {
    data?: ExternalMetricDefinitionContractDto
  }
}

export type PostConsoleV1MetricsResponse = PostConsoleV1MetricsResponses[keyof PostConsoleV1MetricsResponses]

export type DeleteConsoleV1MetricsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}'
}

export type DeleteConsoleV1MetricsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1MetricsByIdError = DeleteConsoleV1MetricsByIdErrors[keyof DeleteConsoleV1MetricsByIdErrors]

export type DeleteConsoleV1MetricsByIdResponses = {
  /**
   * Delete metric response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1MetricsByIdResponse =
  DeleteConsoleV1MetricsByIdResponses[keyof DeleteConsoleV1MetricsByIdResponses]

export type GetConsoleV1MetricsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}'
}

export type GetConsoleV1MetricsByIdErrors = {
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1MetricsByIdError = GetConsoleV1MetricsByIdErrors[keyof GetConsoleV1MetricsByIdErrors]

export type GetConsoleV1MetricsByIdResponses = {
  /**
   * Get Metric Definition response
   */
  200: SingleDataResponse & {
    data?: ExternalMetricDefinitionContractDto
  }
}

export type GetConsoleV1MetricsByIdResponse = GetConsoleV1MetricsByIdResponses[keyof GetConsoleV1MetricsByIdResponses]

export type PostConsoleV1MetricsByIdData = {
  body: MetricsUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}'
}

export type PostConsoleV1MetricsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1MetricsByIdError = PostConsoleV1MetricsByIdErrors[keyof PostConsoleV1MetricsByIdErrors]

export type PostConsoleV1MetricsByIdResponses = {
  /**
   * Update metric response
   */
  200: SingleDataResponse & {
    data?: ExternalMetricDefinitionContractDto
  }
}

export type PostConsoleV1MetricsByIdResponse =
  PostConsoleV1MetricsByIdResponses[keyof PostConsoleV1MetricsByIdResponses]

export type PutConsoleV1MetricsByIdCancelArchiveData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}/cancel_archive'
}

export type PutConsoleV1MetricsByIdCancelArchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1MetricsByIdCancelArchiveError =
  PutConsoleV1MetricsByIdCancelArchiveErrors[keyof PutConsoleV1MetricsByIdCancelArchiveErrors]

export type PutConsoleV1MetricsByIdCancelArchiveResponses = {
  /**
   * Cancel archive metric response
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1MetricsByIdCancelArchiveResponse =
  PutConsoleV1MetricsByIdCancelArchiveResponses[keyof PutConsoleV1MetricsByIdCancelArchiveResponses]

export type GetConsoleV1MetricsByIdExperimentsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Which layer to place the experiment into.
     */
    layerID?: string
    /**
     * The idType the experiment will be performed on
     */
    idType?: string
    /**
     * The team ID associated with the experiment, Enterprise only.
     */
    teamID?: string | null
    /**
     * The current status of the experiment
     */
    status?:
      | 'active'
      | 'setup'
      | 'decision_made'
      | 'abandoned'
      | 'archived'
      | 'experiment_stopped'
      | 'assignment_stopped'
      | Array<
          'active' | 'setup' | 'decision_made' | 'abandoned' | 'archived' | 'experiment_stopped' | 'assignment_stopped'
        >
    targetAppID?: string
    /**
     * Name of the creator.
     */
    creatorName?: string | null
    /**
     * ID of the user who created the entity.
     */
    creatorID?: string | null
    /**
     * Filter by tags
     */
    tags?: string | Array<string>
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/metrics/{id}/experiments'
}

export type GetConsoleV1MetricsByIdExperimentsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsByIdExperimentsError =
  GetConsoleV1MetricsByIdExperimentsErrors[keyof GetConsoleV1MetricsByIdExperimentsErrors]

export type GetConsoleV1MetricsByIdExperimentsResponses = {
  /**
   * List experinments using metric response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalExperimentDto>
  }
}

export type GetConsoleV1MetricsByIdExperimentsResponse =
  GetConsoleV1MetricsByIdExperimentsResponses[keyof GetConsoleV1MetricsByIdExperimentsResponses]

export type PostConsoleV1MetricsByIdReloadData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: {
    /**
     * Incremental reload of the metric
     */
    incremental?: 'true' | 'false'
  }
  url: '/console/v1/metrics/{id}/reload'
}

export type PostConsoleV1MetricsByIdReloadErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1MetricsByIdReloadError =
  PostConsoleV1MetricsByIdReloadErrors[keyof PostConsoleV1MetricsByIdReloadErrors]

export type PostConsoleV1MetricsByIdReloadResponses = {
  /**
   * Reload metric data response
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1MetricsByIdReloadResponse =
  PostConsoleV1MetricsByIdReloadResponses[keyof PostConsoleV1MetricsByIdReloadResponses]

export type PutConsoleV1MetricsByIdScheduleArchiveData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}/schedule_archive'
}

export type PutConsoleV1MetricsByIdScheduleArchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1MetricsByIdScheduleArchiveError =
  PutConsoleV1MetricsByIdScheduleArchiveErrors[keyof PutConsoleV1MetricsByIdScheduleArchiveErrors]

export type PutConsoleV1MetricsByIdScheduleArchiveResponses = {
  /**
   * Schedule a metric archive
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1MetricsByIdScheduleArchiveResponse =
  PutConsoleV1MetricsByIdScheduleArchiveResponses[keyof PutConsoleV1MetricsByIdScheduleArchiveResponses]

export type PutConsoleV1MetricsByIdUnarchiveData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/metrics/{id}/unarchive'
}

export type PutConsoleV1MetricsByIdUnarchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1MetricsByIdUnarchiveError =
  PutConsoleV1MetricsByIdUnarchiveErrors[keyof PutConsoleV1MetricsByIdUnarchiveErrors]

export type PutConsoleV1MetricsByIdUnarchiveResponses = {
  /**
   * Unarchive metric response
   */
  200: {
    message?: string
  }
}

export type PutConsoleV1MetricsByIdUnarchiveResponse =
  PutConsoleV1MetricsByIdUnarchiveResponses[keyof PutConsoleV1MetricsByIdUnarchiveResponses]

export type GetConsoleV1MetricsListData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Should hidden metrics be returned: Allowed values are "true" or "false".
     */
    showHiddenMetrics?: 'true' | 'false'
    /**
     * Filter metrics based on a given tagID, found on /tags endpoint. Can be a single string or an array of strings.
     */
    tags?: string | Array<string>
    /**
     * Additional filters for metrics. Can be a string or an object with tags filter.
     */
    filters?: string
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/metrics/list'
}

export type GetConsoleV1MetricsListErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsListError = GetConsoleV1MetricsListErrors[keyof GetConsoleV1MetricsListErrors]

export type GetConsoleV1MetricsListResponses = {
  /**
   * List all metrics in the project response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalMetricDefinitionContractDto>
  }
}

export type GetConsoleV1MetricsListResponse = GetConsoleV1MetricsListResponses[keyof GetConsoleV1MetricsListResponses]

export type PostConsoleV1MetricsMetricSourceData = {
  body: MetricSourceCreationContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/metrics/metric_source'
}

export type PostConsoleV1MetricsMetricSourceErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1MetricsMetricSourceError =
  PostConsoleV1MetricsMetricSourceErrors[keyof PostConsoleV1MetricsMetricSourceErrors]

export type PostConsoleV1MetricsMetricSourceResponses = {
  /**
   * Create metric source response
   */
  201: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type PostConsoleV1MetricsMetricSourceResponse =
  PostConsoleV1MetricsMetricSourceResponses[keyof PostConsoleV1MetricsMetricSourceResponses]

export type DeleteConsoleV1MetricsMetricSourceByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/metrics/metric_source/{name}'
}

export type DeleteConsoleV1MetricsMetricSourceByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type DeleteConsoleV1MetricsMetricSourceByNameError =
  DeleteConsoleV1MetricsMetricSourceByNameErrors[keyof DeleteConsoleV1MetricsMetricSourceByNameErrors]

export type DeleteConsoleV1MetricsMetricSourceByNameResponses = {
  /**
   * Delete metric source response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1MetricsMetricSourceByNameResponse =
  DeleteConsoleV1MetricsMetricSourceByNameResponses[keyof DeleteConsoleV1MetricsMetricSourceByNameResponses]

export type GetConsoleV1MetricsMetricSourceByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/metrics/metric_source/{name}'
}

export type GetConsoleV1MetricsMetricSourceByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsMetricSourceByNameError =
  GetConsoleV1MetricsMetricSourceByNameErrors[keyof GetConsoleV1MetricsMetricSourceByNameErrors]

export type GetConsoleV1MetricsMetricSourceByNameResponses = {
  /**
   * Read metric source response
   */
  200: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type GetConsoleV1MetricsMetricSourceByNameResponse =
  GetConsoleV1MetricsMetricSourceByNameResponses[keyof GetConsoleV1MetricsMetricSourceByNameResponses]

export type PostConsoleV1MetricsMetricSourceByNameData = {
  body: MetricSourceUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: never
  url: '/console/v1/metrics/metric_source/{name}'
}

export type PostConsoleV1MetricsMetricSourceByNameErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1MetricsMetricSourceByNameError =
  PostConsoleV1MetricsMetricSourceByNameErrors[keyof PostConsoleV1MetricsMetricSourceByNameErrors]

export type PostConsoleV1MetricsMetricSourceByNameResponses = {
  /**
   * Update metric source response
   */
  200: SingleDataResponse & {
    data?: MetricSourceContractDto
  }
}

export type PostConsoleV1MetricsMetricSourceByNameResponse =
  PostConsoleV1MetricsMetricSourceByNameResponses[keyof PostConsoleV1MetricsMetricSourceByNameResponses]

export type GetConsoleV1MetricsMetricSourceByNameMetricsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * name
     */
    name: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/metrics/metric_source/{name}/metrics'
}

export type GetConsoleV1MetricsMetricSourceByNameMetricsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsMetricSourceByNameMetricsError =
  GetConsoleV1MetricsMetricSourceByNameMetricsErrors[keyof GetConsoleV1MetricsMetricSourceByNameMetricsErrors]

export type GetConsoleV1MetricsMetricSourceByNameMetricsResponses = {
  /**
   * Read metric source metrics response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ExternalMetricDefinitionContractDto>
  }
}

export type GetConsoleV1MetricsMetricSourceByNameMetricsResponse =
  GetConsoleV1MetricsMetricSourceByNameMetricsResponses[keyof GetConsoleV1MetricsMetricSourceByNameMetricsResponses]

export type GetConsoleV1MetricsMetricSourceListData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/metrics/metric_source/list'
}

export type GetConsoleV1MetricsMetricSourceListErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsMetricSourceListError =
  GetConsoleV1MetricsMetricSourceListErrors[keyof GetConsoleV1MetricsMetricSourceListErrors]

export type GetConsoleV1MetricsMetricSourceListResponses = {
  /**
   * List metric source response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<MetricSourceContractDto>
  }
}

export type GetConsoleV1MetricsMetricSourceListResponse =
  GetConsoleV1MetricsMetricSourceListResponses[keyof GetConsoleV1MetricsMetricSourceListResponses]

export type GetConsoleV1MetricsValuesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    /**
     * Expected valid date in the form of YYYY-MM-DD
     */
    date: string
    metricName?: string
    metricType?: string
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/metrics/values'
}

export type GetConsoleV1MetricsValuesErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1MetricsValuesError = GetConsoleV1MetricsValuesErrors[keyof GetConsoleV1MetricsValuesErrors]

export type GetConsoleV1MetricsValuesResponses = {
  /**
   * List All Metric Values Response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<MetricValueDto>
  }
}

export type GetConsoleV1MetricsValuesResponse =
  GetConsoleV1MetricsValuesResponses[keyof GetConsoleV1MetricsValuesResponses]

export type GetConsoleV1ParamStoresData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/param_stores'
}

export type GetConsoleV1ParamStoresResponses = {
  /**
   * List param stores
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ParamStoreDto>
  }
}

export type GetConsoleV1ParamStoresResponse = GetConsoleV1ParamStoresResponses[keyof GetConsoleV1ParamStoresResponses]

export type PostConsoleV1ParamStoresData = {
  body: ParamStoreCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/param_stores'
}

export type PostConsoleV1ParamStoresResponses = {
  /**
   * Create param store
   */
  200: SingleDataResponse & {
    data?: ParamStoreDto
  }
}

export type PostConsoleV1ParamStoresResponse =
  PostConsoleV1ParamStoresResponses[keyof PostConsoleV1ParamStoresResponses]

export type GetConsoleV1ParamStoresByNameData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    name: string
  }
  query?: never
  url: '/console/v1/param_stores/{name}'
}

export type GetConsoleV1ParamStoresByNameResponses = {
  /**
   * Get param store
   */
  200: SingleDataResponse & {
    data?: ParamStoreDto
  }
}

export type GetConsoleV1ParamStoresByNameResponse =
  GetConsoleV1ParamStoresByNameResponses[keyof GetConsoleV1ParamStoresByNameResponses]

export type PostConsoleV1ParamStoresByNameData = {
  body: ParamStoreUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    name: string
  }
  query?: never
  url: '/console/v1/param_stores/{name}'
}

export type PostConsoleV1ParamStoresByNameResponses = {
  /**
   * Update param store
   */
  200: SingleDataResponse & {
    data?: ParamStoreDto
  }
}

export type PostConsoleV1ParamStoresByNameResponse =
  PostConsoleV1ParamStoresByNameResponses[keyof PostConsoleV1ParamStoresByNameResponses]

export type GetConsoleV1ProjectData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/project'
}

export type GetConsoleV1ProjectResponses = {
  /**
   * Get Project Info
   */
  200: SingleDataResponse & {
    data?: ProjectDto
  }
}

export type GetConsoleV1ProjectResponse = GetConsoleV1ProjectResponses[keyof GetConsoleV1ProjectResponses]

export type GetConsoleV1ProjectUsageBillingReportData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    /**
     * Unix timestamp in ms
     */
    start?: number
    /**
     * Unix timestamp in ms
     */
    end: number
  }
  url: '/console/v1/project/usage_billing/report'
}

export type GetConsoleV1ProjectUsageBillingReportErrors = {
  /**
   * Data is not available
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ProjectUsageBillingReportError =
  GetConsoleV1ProjectUsageBillingReportErrors[keyof GetConsoleV1ProjectUsageBillingReportErrors]

export type GetConsoleV1ProjectUsageBillingReportResponses = {
  /**
   * Report URL generated successfully
   */
  200: Blob | File
}

export type GetConsoleV1ProjectUsageBillingReportResponse =
  GetConsoleV1ProjectUsageBillingReportResponses[keyof GetConsoleV1ProjectUsageBillingReportResponses]

export type GetConsoleV1ReleasePipelineTriggersData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Filter by Release Pipeline ID
     */
    releasePipelineID?: string
    /**
     * Filter by Gate ID
     */
    gateID?: string
    /**
     * Filter by Dynamic Config ID
     */
    dynamicConfigID?: string
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/release_pipeline_triggers'
}

export type GetConsoleV1ReleasePipelineTriggersResponses = {
  /**
   * List pipeline triggers success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ReleasePipelineTriggerResponseDto>
  }
}

export type GetConsoleV1ReleasePipelineTriggersResponse =
  GetConsoleV1ReleasePipelineTriggersResponses[keyof GetConsoleV1ReleasePipelineTriggersResponses]

export type GetConsoleV1ReleasePipelineTriggersByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}'
}

export type GetConsoleV1ReleasePipelineTriggersByIdResponses = {
  /**
   * Get pipeline trigger success
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type GetConsoleV1ReleasePipelineTriggersByIdResponse =
  GetConsoleV1ReleasePipelineTriggersByIdResponses[keyof GetConsoleV1ReleasePipelineTriggersByIdResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdAbortData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/abort'
}

export type PutConsoleV1ReleasePipelineTriggersByIdAbortResponses = {
  /**
   * Aborted pipeline trigger successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdAbortResponse =
  PutConsoleV1ReleasePipelineTriggersByIdAbortResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdAbortResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdApproveData = {
  body: ReleasePipelineTriggerActionBodyDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/approve'
}

export type PutConsoleV1ReleasePipelineTriggersByIdApproveResponses = {
  /**
   * Approved pipeline trigger phase successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdApproveResponse =
  PutConsoleV1ReleasePipelineTriggersByIdApproveResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdApproveResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdPauseData = {
  body: ReleasePipelineTriggerActionBodyDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/pause'
}

export type PutConsoleV1ReleasePipelineTriggersByIdPauseResponses = {
  /**
   * Paused pipeline trigger successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdPauseResponse =
  PutConsoleV1ReleasePipelineTriggersByIdPauseResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdPauseResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdRolloutData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/rollout'
}

export type PutConsoleV1ReleasePipelineTriggersByIdRolloutResponses = {
  /**
   * Fully rolled out pipeline trigger successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdRolloutResponse =
  PutConsoleV1ReleasePipelineTriggersByIdRolloutResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdRolloutResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdSkipData = {
  body: ReleasePipelineTriggerActionBodyDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/skip'
}

export type PutConsoleV1ReleasePipelineTriggersByIdSkipResponses = {
  /**
   * Skipped pipeline trigger phase successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdSkipResponse =
  PutConsoleV1ReleasePipelineTriggersByIdSkipResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdSkipResponses]

export type PutConsoleV1ReleasePipelineTriggersByIdUnpauseData = {
  body: ReleasePipelineTriggerActionBodyDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipeline_triggers/{id}/unpause'
}

export type PutConsoleV1ReleasePipelineTriggersByIdUnpauseResponses = {
  /**
   * Unpaused pipeline trigger successfully
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineTriggerResponseDto
  }
}

export type PutConsoleV1ReleasePipelineTriggersByIdUnpauseResponse =
  PutConsoleV1ReleasePipelineTriggersByIdUnpauseResponses[keyof PutConsoleV1ReleasePipelineTriggersByIdUnpauseResponses]

export type GetConsoleV1ReleasePipelinesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/release_pipelines'
}

export type GetConsoleV1ReleasePipelinesResponses = {
  /**
   * List pipelines
   */
  200: PaginationResponseWithMessage & {
    data?: Array<ReleasePipelineDto>
  }
}

export type GetConsoleV1ReleasePipelinesResponse =
  GetConsoleV1ReleasePipelinesResponses[keyof GetConsoleV1ReleasePipelinesResponses]

export type PostConsoleV1ReleasePipelinesData = {
  body: ReleasePipelineCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/release_pipelines'
}

export type PostConsoleV1ReleasePipelinesResponses = {
  /**
   * Create pipeline
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineDto
  }
}

export type PostConsoleV1ReleasePipelinesResponse =
  PostConsoleV1ReleasePipelinesResponses[keyof PostConsoleV1ReleasePipelinesResponses]

export type DeleteConsoleV1ReleasePipelinesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipelines/{id}'
}

export type DeleteConsoleV1ReleasePipelinesByIdResponses = {
  /**
   * Delete pipeline
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1ReleasePipelinesByIdResponse =
  DeleteConsoleV1ReleasePipelinesByIdResponses[keyof DeleteConsoleV1ReleasePipelinesByIdResponses]

export type GetConsoleV1ReleasePipelinesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipelines/{id}'
}

export type GetConsoleV1ReleasePipelinesByIdResponses = {
  /**
   * Get pipeline
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineDto
  }
}

export type GetConsoleV1ReleasePipelinesByIdResponse =
  GetConsoleV1ReleasePipelinesByIdResponses[keyof GetConsoleV1ReleasePipelinesByIdResponses]

export type PostConsoleV1ReleasePipelinesByIdData = {
  body: ReleasePipelineUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/release_pipelines/{id}'
}

export type PostConsoleV1ReleasePipelinesByIdResponses = {
  /**
   * Update pipeline
   */
  200: SingleDataResponse & {
    data?: ReleasePipelineDto
  }
}

export type PostConsoleV1ReleasePipelinesByIdResponse =
  PostConsoleV1ReleasePipelinesByIdResponses[keyof PostConsoleV1ReleasePipelinesByIdResponses]

export type GetConsoleV1ReportsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query: {
    /**
     * report type
     */
    type: 'first_exposures' | 'pulse_daily' | 'topline_impact_daily'
    /**
     * date for the report
     */
    date: string
  }
  url: '/console/v1/reports'
}

export type GetConsoleV1ReportsErrors = {
  /**
   * Data is not available
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1ReportsError = GetConsoleV1ReportsErrors[keyof GetConsoleV1ReportsErrors]

export type GetConsoleV1ReportsResponses = {
  /**
   * Get Reports
   */
  200: SingleDataResponse & {
    data?: ReportDto
  }
}

export type GetConsoleV1ReportsResponse = GetConsoleV1ReportsResponses[keyof GetConsoleV1ReportsResponses]

export type GetConsoleV1RolesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/roles'
}

export type GetConsoleV1RolesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1RolesError = GetConsoleV1RolesErrors[keyof GetConsoleV1RolesErrors]

export type GetConsoleV1RolesResponses = {
  /**
   * List Roles Response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<RoleContractDto>
  }
}

export type GetConsoleV1RolesResponse = GetConsoleV1RolesResponses[keyof GetConsoleV1RolesResponses]

export type PostConsoleV1RolesData = {
  body: RoleContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/roles'
}

export type PostConsoleV1RolesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1RolesError = PostConsoleV1RolesErrors[keyof PostConsoleV1RolesErrors]

export type PostConsoleV1RolesResponses = {
  /**
   * Create Role Response
   */
  201: SingleDataResponse & {
    data?: RoleContractDto
  }
}

export type PostConsoleV1RolesResponse = PostConsoleV1RolesResponses[keyof PostConsoleV1RolesResponses]

export type DeleteConsoleV1RolesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/roles/{id}'
}

export type DeleteConsoleV1RolesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type DeleteConsoleV1RolesByIdError = DeleteConsoleV1RolesByIdErrors[keyof DeleteConsoleV1RolesByIdErrors]

export type DeleteConsoleV1RolesByIdResponses = {
  /**
   * Delete Role Response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1RolesByIdResponse =
  DeleteConsoleV1RolesByIdResponses[keyof DeleteConsoleV1RolesByIdResponses]

export type GetConsoleV1RolesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/roles/{id}'
}

export type GetConsoleV1RolesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1RolesByIdError = GetConsoleV1RolesByIdErrors[keyof GetConsoleV1RolesByIdErrors]

export type GetConsoleV1RolesByIdResponses = {
  /**
   * Get Role Response
   */
  200: SingleDataResponse & {
    data?: RoleContractDto
  }
}

export type GetConsoleV1RolesByIdResponse = GetConsoleV1RolesByIdResponses[keyof GetConsoleV1RolesByIdResponses]

export type PatchConsoleV1RolesByIdData = {
  body: RoleUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/roles/{id}'
}

export type PatchConsoleV1RolesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PatchConsoleV1RolesByIdError = PatchConsoleV1RolesByIdErrors[keyof PatchConsoleV1RolesByIdErrors]

export type PatchConsoleV1RolesByIdResponses = {
  /**
   * Update Role Response
   */
  200: SingleDataResponse & {
    data?: RoleContractDto
  }
}

export type PatchConsoleV1RolesByIdResponse = PatchConsoleV1RolesByIdResponses[keyof PatchConsoleV1RolesByIdResponses]

export type GetConsoleV1SegmentsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/segments'
}

export type GetConsoleV1SegmentsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1SegmentsError = GetConsoleV1SegmentsErrors[keyof GetConsoleV1SegmentsErrors]

export type GetConsoleV1SegmentsResponses = {
  /**
   * List Segments Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<SegmentDto>
  }
}

export type GetConsoleV1SegmentsResponse = GetConsoleV1SegmentsResponses[keyof GetConsoleV1SegmentsResponses]

export type PostConsoleV1SegmentsData = {
  body: SegmentCreateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/segments'
}

export type PostConsoleV1SegmentsErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1SegmentsError = PostConsoleV1SegmentsErrors[keyof PostConsoleV1SegmentsErrors]

export type PostConsoleV1SegmentsResponses = {
  /**
   * Create Segment Success
   */
  201: SingleDataResponse & {
    data?: SegmentDto
  }
}

export type PostConsoleV1SegmentsResponse = PostConsoleV1SegmentsResponses[keyof PostConsoleV1SegmentsResponses]

export type DeleteConsoleV1SegmentsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}'
}

export type DeleteConsoleV1SegmentsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1SegmentsByIdError =
  DeleteConsoleV1SegmentsByIdErrors[keyof DeleteConsoleV1SegmentsByIdErrors]

export type DeleteConsoleV1SegmentsByIdResponses = {
  /**
   * Delete Segment Success
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1SegmentsByIdResponse =
  DeleteConsoleV1SegmentsByIdResponses[keyof DeleteConsoleV1SegmentsByIdResponses]

export type GetConsoleV1SegmentsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}'
}

export type GetConsoleV1SegmentsByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1SegmentsByIdError = GetConsoleV1SegmentsByIdErrors[keyof GetConsoleV1SegmentsByIdErrors]

export type GetConsoleV1SegmentsByIdResponses = {
  /**
   * Get Segment Success
   */
  200: SingleDataResponse & {
    data?: SegmentDto
  }
}

export type GetConsoleV1SegmentsByIdResponse =
  GetConsoleV1SegmentsByIdResponses[keyof GetConsoleV1SegmentsByIdResponses]

export type PatchConsoleV1SegmentsByIdAddIdsData = {
  body: SegmentIdListUserStoreContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/add_ids'
}

export type PatchConsoleV1SegmentsByIdAddIdsErrors = {
  /**
   * Segment must be of type 'user_store_id_list' to be modified on this endpoint
   */
  400: {
    status: 400
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1SegmentsByIdAddIdsError =
  PatchConsoleV1SegmentsByIdAddIdsErrors[keyof PatchConsoleV1SegmentsByIdAddIdsErrors]

export type PatchConsoleV1SegmentsByIdAddIdsResponses = {
  /**
   * User Store ID List updated successfully.
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1SegmentsByIdAddIdsResponse =
  PatchConsoleV1SegmentsByIdAddIdsResponses[keyof PatchConsoleV1SegmentsByIdAddIdsResponses]

export type PutConsoleV1SegmentsByIdArchiveData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/archive'
}

export type PutConsoleV1SegmentsByIdArchiveErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PutConsoleV1SegmentsByIdArchiveError =
  PutConsoleV1SegmentsByIdArchiveErrors[keyof PutConsoleV1SegmentsByIdArchiveErrors]

export type PutConsoleV1SegmentsByIdArchiveResponses = {
  /**
   * Archive Segment Success
   */
  200: SingleDataResponse & {
    data?: SegmentDto
  }
}

export type PutConsoleV1SegmentsByIdArchiveResponse =
  PutConsoleV1SegmentsByIdArchiveResponses[keyof PutConsoleV1SegmentsByIdArchiveResponses]

export type PostConsoleV1SegmentsByIdConditionalData = {
  body: SegmentRulesDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/conditional'
}

export type PostConsoleV1SegmentsByIdConditionalErrors = {
  /**
   * Segment must be of type 'rule_based' to be modified on this endpoint
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1SegmentsByIdConditionalError =
  PostConsoleV1SegmentsByIdConditionalErrors[keyof PostConsoleV1SegmentsByIdConditionalErrors]

export type PostConsoleV1SegmentsByIdConditionalResponses = {
  /**
   * Rules Successfully Updated
   */
  200: SingleDataResponse & {
    data?: SegmentDto
  }
}

export type PostConsoleV1SegmentsByIdConditionalResponse =
  PostConsoleV1SegmentsByIdConditionalResponses[keyof PostConsoleV1SegmentsByIdConditionalResponses]

export type DeleteConsoleV1SegmentsByIdIdListData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/id_list'
}

export type DeleteConsoleV1SegmentsByIdIdListErrors = {
  /**
   * Segment must be of type 'id_list' to be modified on this endpoint
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type DeleteConsoleV1SegmentsByIdIdListError =
  DeleteConsoleV1SegmentsByIdIdListErrors[keyof DeleteConsoleV1SegmentsByIdIdListErrors]

export type DeleteConsoleV1SegmentsByIdIdListResponses = {
  /**
   * Segment ids deleted successfully.
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1SegmentsByIdIdListResponse =
  DeleteConsoleV1SegmentsByIdIdListResponses[keyof DeleteConsoleV1SegmentsByIdIdListResponses]

export type GetConsoleV1SegmentsByIdIdListData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/segments/{id}/id_list'
}

export type GetConsoleV1SegmentsByIdIdListResponses = {
  /**
   * IDs read successfully
   */
  200: PaginationResponseWithMessage & {
    data?: IdListDto
  }
}

export type GetConsoleV1SegmentsByIdIdListResponse =
  GetConsoleV1SegmentsByIdIdListResponses[keyof GetConsoleV1SegmentsByIdIdListResponses]

export type PatchConsoleV1SegmentsByIdIdListData = {
  body: SegmentIdListContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/id_list'
}

export type PatchConsoleV1SegmentsByIdIdListErrors = {
  /**
   * Segment must be of type 'id_list' to be modified on this endpoint
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1SegmentsByIdIdListError =
  PatchConsoleV1SegmentsByIdIdListErrors[keyof PatchConsoleV1SegmentsByIdIdListErrors]

export type PatchConsoleV1SegmentsByIdIdListResponses = {
  /**
   * Segment ids updated successfully.
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1SegmentsByIdIdListResponse =
  PatchConsoleV1SegmentsByIdIdListResponses[keyof PatchConsoleV1SegmentsByIdIdListResponses]

export type PostConsoleV1SegmentsByIdIdListResetData = {
  body: SegmentIdListResetContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/id_list/reset'
}

export type PostConsoleV1SegmentsByIdIdListResetResponses = {
  /**
   * Reset ID List Segment Success
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1SegmentsByIdIdListResetResponse =
  PostConsoleV1SegmentsByIdIdListResetResponses[keyof PostConsoleV1SegmentsByIdIdListResetResponses]

export type GetConsoleV1SegmentsByIdIdlistMetadataData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/idlist_metadata'
}

export type GetConsoleV1SegmentsByIdIdlistMetadataResponses = {
  /**
   * ID List metadata read successfully
   */
  200: SingleDataResponse & {
    data?: IdListMetadataDto
  }
}

export type GetConsoleV1SegmentsByIdIdlistMetadataResponse =
  GetConsoleV1SegmentsByIdIdlistMetadataResponses[keyof GetConsoleV1SegmentsByIdIdlistMetadataResponses]

export type PatchConsoleV1SegmentsByIdRemoveIdsData = {
  body: SegmentIdListUserStoreContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/segments/{id}/remove_ids'
}

export type PatchConsoleV1SegmentsByIdRemoveIdsErrors = {
  /**
   * Segment must be of type 'user_store_id_list' to be modified on this endpoint
   */
  400: {
    status: 400
    message: string
  }
  /**
   * Segment not found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1SegmentsByIdRemoveIdsError =
  PatchConsoleV1SegmentsByIdRemoveIdsErrors[keyof PatchConsoleV1SegmentsByIdRemoveIdsErrors]

export type PatchConsoleV1SegmentsByIdRemoveIdsResponses = {
  /**
   * User Store ID List updated successfully.
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1SegmentsByIdRemoveIdsResponse =
  PatchConsoleV1SegmentsByIdRemoveIdsResponses[keyof PatchConsoleV1SegmentsByIdRemoveIdsResponses]

export type GetConsoleV1SettingsProjectData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/project'
}

export type GetConsoleV1SettingsProjectErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1SettingsProjectError =
  GetConsoleV1SettingsProjectErrors[keyof GetConsoleV1SettingsProjectErrors]

export type GetConsoleV1SettingsProjectResponses = {
  /**
   * Get Project Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsProjectContractDto
  }
}

export type GetConsoleV1SettingsProjectResponse =
  GetConsoleV1SettingsProjectResponses[keyof GetConsoleV1SettingsProjectResponses]

export type PostConsoleV1SettingsProjectData = {
  body: SettingsProjectContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/project'
}

export type PostConsoleV1SettingsProjectErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1SettingsProjectError =
  PostConsoleV1SettingsProjectErrors[keyof PostConsoleV1SettingsProjectErrors]

export type PostConsoleV1SettingsProjectResponses = {
  /**
   * Update Project Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsProjectContractDto
  }
}

export type PostConsoleV1SettingsProjectResponse =
  PostConsoleV1SettingsProjectResponses[keyof PostConsoleV1SettingsProjectResponses]

export type GetConsoleV1SettingsReviewsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/reviews'
}

export type GetConsoleV1SettingsReviewsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1SettingsReviewsError =
  GetConsoleV1SettingsReviewsErrors[keyof GetConsoleV1SettingsReviewsErrors]

export type GetConsoleV1SettingsReviewsResponses = {
  /**
   * Get Reviews Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsReviewsContractDto
  }
}

export type GetConsoleV1SettingsReviewsResponse =
  GetConsoleV1SettingsReviewsResponses[keyof GetConsoleV1SettingsReviewsResponses]

export type PostConsoleV1SettingsReviewsData = {
  body: SettingsReviewsContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/reviews'
}

export type PostConsoleV1SettingsReviewsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1SettingsReviewsError =
  PostConsoleV1SettingsReviewsErrors[keyof PostConsoleV1SettingsReviewsErrors]

export type PostConsoleV1SettingsReviewsResponses = {
  /**
   * Update Reviews Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsReviewsContractDto
  }
}

export type PostConsoleV1SettingsReviewsResponse =
  PostConsoleV1SettingsReviewsResponses[keyof PostConsoleV1SettingsReviewsResponses]

export type GetConsoleV1SettingsRolesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/roles'
}

export type GetConsoleV1SettingsRolesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1SettingsRolesError = GetConsoleV1SettingsRolesErrors[keyof GetConsoleV1SettingsRolesErrors]

export type GetConsoleV1SettingsRolesResponses = {
  /**
   * Get Roles Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsRolesContractDto
  }
}

export type GetConsoleV1SettingsRolesResponse =
  GetConsoleV1SettingsRolesResponses[keyof GetConsoleV1SettingsRolesResponses]

export type PostConsoleV1SettingsRolesData = {
  body: SettingsRolesContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/roles'
}

export type PostConsoleV1SettingsRolesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1SettingsRolesError = PostConsoleV1SettingsRolesErrors[keyof PostConsoleV1SettingsRolesErrors]

export type PostConsoleV1SettingsRolesResponses = {
  /**
   * Update Roles Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsRolesContractDto
  }
}

export type PostConsoleV1SettingsRolesResponse =
  PostConsoleV1SettingsRolesResponses[keyof PostConsoleV1SettingsRolesResponses]

export type GetConsoleV1SettingsTeamsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/teams'
}

export type GetConsoleV1SettingsTeamsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1SettingsTeamsError = GetConsoleV1SettingsTeamsErrors[keyof GetConsoleV1SettingsTeamsErrors]

export type GetConsoleV1SettingsTeamsResponses = {
  /**
   * Get Teams Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsTeamsContractDto
  }
}

export type GetConsoleV1SettingsTeamsResponse =
  GetConsoleV1SettingsTeamsResponses[keyof GetConsoleV1SettingsTeamsResponses]

export type PostConsoleV1SettingsTeamsData = {
  body: SettingsTeamsContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/settings/teams'
}

export type PostConsoleV1SettingsTeamsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1SettingsTeamsError = PostConsoleV1SettingsTeamsErrors[keyof PostConsoleV1SettingsTeamsErrors]

export type PostConsoleV1SettingsTeamsResponses = {
  /**
   * Update Teams Settings Response
   */
  200: SingleDataResponse & {
    data?: SettingsTeamsContractDto
  }
}

export type PostConsoleV1SettingsTeamsResponse =
  PostConsoleV1SettingsTeamsResponses[keyof PostConsoleV1SettingsTeamsResponses]

export type GetConsoleV1TagsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/tags'
}

export type GetConsoleV1TagsErrors = {
  /**
   * Tag not found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1TagsError = GetConsoleV1TagsErrors[keyof GetConsoleV1TagsErrors]

export type GetConsoleV1TagsResponses = {
  /**
   * List Tags Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<TagDto>
  }
}

export type GetConsoleV1TagsResponse = GetConsoleV1TagsResponses[keyof GetConsoleV1TagsResponses]

export type PostConsoleV1TagsData = {
  body: TagCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/tags'
}

export type PostConsoleV1TagsResponses = {
  /**
   * Create Tag Response
   */
  200: SingleDataResponse & {
    data?: TagDto
  }
}

export type PostConsoleV1TagsResponse = PostConsoleV1TagsResponses[keyof PostConsoleV1TagsResponses]

export type DeleteConsoleV1TagsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/tags/{id}'
}

export type DeleteConsoleV1TagsByIdResponses = {
  /**
   * Delete tag response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1TagsByIdResponse = DeleteConsoleV1TagsByIdResponses[keyof DeleteConsoleV1TagsByIdResponses]

export type GetConsoleV1TagsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/tags/{id}'
}

export type GetConsoleV1TagsByIdErrors = {
  /**
   * Tag not found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1TagsByIdError = GetConsoleV1TagsByIdErrors[keyof GetConsoleV1TagsByIdErrors]

export type GetConsoleV1TagsByIdResponses = {
  /**
   * Read Tag Success
   */
  200: SingleDataResponse & {
    data?: TagDto
  }
}

export type GetConsoleV1TagsByIdResponse = GetConsoleV1TagsByIdResponses[keyof GetConsoleV1TagsByIdResponses]

export type PatchConsoleV1TagsByIdData = {
  body: TagUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/tags/{id}'
}

export type PatchConsoleV1TagsByIdResponses = {
  /**
   * Update Tag Response
   */
  200: SingleDataResponse & {
    data?: TagDto
  }
}

export type PatchConsoleV1TagsByIdResponse = PatchConsoleV1TagsByIdResponses[keyof PatchConsoleV1TagsByIdResponses]

export type GetConsoleV1TargetAppData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/target_app'
}

export type GetConsoleV1TargetAppErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1TargetAppError = GetConsoleV1TargetAppErrors[keyof GetConsoleV1TargetAppErrors]

export type GetConsoleV1TargetAppResponses = {
  /**
   * List Target Apps Success
   */
  200: PaginationResponseWithMessage & {
    data?: Array<TargetAppDto>
  }
}

export type GetConsoleV1TargetAppResponse = GetConsoleV1TargetAppResponses[keyof GetConsoleV1TargetAppResponses]

export type PatchConsoleV1TargetAppData = {
  body: BulkAssignConfigTargetAppDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/target_app'
}

export type PatchConsoleV1TargetAppErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Gates with IDs [not a gate] do not exist
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1TargetAppError = PatchConsoleV1TargetAppErrors[keyof PatchConsoleV1TargetAppErrors]

export type PatchConsoleV1TargetAppResponses = {
  /**
   * Bulk Assign Target Apps Success
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1TargetAppResponse = PatchConsoleV1TargetAppResponses[keyof PatchConsoleV1TargetAppResponses]

export type PostConsoleV1TargetAppData = {
  body: TargetAppCreateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/target_app'
}

export type PostConsoleV1TargetAppResponses = {
  /**
   * Create Target App Success
   */
  200: SingleDataResponse & {
    data?: TargetAppDto
  }
}

export type PostConsoleV1TargetAppResponse = PostConsoleV1TargetAppResponses[keyof PostConsoleV1TargetAppResponses]

export type DeleteConsoleV1TargetAppByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id of target app
     */
    id: string
  }
  query?: never
  url: '/console/v1/target_app/{id}'
}

export type DeleteConsoleV1TargetAppByIdResponses = {
  /**
   * Delete Target App Success
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1TargetAppByIdResponse =
  DeleteConsoleV1TargetAppByIdResponses[keyof DeleteConsoleV1TargetAppByIdResponses]

export type GetConsoleV1TargetAppByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/target_app/{id}'
}

export type GetConsoleV1TargetAppByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1TargetAppByIdError = GetConsoleV1TargetAppByIdErrors[keyof GetConsoleV1TargetAppByIdErrors]

export type GetConsoleV1TargetAppByIdResponses = {
  /**
   * Read Target App Success
   */
  200: SingleDataResponse & {
    data?: TargetAppDto
  }
}

export type GetConsoleV1TargetAppByIdResponse =
  GetConsoleV1TargetAppByIdResponses[keyof GetConsoleV1TargetAppByIdResponses]

export type PatchConsoleV1TargetAppByIdData = {
  body: UpdateTargetAppDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/target_app/{id}'
}

export type PatchConsoleV1TargetAppByIdErrors = {
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Gates with IDs [not a gate] do not exist
   */
  404: {
    status: 404
    message: string
  }
}

export type PatchConsoleV1TargetAppByIdError =
  PatchConsoleV1TargetAppByIdErrors[keyof PatchConsoleV1TargetAppByIdErrors]

export type PatchConsoleV1TargetAppByIdResponses = {
  /**
   * Update Target App Success
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1TargetAppByIdResponse =
  PatchConsoleV1TargetAppByIdResponses[keyof PatchConsoleV1TargetAppByIdResponses]

export type GetConsoleV1UnitIdTypesData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/unit_id_types'
}

export type GetConsoleV1UnitIdTypesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1UnitIdTypesError = GetConsoleV1UnitIdTypesErrors[keyof GetConsoleV1UnitIdTypesErrors]

export type GetConsoleV1UnitIdTypesResponses = {
  /**
   * List Unit ID Types Response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<UnitIdTypeContractDto>
  }
}

export type GetConsoleV1UnitIdTypesResponse = GetConsoleV1UnitIdTypesResponses[keyof GetConsoleV1UnitIdTypesResponses]

export type PostConsoleV1UnitIdTypesData = {
  body: UnitIdTypeContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/unit_id_types'
}

export type PostConsoleV1UnitIdTypesErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1UnitIdTypesError = PostConsoleV1UnitIdTypesErrors[keyof PostConsoleV1UnitIdTypesErrors]

export type PostConsoleV1UnitIdTypesResponses = {
  /**
   * Create Unit ID Type Response
   */
  201: SingleDataResponse & {
    data?: UnitIdTypeContractDto
  }
}

export type PostConsoleV1UnitIdTypesResponse =
  PostConsoleV1UnitIdTypesResponses[keyof PostConsoleV1UnitIdTypesResponses]

export type DeleteConsoleV1UnitIdTypesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/unit_id_types/{id}'
}

export type DeleteConsoleV1UnitIdTypesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
}

export type DeleteConsoleV1UnitIdTypesByIdError =
  DeleteConsoleV1UnitIdTypesByIdErrors[keyof DeleteConsoleV1UnitIdTypesByIdErrors]

export type DeleteConsoleV1UnitIdTypesByIdResponses = {
  /**
   * Delete Unit ID Type Response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1UnitIdTypesByIdResponse =
  DeleteConsoleV1UnitIdTypesByIdResponses[keyof DeleteConsoleV1UnitIdTypesByIdResponses]

export type GetConsoleV1UnitIdTypesByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/unit_id_types/{id}'
}

export type GetConsoleV1UnitIdTypesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1UnitIdTypesByIdError =
  GetConsoleV1UnitIdTypesByIdErrors[keyof GetConsoleV1UnitIdTypesByIdErrors]

export type GetConsoleV1UnitIdTypesByIdResponses = {
  /**
   * Get Unit ID Type Response
   */
  200: SingleDataResponse & {
    data?: UnitIdTypeContractDto
  }
}

export type GetConsoleV1UnitIdTypesByIdResponse =
  GetConsoleV1UnitIdTypesByIdResponses[keyof GetConsoleV1UnitIdTypesByIdResponses]

export type PatchConsoleV1UnitIdTypesByIdData = {
  body: UnitIdTypeUpdateContractDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/unit_id_types/{id}'
}

export type PatchConsoleV1UnitIdTypesByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
}

export type PatchConsoleV1UnitIdTypesByIdError =
  PatchConsoleV1UnitIdTypesByIdErrors[keyof PatchConsoleV1UnitIdTypesByIdErrors]

export type PatchConsoleV1UnitIdTypesByIdResponses = {
  /**
   * Update Unit ID Type Response
   */
  200: SingleDataResponse & {
    data?: UnitIdTypeContractDto
  }
}

export type PatchConsoleV1UnitIdTypesByIdResponse =
  PatchConsoleV1UnitIdTypesByIdResponses[keyof PatchConsoleV1UnitIdTypesByIdResponses]

export type GetConsoleV1UsersData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/users'
}

export type GetConsoleV1UsersErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1UsersError = GetConsoleV1UsersErrors[keyof GetConsoleV1UsersErrors]

export type GetConsoleV1UsersResponses = {
  /**
   * List users response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<UserContractDto>
  }
}

export type GetConsoleV1UsersResponse = GetConsoleV1UsersResponses[keyof GetConsoleV1UsersResponses]

export type GetConsoleV1UsersByEmailData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * email
     */
    email: string
  }
  query?: never
  url: '/console/v1/users/{email}'
}

export type GetConsoleV1UsersByEmailErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type GetConsoleV1UsersByEmailError = GetConsoleV1UsersByEmailErrors[keyof GetConsoleV1UsersByEmailErrors]

export type GetConsoleV1UsersByEmailResponses = {
  /**
   * Get user response
   */
  200: SingleDataResponse & {
    data?: UserContractDto
  }
}

export type GetConsoleV1UsersByEmailResponse =
  GetConsoleV1UsersByEmailResponses[keyof GetConsoleV1UsersByEmailResponses]

export type PostConsoleV1UsersByEmailData = {
  body: UserUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * email
     */
    email: string
  }
  query?: never
  url: '/console/v1/users/{email}'
}

export type PostConsoleV1UsersByEmailErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
  /**
   * Forbidden. The request was valid, but the server is refusing action. You might not have the necessary permissions to access the resource.
   */
  403: {
    status: 403
    message: string
  }
  /**
   * Not Found. The requested resource could not be found.
   */
  404: {
    status: 404
    message: string
  }
}

export type PostConsoleV1UsersByEmailError = PostConsoleV1UsersByEmailErrors[keyof PostConsoleV1UsersByEmailErrors]

export type PostConsoleV1UsersByEmailResponses = {
  /**
   * Update user response
   */
  200: SingleDataResponse & {
    data?: UserContractDto
  }
}

export type PostConsoleV1UsersByEmailResponse =
  PostConsoleV1UsersByEmailResponses[keyof PostConsoleV1UsersByEmailResponses]

export type PostConsoleV1UsersInviteData = {
  body: UserInvitesDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/users/invite'
}

export type PostConsoleV1UsersInviteErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1UsersInviteError = PostConsoleV1UsersInviteErrors[keyof PostConsoleV1UsersInviteErrors]

export type PostConsoleV1UsersInviteResponses = {
  /**
   * Invite user response
   */
  200: {
    message?: string
  }
}

export type PostConsoleV1UsersInviteResponse =
  PostConsoleV1UsersInviteResponses[keyof PostConsoleV1UsersInviteResponses]

export type GetConsoleV1UsersTeamsData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: {
    /**
     * Results per page
     */
    limit?: string | number
    /**
     * Page number
     */
    page?: string | number
  }
  url: '/console/v1/users/teams'
}

export type GetConsoleV1UsersTeamsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1UsersTeamsError = GetConsoleV1UsersTeamsErrors[keyof GetConsoleV1UsersTeamsErrors]

export type GetConsoleV1UsersTeamsResponses = {
  /**
   * Get teams response
   */
  200: PaginationResponseWithMessage & {
    data?: Array<TeamDto>
  }
}

export type GetConsoleV1UsersTeamsResponse = GetConsoleV1UsersTeamsResponses[keyof GetConsoleV1UsersTeamsResponses]

export type PostConsoleV1UsersTeamsData = {
  body: TeamCreationDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/users/teams'
}

export type PostConsoleV1UsersTeamsErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PostConsoleV1UsersTeamsError = PostConsoleV1UsersTeamsErrors[keyof PostConsoleV1UsersTeamsErrors]

export type PostConsoleV1UsersTeamsResponses = {
  /**
   * Create team response
   */
  200: SingleDataResponse & {
    data?: TeamDto
  }
}

export type PostConsoleV1UsersTeamsResponse = PostConsoleV1UsersTeamsResponses[keyof PostConsoleV1UsersTeamsResponses]

export type DeleteConsoleV1UsersTeamsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/users/teams/{id}'
}

export type DeleteConsoleV1UsersTeamsByIdResponses = {
  /**
   * Delete team response
   */
  200: {
    message?: string
  }
}

export type DeleteConsoleV1UsersTeamsByIdResponse =
  DeleteConsoleV1UsersTeamsByIdResponses[keyof DeleteConsoleV1UsersTeamsByIdResponses]

export type GetConsoleV1UsersTeamsByIdData = {
  body?: never
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/users/teams/{id}'
}

export type GetConsoleV1UsersTeamsByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type GetConsoleV1UsersTeamsByIdError = GetConsoleV1UsersTeamsByIdErrors[keyof GetConsoleV1UsersTeamsByIdErrors]

export type GetConsoleV1UsersTeamsByIdResponses = {
  /**
   * Get team response
   */
  200: SingleDataResponse & {
    data?: TeamDto
  }
}

export type GetConsoleV1UsersTeamsByIdResponse =
  GetConsoleV1UsersTeamsByIdResponses[keyof GetConsoleV1UsersTeamsByIdResponses]

export type PatchConsoleV1UsersTeamsByIdData = {
  body: TeamPartialUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path: {
    /**
     * id
     */
    id: string
  }
  query?: never
  url: '/console/v1/users/teams/{id}'
}

export type PatchConsoleV1UsersTeamsByIdErrors = {
  /**
   * Invalid request. Please check the request input and try again.
   */
  400: {
    status: 400
    message: string
  }
  /**
   * This endpoint only accepts an active CONSOLE key, but an invalid key was sent. Key: console-xxxXXXxxxXXXxxx
   */
  401: {
    status: 401
    message: string
  }
}

export type PatchConsoleV1UsersTeamsByIdError =
  PatchConsoleV1UsersTeamsByIdErrors[keyof PatchConsoleV1UsersTeamsByIdErrors]

export type PatchConsoleV1UsersTeamsByIdResponses = {
  /**
   * Update team response
   */
  200: SingleDataResponse & {
    data?: TeamDto
  }
}

export type PatchConsoleV1UsersTeamsByIdResponse =
  PatchConsoleV1UsersTeamsByIdResponses[keyof PatchConsoleV1UsersTeamsByIdResponses]

export type PatchConsoleV1WhConnectionsData = {
  body: WhConnectionUpdateDto
  headers?: {
    /**
     * Optional header to respect review settings for mutation endpoints.
     */
    'x-respect-review-settings'?: string
  }
  path?: never
  query?: never
  url: '/console/v1/wh_connections'
}

export type PatchConsoleV1WhConnectionsErrors = {
  /**
   * Insufficient permissions.
   */
  403: {
    status: 403
    message: string
  }
}

export type PatchConsoleV1WhConnectionsError =
  PatchConsoleV1WhConnectionsErrors[keyof PatchConsoleV1WhConnectionsErrors]

export type PatchConsoleV1WhConnectionsResponses = {
  /**
   * Connection updated successfully
   */
  200: {
    message?: string
  }
}

export type PatchConsoleV1WhConnectionsResponse =
  PatchConsoleV1WhConnectionsResponses[keyof PatchConsoleV1WhConnectionsResponses]

export type ClientOptions = {
  baseUrl: 'https://statsigapi.net' | (string & {})
}
