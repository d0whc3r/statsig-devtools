// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zAlertSchemaDto = z.object({
  id: z.string(),
  name: z.string(),
  alertType: z.enum(['threshold']),
  metrics: z.record(z.string(), z.unknown()),
  metricGroupBys: z.record(z.string(), z.unknown()),
  formula: z.optional(z.string()),
  message: z.string(),
  creatorID: z.optional(z.string()),
  companyID: z.string(),
  priority: z.enum(['P0', 'P1', 'P2', 'P3', 'P4', 'P5']),
  alertThreshold: z.number(),
  warningThreshold: z.optional(z.number()),
  windowMs: z.number(),
  condition: z.enum(['greater', 'greater_or_equal', 'less', 'less_or_equal', 'equal', 'not_equal']),
  renotificationConditions: z.optional(z.array(z.enum(['raise', 'warn', 'no-data']))),
  renotificationWindowMs: z.optional(z.number()),
  renotificationMessage: z.optional(z.string()),
  team: z.optional(z.union([z.string(), z.null()])),
  tags: z.array(z.string()),
})

export const zArchiveSchemaDto = z.object({
  forceArchive: z.optional(z.boolean()),
  archiveReason: z.optional(z.string()),
})

export const zAssignmentSourceContractDto = z.object({
  name: z.string(),
  description: z.string(),
  isVerified: z.optional(z.boolean()),
  tags: z.array(z.string()),
  sql: z.string(),
  timestampColumn: z.string(),
  experimentIDColumn: z.string(),
  groupIDColumn: z.string(),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
})

export const zAssignmentSourceCreationDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  isVerified: z.optional(z.boolean()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.string(),
  experimentIDColumn: z.string(),
  groupIDColumn: z.string(),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zAssignmentSourcePartialUpdateDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  isVerified: z.optional(z.boolean()),
  tags: z.optional(z.array(z.string())),
  sql: z.optional(z.unknown().readonly()),
  timestampColumn: z.optional(z.string()),
  experimentIDColumn: z.optional(z.string()),
  groupIDColumn: z.optional(z.string()),
  idTypeMapping: z.optional(
    z.array(
      z.object({
        statsigUnitID: z.string(),
        column: z.string(),
      }),
    ),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zAssignmentSourceQueryUpdateDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  isVerified: z.optional(z.boolean()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.string(),
  experimentIDColumn: z.string(),
  groupIDColumn: z.string(),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zAuditLogDto = z.object({
  id: z.string(),
  name: z.string(),
  changeLog: z.string(),
  actionType: z.record(z.string(), z.unknown()),
  date: z.string(),
  time: z.string(),
  updatedBy: z.string(),
  updatedByUserID: z.string(),
  modifierEmail: z.record(z.string(), z.unknown()),
  changes: z.record(z.string(), z.unknown()),
  tags: z.array(z.string()),
  targetAppIDs: z.optional(z.array(z.string())),
})

export const zAutotuneCreateDto = z.object({
  description: z.optional(z.string()),
  variants: z
    .array(
      z.object({
        name: z.string(),
        json: z.unknown(),
        size: z.optional(z.number()),
      }),
    )
    .min(2),
  successEvent: z.string(),
  successEventValue: z.optional(z.string()),
  explorationWindow: z.enum([
    '1hr',
    '24hr',
    '48hr',
    '168hr',
    '336hr',
    '1',
    '24',
    '48',
    '168',
    '336',
    '1hrs',
    '24hrs',
    '48hrs',
    '168hrs',
    '336hrs',
  ]),
  attributionWindow: z.enum(['1hr', '2hr', '4hr', '24hr', '1hrs', '2hrs', '4hrs', '24hrs', '1', '2', '4', '24']),
  attributionWindowUnit: z.optional(z.enum(['min', 'hour', 'day'])),
  explorationWindowRate: z.optional(z.number().gte(0.001).lte(1)),
  longtermExplorationAllocation: z.optional(z.number().gte(0.001).lte(1)),
  winnerThreshold: z.enum(['80%', '90%', '95%', '98%', '99%']),
  metadataField: z.optional(z.string()),
  higherIsBetter: z.optional(z.boolean()),
  isContextual: z.optional(z.boolean()),
  metricSourceID: z.optional(z.string()),
  linkedExperimentName: z.optional(z.string()),
  goalRichText: z.optional(z.string()),
  optimizationParameter: z.optional(z.enum(['occurrence', 'value'])),
  valueColumn: z.optional(z.string()),
  featureList: z.optional(z.array(z.string())),
  name: z.string(),
  idType: z.optional(z.string()),
})

export const zAutotuneExperimentDto = z.object({
  description: z.string(),
  variants: z.array(
    z.object({
      name: z.string(),
      json: z.unknown(),
      size: z.optional(z.number()),
      id: z.string(),
    }),
  ),
  successEvent: z.string(),
  successEventValue: z.string(),
  explorationWindow: z.enum([
    '1hr',
    '24hr',
    '48hr',
    '168hr',
    '336hr',
    '1',
    '24',
    '48',
    '168',
    '336',
    '1hrs',
    '24hrs',
    '48hrs',
    '168hrs',
    '336hrs',
  ]),
  attributionWindow: z.enum(['1hr', '2hr', '4hr', '24hr', '1hrs', '2hrs', '4hrs', '24hrs', '1', '2', '4', '24']),
  attributionWindowUnit: z.optional(z.enum(['min', 'hour', 'day'])),
  explorationWindowRate: z.optional(z.number().gte(0.001).lte(1)),
  longtermExplorationAllocation: z.optional(z.number().gte(0.001).lte(1)),
  winnerThreshold: z.enum(['80%', '90%', '95%', '98%', '99%']),
  metadataField: z.optional(z.string()),
  higherIsBetter: z.optional(z.boolean()),
  isContextual: z.optional(z.boolean()),
  metricSourceID: z.optional(z.string()),
  linkedExperimentName: z.optional(z.string()),
  goalRichText: z.optional(z.string()),
  optimizationParameter: z.optional(z.enum(['occurrence', 'value'])),
  valueColumn: z.optional(z.string()),
  featureList: z.optional(z.array(z.string())),
  id: z.string(),
  name: z.optional(z.string()),
  idType: z.string(),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.union([z.string(), z.null()]),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.union([z.string(), z.null()]),
  tags: z.optional(z.array(z.string())),
  targetApps: z.optional(z.array(z.string())),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  isStarted: z.boolean(),
  winner: z.union([
    z.object({
      id: z.string(),
      name: z.string(),
    }),
    z.null(),
  ]),
})

/**
 * Autotune object
 */
export const zAutotuneFullUpdateDto = z.object({
  description: z.optional(z.string()),
  variants: z
    .array(
      z.object({
        name: z.string(),
        json: z.unknown(),
        size: z.optional(z.number()),
      }),
    )
    .min(2),
  successEvent: z.string(),
  successEventValue: z.optional(z.string()),
  explorationWindow: z.enum([
    '1hr',
    '24hr',
    '48hr',
    '168hr',
    '336hr',
    '1',
    '24',
    '48',
    '168',
    '336',
    '1hrs',
    '24hrs',
    '48hrs',
    '168hrs',
    '336hrs',
  ]),
  attributionWindow: z.enum(['1hr', '2hr', '4hr', '24hr', '1hrs', '2hrs', '4hrs', '24hrs', '1', '2', '4', '24']),
  attributionWindowUnit: z.optional(z.enum(['min', 'hour', 'day'])),
  explorationWindowRate: z.optional(z.number().gte(0.001).lte(1)),
  longtermExplorationAllocation: z.optional(z.number().gte(0.001).lte(1)),
  winnerThreshold: z.enum(['80%', '90%', '95%', '98%', '99%']),
  metadataField: z.optional(z.string()),
  higherIsBetter: z.optional(z.boolean()),
  isContextual: z.optional(z.boolean()),
  metricSourceID: z.optional(z.string()),
  linkedExperimentName: z.optional(z.string()),
  goalRichText: z.optional(z.string()),
  optimizationParameter: z.optional(z.enum(['occurrence', 'value'])),
  valueColumn: z.optional(z.string()),
  featureList: z.optional(z.array(z.string())),
})

export const zAutotunePartialUpdateDto = z.object({
  description: z.optional(z.string()),
  variants: z.optional(
    z
      .array(
        z.object({
          name: z.string(),
          json: z.unknown(),
          size: z.optional(z.number()),
        }),
      )
      .min(2),
  ),
  successEvent: z.optional(z.string()),
  successEventValue: z.optional(z.string()),
  explorationWindow: z.optional(
    z.enum([
      '1hr',
      '24hr',
      '48hr',
      '168hr',
      '336hr',
      '1',
      '24',
      '48',
      '168',
      '336',
      '1hrs',
      '24hrs',
      '48hrs',
      '168hrs',
      '336hrs',
    ]),
  ),
  attributionWindow: z.optional(
    z.enum(['1hr', '2hr', '4hr', '24hr', '1hrs', '2hrs', '4hrs', '24hrs', '1', '2', '4', '24']),
  ),
  attributionWindowUnit: z.optional(z.enum(['min', 'hour', 'day'])),
  explorationWindowRate: z.optional(z.number().gte(0.001).lte(1)),
  longtermExplorationAllocation: z.optional(z.number().gte(0.001).lte(1)),
  winnerThreshold: z.optional(z.enum(['80%', '90%', '95%', '98%', '99%'])),
  metadataField: z.optional(z.string()),
  higherIsBetter: z.optional(z.boolean()),
  isContextual: z.optional(z.boolean()),
  metricSourceID: z.optional(z.string()),
  linkedExperimentName: z.optional(z.string()),
  goalRichText: z.optional(z.string()),
  optimizationParameter: z.optional(z.enum(['occurrence', 'value'])),
  valueColumn: z.optional(z.string()),
  featureList: z.optional(z.array(z.string())),
})

export const zBulkAssignConfigTargetAppDto = z.object({
  targetApps: z.array(z.string()).min(1),
  gates: z.optional(z.array(z.string())),
  dynamicConfigs: z.optional(z.array(z.string())),
  experiments: z.optional(z.array(z.string())),
})

export const zChangeValidationDto = z.object({
  reviewID: z.string(),
  validated: z.boolean(),
  message: z.optional(z.string()),
})

export const zChangeValidationUpdateMessageDto = z.object({
  reviewID: z.string(),
  message: z.optional(z.string()),
})

export const zCompanyInfoResponseDto = z.object({
  companyID: z.string(),
  companyName: z.string(),
  isWarehouseNative: z.boolean(),
  orgID: z.union([z.string(), z.null()]),
  orgName: z.union([z.string(), z.null()]),
})

export const zCumulativeExposureResponseDto = z.array(
  z.object({
    groupID: z.string(),
    groupName: z.string(),
    results: z.array(
      z.object({
        date: z.string(),
        exposures: z.number(),
      }),
    ),
  }),
)

export const zDynamicConfigCreateDto = z.object({
  name: z
    .string()
    .min(3)
    .max(100)
    .regex(/^[a-zA-Z0-9_\-. ]*$/),
  isEnabled: z.optional(z.boolean()).default(true),
  description: z.optional(z.string().max(1000)),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.optional(z.number().gte(0).lte(100)),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        completedAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        pendingAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        returnValueJson5: z.optional(z.string()),
        variants: z.optional(
          z.array(
            z.object({
              id: z.optional(z.string()),
              name: z.string(),
              passPercentage: z.number().gte(0).lte(100),
              returnValue: z.optional(z.record(z.string(), z.unknown())),
              returnValueJson5: z.optional(z.string()),
            }),
          ),
        ),
      }),
    ),
  ),
  defaultValue: z.optional(z.record(z.string(), z.unknown())),
  defaultValueJson5: z.optional(z.string()),
  idType: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  schema: z.optional(z.union([z.string(), z.null()])),
  schemaJson5: z.optional(z.union([z.string(), z.null()])),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
  id: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-.]*$/),
  ),
  isTemplate: z.optional(z.boolean()),
})

export const zDynamicConfigDto = z.object({
  id: z.string(),
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  idType: z.optional(z.string()),
  description: z.string().max(1000),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  tags: z.optional(z.array(z.string())),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  isEnabled: z.boolean().default(true),
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.number().gte(0).lte(100),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      returnValueJson5: z.optional(z.string()),
      variants: z.optional(
        z.array(
          z.object({
            id: z.optional(z.string()),
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            returnValueJson5: z.optional(z.string()),
          }),
        ),
      ),
    }),
  ),
  defaultValue: z.optional(z.record(z.string(), z.unknown())),
  defaultValueJson5: z.optional(z.string()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  schema: z.optional(z.union([z.string(), z.null()])),
  schemaJson5: z.optional(z.union([z.string(), z.null()])),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
  isTemplate: z.optional(z.boolean()),
})

export const zDynamicConfigFullUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  isEnabled: z.boolean().default(true),
  description: z.string().max(1000),
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.optional(z.number().gte(0).lte(100)),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      returnValueJson5: z.optional(z.string()),
      variants: z.optional(
        z.array(
          z.object({
            id: z.optional(z.string()),
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            returnValueJson5: z.optional(z.string()),
          }),
        ),
      ),
    }),
  ),
  defaultValue: z.optional(z.record(z.string(), z.unknown())),
  defaultValueJson5: z.optional(z.string()),
  idType: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  schema: z.optional(z.union([z.string(), z.null()])),
  schemaJson5: z.optional(z.union([z.string(), z.null()])),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
})

export const zDynamicConfigPartialUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  isEnabled: z.optional(z.boolean()).default(true),
  description: z.optional(z.string().max(1000)),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.optional(z.number().gte(0).lte(100)),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        completedAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        pendingAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        returnValueJson5: z.optional(z.string()),
        variants: z.optional(
          z.array(
            z.object({
              id: z.optional(z.string()),
              name: z.string(),
              passPercentage: z.number().gte(0).lte(100),
              returnValue: z.optional(z.record(z.string(), z.unknown())),
              returnValueJson5: z.optional(z.string()),
            }),
          ),
        ),
      }),
    ),
  ),
  defaultValue: z.optional(z.record(z.string(), z.unknown())),
  defaultValueJson5: z.optional(z.string()),
  idType: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  schema: z.optional(z.union([z.string(), z.null()])),
  schemaJson5: z.optional(z.union([z.string(), z.null()])),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
})

export const zDynamicConfigRuleDto = z.object({
  name: z.string(),
  passPercentage: z.number().gte(0).lte(100),
  conditions: z.array(
    z.object({
      targetValue: z.optional(z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()])),
      operator: z.optional(z.string()),
      field: z.optional(z.union([z.string(), z.null()])),
      customID: z.optional(z.union([z.string(), z.null()])),
      type: z.enum([
        'app_version',
        'browser_name',
        'browser_version',
        'country',
        'custom_field',
        'email',
        'environment_tier',
        'fails_gate',
        'fails_segment',
        'ip_address',
        'locale',
        'os_name',
        'os_version',
        'passes_gate',
        'passes_segment',
        'public',
        'time',
        'unit_id',
        'user_id',
        'url',
        'javascript',
        'device_model',
        'target_app',
      ]),
    }),
  ),
  environments: z.optional(z.union([z.array(z.string()), z.null()])),
  id: z.optional(z.string()),
  baseID: z.optional(z.string()),
  returnValue: z.optional(z.record(z.string(), z.unknown())),
  completedAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
  pendingAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
})

export const zDynamicConfigRulePartialDto = z.object({
  name: z.optional(z.string()),
  passPercentage: z.optional(z.number().gte(0).lte(100)),
  conditions: z.optional(
    z.array(
      z.object({
        targetValue: z.optional(z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()])),
        operator: z.optional(z.string()),
        field: z.optional(z.union([z.string(), z.null()])),
        customID: z.optional(z.union([z.string(), z.null()])),
        type: z.enum([
          'app_version',
          'browser_name',
          'browser_version',
          'country',
          'custom_field',
          'email',
          'environment_tier',
          'fails_gate',
          'fails_segment',
          'ip_address',
          'locale',
          'os_name',
          'os_version',
          'passes_gate',
          'passes_segment',
          'public',
          'time',
          'unit_id',
          'user_id',
          'url',
          'javascript',
          'device_model',
          'target_app',
        ]),
      }),
    ),
  ),
  environments: z.optional(z.union([z.array(z.string()), z.null()])),
  id: z.optional(z.string()),
  baseID: z.optional(z.string()),
  returnValue: z.optional(z.record(z.string(), z.unknown())),
  completedAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
  pendingAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
  returnValueJson5: z.optional(z.string()),
  variants: z.optional(
    z.array(
      z.object({
        id: z.optional(z.string()),
        name: z.string(),
        passPercentage: z.number().gte(0).lte(100),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        returnValueJson5: z.optional(z.string()),
      }),
    ),
  ),
})

export const zDynamicConfigRulesDto = z.object({
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.number().gte(0).lte(100),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
    }),
  ),
})

export const zEchidnaGateLoadPulseQueryDto = z.object({
  refresh: z.optional(z.enum(['full', 'incremental', 'metric'])),
  metricIDs: z.optional(z.array(z.string())),
  ruleId: z.string(),
  turboMode: z.optional(z.boolean()),
})

export const zEchidnaLoadPulseQueryDto = z.object({
  refresh: z.optional(z.enum(['full', 'incremental', 'metric'])),
  metricIDs: z.optional(z.array(z.string())),
  ruleId: z.optional(z.string()),
  turboMode: z.optional(z.boolean()),
})

export const zEnableDisableGroupsDto = z.object({
  group_names: z.array(z.string()),
})

export const zEntityPropertySourceCreationDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.optional(z.string()),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zEntityPropertySourceDto = z.object({
  name: z.string(),
  description: z.string(),
  tags: z.array(z.string()),
  sql: z.string(),
  timestampColumn: z.optional(z.string()),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
})

export const zEntityPropertySourcePartialUpdateDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  sql: z.optional(z.unknown().readonly()),
  timestampColumn: z.optional(z.string()),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.optional(
    z.array(
      z.object({
        statsigUnitID: z.string(),
        column: z.string(),
      }),
    ),
  ),
  isReadOnly: z.optional(z.boolean()),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zEntityPropertySourceQueryUpdateDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.optional(z.string()),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  isReadOnly: z.optional(z.boolean()),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zEnvironmentsContractDto = z.object({
  environments: z.array(
    z.object({
      name: z.string(),
      id: z.string(),
      isProduction: z.boolean(),
      requiresReview: z.boolean(),
      requiredReviewGroupID: z.optional(z.string()),
      requiresReleasePipeline: z.boolean(),
    }),
  ),
})

export const zEnvironmentsUpdateContractDto = z.object({
  environments: z.array(
    z.object({
      name: z.string(),
      id: z.optional(z.string()),
      isProduction: z.boolean(),
      requiresReview: z.boolean(),
      requiredReviewGroupID: z.optional(z.string()),
      requiresReleasePipeline: z.boolean(),
    }),
  ),
})

export const zExperimentAbandonDto = z.object({
  decisionReason: z.string(),
})

/**
 * Schema for archiving an experiment
 */
export const zExperimentArchiveDto = z.object({
  archiveReason: z.optional(z.string()),
})

/**
 * Create Experiment
 */
export const zExperimentCreateDto = z.object({
  name: z
    .string()
    .min(3)
    .max(100)
    .regex(/^[a-zA-Z0-9_\- ]*$/),
  description: z.optional(z.string().max(1000)),
  idType: z.optional(z.string()),
  secondaryIDType: z.optional(z.union([z.string(), z.null()])),
  identifierMappingMode: z.optional(z.enum(['strictOneToOne', 'firstTouchOneToMany', 'lastTouchOneToMany'])),
  identityResolutionSource: z.optional(z.union([z.string(), z.null()])),
  hypothesis: z.optional(z.string()),
  links: z.optional(
    z.array(
      z.object({
        url: z.url(),
        title: z.optional(z.string()),
      }),
    ),
  ),
  groups: z.optional(
    z.array(
      z.object({
        name: z.string(),
        id: z.optional(z.union([z.string(), z.null()])),
        size: z.number().gte(0).lte(100),
        parameterValues: z.record(z.string(), z.unknown()),
        disabled: z.optional(z.boolean()),
        description: z.optional(z.string()),
        foreignGroupID: z.optional(z.string()),
      }),
    ),
  ),
  controlGroupID: z.optional(z.string()),
  allocation: z.optional(z.number().gte(0).lte(100)),
  primaryMetricTags: z.optional(z.array(z.string())),
  secondaryMetricTags: z.optional(z.array(z.string())),
  primaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  secondaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  otherMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  tags: z.optional(z.array(z.string())),
  duration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetExposures: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetingGateID: z.optional(z.union([z.string(), z.null()])),
  sequentialTesting: z.optional(z.boolean()),
  bonferroniCorrection: z.optional(z.boolean()),
  bonferroniCorrectionPerMetric: z.optional(z.boolean()),
  benjaminiHochbergPerVariant: z.optional(z.boolean()),
  benjaminiHochbergPerMetric: z.optional(z.boolean()),
  benjaminiPrimaryMetricsOnly: z.optional(z.boolean()),
  defaultConfidenceInterval: z.optional(z.enum(['80', '90', '95', '98', '99'])),
  manualQualityScores: z.optional(
    z.array(
      z.object({
        criteriaName: z.union([
          z.literal('HYPOTHESIS_LENGTH'),
          z.literal('BALANCED_EXPOSURE'),
          z.literal('PRIMARY_METRICS_LENGTH'),
          z.literal('COMPARISON_CORRECTION'),
          z.literal('GUARDRAIL_METRIC_TAGS'),
          z.literal('SUFFICIENT_SAMPLE'),
          z.literal('POWER_ANALYSIS'),
          z.literal('SEQUENTIAL_TESTING'),
          z.string(),
        ]),
        status: z.enum(['PASSED', 'FAILED', 'WARNING']),
        criteriaDescription: z.string(),
        score: z.number(),
        weight: z.number(),
      }),
    ),
  ),
  status: z.optional(
    z.enum(['active', 'setup', 'decision_made', 'abandoned', 'archived', 'experiment_stopped', 'assignment_stopped']),
  ),
  launchedGroupID: z.optional(z.union([z.string(), z.null()])),
  assignmentSourceName: z.optional(z.string()),
  assignmentSourceExperimentName: z.optional(z.string()),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  isAnalysisOnly: z.optional(z.union([z.boolean(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  allocationDuration: z.optional(z.union([z.coerce.bigint().gt(BigInt(1)), z.null()])),
  cohortedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  cohortedMetricsMatureAfterEnd: z.optional(z.boolean()),
  cohortWaitUntilEndToInclude: z.optional(z.boolean()),
  fixedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  scheduledReloadHour: z.optional(z.union([z.coerce.bigint().gte(BigInt(0)).lte(BigInt(23)), z.null()])),
  scheduledReloadType: z.optional(z.enum(['full', 'incremental'])),
  analysisEndTime: z.optional(z.string()),
  assignmentSourceFilters: z.optional(
    z.array(
      z.object({
        column: z.optional(z.string()),
        condition: z.enum([
          'in',
          'not_in',
          '=',
          '>',
          '<',
          '>=',
          '<=',
          'is_null',
          'non_null',
          'contains',
          'not_contains',
          'sql_filter',
          'starts_with',
          'ends_with',
          'after_exposure',
          'before_exposure',
          'is_true',
          'is_false',
        ]),
        values: z.optional(z.array(z.string())),
      }),
    ),
  ),
  analyticsType: z.optional(z.enum(['frequentist', 'bayesian', 'sprt'])),
  isSidecar: z.optional(z.boolean()),
  decisionReason: z.optional(z.string()),
  id: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_-]*$/),
  ),
  layerID: z.optional(z.string()),
})

export const zExperimentFullUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\- ]*$/),
  ),
  description: z.string().max(1000),
  idType: z.string(),
  secondaryIDType: z.optional(z.union([z.string(), z.null()])),
  identifierMappingMode: z.optional(z.enum(['strictOneToOne', 'firstTouchOneToMany', 'lastTouchOneToMany'])),
  identityResolutionSource: z.optional(z.union([z.string(), z.null()])),
  hypothesis: z.string(),
  links: z.optional(
    z.array(
      z.object({
        url: z.url(),
        title: z.optional(z.string()),
      }),
    ),
  ),
  groups: z.array(
    z.object({
      name: z.string(),
      id: z.optional(z.union([z.string(), z.null()])),
      size: z.number().gte(0).lte(100),
      parameterValues: z.record(z.string(), z.unknown()),
      disabled: z.optional(z.boolean()),
      description: z.optional(z.string()),
      foreignGroupID: z.optional(z.string()),
    }),
  ),
  controlGroupID: z.optional(z.string()),
  allocation: z.number().gte(0).lte(100),
  primaryMetricTags: z.optional(z.array(z.string())),
  secondaryMetricTags: z.optional(z.array(z.string())),
  primaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  secondaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  otherMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  tags: z.optional(z.array(z.string())),
  duration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetExposures: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetingGateID: z.union([z.string(), z.null()]),
  sequentialTesting: z.optional(z.boolean()),
  bonferroniCorrection: z.boolean(),
  bonferroniCorrectionPerMetric: z.optional(z.boolean()),
  benjaminiHochbergPerVariant: z.optional(z.boolean()),
  benjaminiHochbergPerMetric: z.optional(z.boolean()),
  benjaminiPrimaryMetricsOnly: z.optional(z.boolean()),
  defaultConfidenceInterval: z.enum(['80', '90', '95', '98', '99']),
  manualQualityScores: z.optional(
    z.array(
      z.object({
        criteriaName: z.union([
          z.literal('HYPOTHESIS_LENGTH'),
          z.literal('BALANCED_EXPOSURE'),
          z.literal('PRIMARY_METRICS_LENGTH'),
          z.literal('COMPARISON_CORRECTION'),
          z.literal('GUARDRAIL_METRIC_TAGS'),
          z.literal('SUFFICIENT_SAMPLE'),
          z.literal('POWER_ANALYSIS'),
          z.literal('SEQUENTIAL_TESTING'),
          z.string(),
        ]),
        status: z.enum(['PASSED', 'FAILED', 'WARNING']),
        criteriaDescription: z.string(),
        score: z.number(),
        weight: z.number(),
      }),
    ),
  ),
  status: z.enum([
    'active',
    'setup',
    'decision_made',
    'abandoned',
    'archived',
    'experiment_stopped',
    'assignment_stopped',
  ]),
  launchedGroupID: z.optional(z.union([z.string(), z.null()])),
  assignmentSourceName: z.optional(z.string()),
  assignmentSourceExperimentName: z.optional(z.string()),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  isAnalysisOnly: z.optional(z.union([z.boolean(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  allocationDuration: z.optional(z.union([z.coerce.bigint().gt(BigInt(1)), z.null()])),
  cohortedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  cohortedMetricsMatureAfterEnd: z.optional(z.boolean()),
  cohortWaitUntilEndToInclude: z.optional(z.boolean()),
  fixedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  scheduledReloadHour: z.optional(z.union([z.coerce.bigint().gte(BigInt(0)).lte(BigInt(23)), z.null()])),
  scheduledReloadType: z.optional(z.enum(['full', 'incremental'])),
  analysisEndTime: z.optional(z.string()),
  assignmentSourceFilters: z.optional(
    z.array(
      z.object({
        column: z.optional(z.string()),
        condition: z.enum([
          'in',
          'not_in',
          '=',
          '>',
          '<',
          '>=',
          '<=',
          'is_null',
          'non_null',
          'contains',
          'not_contains',
          'sql_filter',
          'starts_with',
          'ends_with',
          'after_exposure',
          'before_exposure',
          'is_true',
          'is_false',
        ]),
        values: z.optional(z.array(z.string())),
      }),
    ),
  ),
  analyticsType: z.optional(z.enum(['frequentist', 'bayesian', 'sprt'])),
  isSidecar: z.optional(z.boolean()),
  decisionReason: z.optional(z.string()),
})

export const zExperimentOverridesDto = z.object({
  overrides: z
    .array(
      z.object({
        type: z.enum(['gate', 'segment']),
        id: z.string(),
        groupID: z.string(),
      }),
    )
    .max(1000),
  userIDOverrides: z.array(
    z.object({
      groupID: z.string(),
      ids: z.array(z.string()).max(1000),
      environment: z.optional(z.union([z.string(), z.null()])),
      unitType: z.optional(z.union([z.string(), z.null()])),
    }),
  ),
})

export const zExperimentPartialUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\- ]*$/),
  ),
  description: z.optional(z.string().max(1000)),
  idType: z.optional(z.string()),
  secondaryIDType: z.optional(z.union([z.string(), z.null()])),
  identifierMappingMode: z.optional(z.enum(['strictOneToOne', 'firstTouchOneToMany', 'lastTouchOneToMany'])),
  identityResolutionSource: z.optional(z.union([z.string(), z.null()])),
  hypothesis: z.optional(z.string()),
  links: z.optional(
    z.array(
      z.object({
        url: z.url(),
        title: z.optional(z.string()),
      }),
    ),
  ),
  groups: z.optional(
    z.array(
      z.object({
        name: z.string(),
        id: z.optional(z.union([z.string(), z.null()])),
        size: z.number().gte(0).lte(100),
        parameterValues: z.record(z.string(), z.unknown()),
        disabled: z.optional(z.boolean()),
        description: z.optional(z.string()),
        foreignGroupID: z.optional(z.string()),
      }),
    ),
  ),
  controlGroupID: z.optional(z.string()),
  allocation: z.optional(z.number().gte(0).lte(100)),
  primaryMetricTags: z.optional(z.array(z.string())),
  secondaryMetricTags: z.optional(z.array(z.string())),
  primaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  secondaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  otherMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  tags: z.optional(z.array(z.string())),
  duration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetExposures: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetingGateID: z.optional(z.union([z.string(), z.null()])),
  sequentialTesting: z.optional(z.boolean()),
  bonferroniCorrection: z.optional(z.boolean()),
  bonferroniCorrectionPerMetric: z.optional(z.boolean()),
  benjaminiHochbergPerVariant: z.optional(z.boolean()),
  benjaminiHochbergPerMetric: z.optional(z.boolean()),
  benjaminiPrimaryMetricsOnly: z.optional(z.boolean()),
  defaultConfidenceInterval: z.optional(z.enum(['80', '90', '95', '98', '99'])),
  manualQualityScores: z.optional(
    z.array(
      z.object({
        criteriaName: z.union([
          z.literal('HYPOTHESIS_LENGTH'),
          z.literal('BALANCED_EXPOSURE'),
          z.literal('PRIMARY_METRICS_LENGTH'),
          z.literal('COMPARISON_CORRECTION'),
          z.literal('GUARDRAIL_METRIC_TAGS'),
          z.literal('SUFFICIENT_SAMPLE'),
          z.literal('POWER_ANALYSIS'),
          z.literal('SEQUENTIAL_TESTING'),
          z.string(),
        ]),
        status: z.enum(['PASSED', 'FAILED', 'WARNING']),
        criteriaDescription: z.string(),
        score: z.number(),
        weight: z.number(),
      }),
    ),
  ),
  status: z.optional(
    z.enum(['active', 'setup', 'decision_made', 'abandoned', 'archived', 'experiment_stopped', 'assignment_stopped']),
  ),
  launchedGroupID: z.optional(z.union([z.string(), z.null()])),
  assignmentSourceName: z.optional(z.string()),
  assignmentSourceExperimentName: z.optional(z.string()),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  isAnalysisOnly: z.optional(z.union([z.boolean(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  allocationDuration: z.optional(z.union([z.coerce.bigint().gt(BigInt(1)), z.null()])),
  cohortedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  cohortedMetricsMatureAfterEnd: z.optional(z.boolean()),
  cohortWaitUntilEndToInclude: z.optional(z.boolean()),
  fixedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  scheduledReloadHour: z.optional(z.union([z.coerce.bigint().gte(BigInt(0)).lte(BigInt(23)), z.null()])),
  scheduledReloadType: z.optional(z.enum(['full', 'incremental'])),
  analysisEndTime: z.optional(z.string()),
  assignmentSourceFilters: z.optional(
    z.array(
      z.object({
        column: z.optional(z.string()),
        condition: z.enum([
          'in',
          'not_in',
          '=',
          '>',
          '<',
          '>=',
          '<=',
          'is_null',
          'non_null',
          'contains',
          'not_contains',
          'sql_filter',
          'starts_with',
          'ends_with',
          'after_exposure',
          'before_exposure',
          'is_true',
          'is_false',
        ]),
        values: z.optional(z.array(z.string())),
      }),
    ),
  ),
  analyticsType: z.optional(z.enum(['frequentist', 'bayesian', 'sprt'])),
  isSidecar: z.optional(z.boolean()),
  decisionReason: z.optional(z.string()),
})

export const zExperimentPulseResultsDto = z.object({
  ds: z.string(),
  primaryMetrics: z.array(
    z.object({
      metricID: z.string(),
      metricName: z.string(),
      directionality: z.enum(['increase', 'decrease']),
      absoluteChange: z.optional(z.number()),
      confidenceIntervalDelta: z.optional(z.number()),
      percentChange: z.optional(z.number()),
      sequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      percentConfidenceIntervalDelta: z.optional(z.number()),
      percentSequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      testMean: z.optional(z.number()),
      controlMean: z.optional(z.number()),
      testStd: z.optional(z.number()),
      controlStd: z.optional(z.number()),
      testUnits: z.optional(z.number()),
      controlUnits: z.optional(z.number()),
      pValue: z.optional(z.number()),
      absoluteToplineImpact: z.optional(z.number()),
      absoluteToplineImpactDelta: z.optional(z.number()),
      relativeToplineImpact: z.optional(z.number()),
      relativeToplineImpactDelta: z.optional(z.number()),
      projectedAbsoluteToplineImpact: z.optional(z.number()),
      projectedAbsoluteToplineImpactDelta: z.optional(z.number()),
      projectedRelativeToplineImpact: z.optional(z.number()),
      projectedRelativeToplineImpactDelta: z.optional(z.number()),
    }),
  ),
  secondaryMetrics: z.array(
    z.object({
      metricID: z.string(),
      metricName: z.string(),
      directionality: z.enum(['increase', 'decrease']),
      absoluteChange: z.optional(z.number()),
      confidenceIntervalDelta: z.optional(z.number()),
      percentChange: z.optional(z.number()),
      sequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      percentConfidenceIntervalDelta: z.optional(z.number()),
      percentSequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      testMean: z.optional(z.number()),
      controlMean: z.optional(z.number()),
      testStd: z.optional(z.number()),
      controlStd: z.optional(z.number()),
      testUnits: z.optional(z.number()),
      controlUnits: z.optional(z.number()),
      pValue: z.optional(z.number()),
      absoluteToplineImpact: z.optional(z.number()),
      absoluteToplineImpactDelta: z.optional(z.number()),
      relativeToplineImpact: z.optional(z.number()),
      relativeToplineImpactDelta: z.optional(z.number()),
      projectedAbsoluteToplineImpact: z.optional(z.number()),
      projectedAbsoluteToplineImpactDelta: z.optional(z.number()),
      projectedRelativeToplineImpact: z.optional(z.number()),
      projectedRelativeToplineImpactDelta: z.optional(z.number()),
    }),
  ),
  otherMetrics: z.optional(
    z.array(
      z.object({
        metricID: z.string(),
        metricName: z.string(),
        directionality: z.enum(['increase', 'decrease']),
        absoluteChange: z.optional(z.number()),
        confidenceIntervalDelta: z.optional(z.number()),
        percentChange: z.optional(z.number()),
        sequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
        percentConfidenceIntervalDelta: z.optional(z.number()),
        percentSequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
        testMean: z.optional(z.number()),
        controlMean: z.optional(z.number()),
        testStd: z.optional(z.number()),
        controlStd: z.optional(z.number()),
        testUnits: z.optional(z.number()),
        controlUnits: z.optional(z.number()),
        pValue: z.optional(z.number()),
        absoluteToplineImpact: z.optional(z.number()),
        absoluteToplineImpactDelta: z.optional(z.number()),
        relativeToplineImpact: z.optional(z.number()),
        relativeToplineImpactDelta: z.optional(z.number()),
        projectedAbsoluteToplineImpact: z.optional(z.number()),
        projectedAbsoluteToplineImpactDelta: z.optional(z.number()),
        projectedRelativeToplineImpact: z.optional(z.number()),
        projectedRelativeToplineImpactDelta: z.optional(z.number()),
      }),
    ),
  ),
})

export const zExperimentStartDto = z.object({
  analysisStartTime: z.optional(z.string()),
  analysisEndTime: z.optional(z.string()),
})

/**
 * Schema for updating the status of an experiment
 */
export const zExperimentStatusUpdateDto = z.object({
  id: z.string(),
  decisionReason: z.string(),
  removeTargeting: z.optional(z.boolean()).default(false),
})

export const zExposureCountDto = z.object({
  gates: z
    .array(
      z.object({
        id: z.string(),
        pastDay: z.number(),
        past7Days: z.number(),
      }),
    )
    .max(25),
  experiments: z
    .array(
      z.object({
        id: z.string(),
        pastDay: z.number(),
        past7Days: z.number(),
      }),
    )
    .max(25),
  dynamicConfigs: z
    .array(
      z.object({
        id: z.string(),
        pastDay: z.number(),
        past7Days: z.number(),
      }),
    )
    .max(25),
})

export const zExternalExperimentDto = z.object({
  reviewSettings: z.optional(
    z.object({
      requiredReview: z.boolean(),
      allowedReviewers: z.optional(
        z.union([
          z.array(
            z.object({
              id: z.string(),
              name: z.string(),
              email: z.string(),
            }),
          ),
          z.null(),
        ]),
      ),
    }),
  ),
  activeReview: z.optional(
    z.object({
      reviewID: z.string(),
      reviewStatus: z.string(),
      description: z.string(),
    }),
  ),
  id: z.string(),
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\- ]*$/),
  ),
  idType: z.string(),
  description: z.string().max(1000),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  tags: z.array(z.string()),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  secondaryIDType: z.optional(z.union([z.string(), z.null()])),
  identifierMappingMode: z.optional(z.enum(['strictOneToOne', 'firstTouchOneToMany', 'lastTouchOneToMany'])),
  identityResolutionSource: z.optional(z.union([z.string(), z.null()])),
  hypothesis: z.string(),
  links: z.optional(
    z.array(
      z.object({
        url: z.url(),
        title: z.optional(z.string()),
      }),
    ),
  ),
  groups: z.array(
    z.object({
      name: z.string(),
      id: z.optional(z.union([z.string(), z.null()])),
      size: z.number().gte(0).lte(100),
      parameterValues: z.record(z.string(), z.unknown()),
      disabled: z.optional(z.boolean()),
      description: z.optional(z.string()),
      foreignGroupID: z.optional(z.string()),
    }),
  ),
  controlGroupID: z.optional(z.string()),
  allocation: z.number().gte(0).lte(100),
  primaryMetricTags: z.optional(z.array(z.string())),
  secondaryMetricTags: z.optional(z.array(z.string())),
  primaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      direction: z.optional(z.enum(['increase', 'decrease'])),
      hypothesizedValue: z.optional(z.number()),
    }),
  ),
  secondaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      direction: z.optional(z.enum(['increase', 'decrease'])),
      hypothesizedValue: z.optional(z.number()),
    }),
  ),
  otherMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        direction: z.optional(z.enum(['increase', 'decrease'])),
        hypothesizedValue: z.optional(z.number()),
      }),
    ),
  ),
  duration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetExposures: z.optional(z.coerce.bigint().gt(BigInt(1))),
  targetingGateID: z.union([z.string(), z.null()]),
  sequentialTesting: z.optional(z.boolean()),
  bonferroniCorrection: z.boolean(),
  bonferroniCorrectionPerMetric: z.optional(z.boolean()),
  benjaminiHochbergPerVariant: z.optional(z.boolean()),
  benjaminiHochbergPerMetric: z.optional(z.boolean()),
  benjaminiPrimaryMetricsOnly: z.optional(z.boolean()),
  defaultConfidenceInterval: z.enum(['80', '90', '95', '98', '99']),
  manualQualityScores: z.optional(
    z.array(
      z.object({
        criteriaName: z.union([
          z.literal('HYPOTHESIS_LENGTH'),
          z.literal('BALANCED_EXPOSURE'),
          z.literal('PRIMARY_METRICS_LENGTH'),
          z.literal('COMPARISON_CORRECTION'),
          z.literal('GUARDRAIL_METRIC_TAGS'),
          z.literal('SUFFICIENT_SAMPLE'),
          z.literal('POWER_ANALYSIS'),
          z.literal('SEQUENTIAL_TESTING'),
          z.string(),
        ]),
        status: z.enum(['PASSED', 'FAILED', 'WARNING']),
        criteriaDescription: z.string(),
        score: z.number(),
        weight: z.number(),
      }),
    ),
  ),
  status: z.enum([
    'active',
    'setup',
    'decision_made',
    'abandoned',
    'archived',
    'experiment_stopped',
    'assignment_stopped',
  ]),
  launchedGroupID: z.optional(z.union([z.string(), z.null()])),
  assignmentSourceName: z.optional(z.string()),
  assignmentSourceExperimentName: z.optional(z.string()),
  isAnalysisOnly: z.optional(z.boolean()),
  allocationDuration: z.optional(z.union([z.coerce.bigint().gt(BigInt(1)), z.null()])),
  cohortedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  cohortedMetricsMatureAfterEnd: z.optional(z.boolean()),
  cohortWaitUntilEndToInclude: z.optional(z.boolean()),
  fixedAnalysisDuration: z.optional(z.coerce.bigint().gt(BigInt(1))),
  scheduledReloadHour: z.optional(z.union([z.coerce.bigint().gte(BigInt(0)).lte(BigInt(23)), z.null()])),
  scheduledReloadType: z.optional(z.enum(['full', 'incremental'])),
  analysisEndTime: z.optional(z.string()),
  assignmentSourceFilters: z.optional(
    z.array(
      z.object({
        column: z.optional(z.string()),
        condition: z.enum([
          'in',
          'not_in',
          '=',
          '>',
          '<',
          '>=',
          '<=',
          'is_null',
          'non_null',
          'contains',
          'not_contains',
          'sql_filter',
          'starts_with',
          'ends_with',
          'after_exposure',
          'before_exposure',
          'is_true',
          'is_false',
        ]),
        values: z.optional(z.array(z.string())),
      }),
    ),
  ),
  analyticsType: z.optional(z.union([z.string(), z.null()])),
  isSidecar: z.optional(z.boolean()),
  decisionReason: z.union([z.string(), z.null()]),
  subtype: z.optional(z.enum(['conversion', 'reactivation', 'retention'])),
  externalExperimentName: z.optional(z.string()),
  layerID: z.union([z.string(), z.null()]),
  startTime: z.union([z.number(), z.null()]),
  endTime: z.union([z.number(), z.null()]),
  decisionTime: z.union([z.number(), z.null()]),
  healthChecks: z.optional(
    z.array(
      z.object({
        name: z.string(),
        description: z.string(),
        status: z.enum(['PASSED', 'FAILED', 'WAITING', 'WARNING']),
        metadata: z.optional(
          z.object({
            type: z.string(),
            lastPulseLoadTime: z.optional(z.number()),
            crossoverPercent: z.optional(z.number()),
            assignmentSourceID: z.optional(z.string()),
            assignmentSourceName: z.optional(z.string()),
            foreignExperimentID: z.optional(z.string()),
            deduplication_rate: z.optional(z.number()),
            deduplication_rates: z.optional(
              z.array(
                z.object({
                  group_id: z.string(),
                  rate: z.number(),
                  group_name: z.string(),
                }),
              ),
            ),
            primary_id_type: z.string(),
            secondary_id_type: z.optional(z.string()),
            missingMetrics: z.optional(z.array(z.string())),
            metrics: z.optional(
              z.array(
                z.object({
                  metric_name: z.string(),
                  earliest_date: z.union([z.iso.datetime(), z.null()]),
                  latest_date: z.union([z.iso.datetime(), z.null()]),
                }),
              ),
            ),
            lastUpdatedDs: z.optional(z.string()),
          }),
        ),
        type: z.optional(
          z.enum([
            'has_checks',
            'has_valid_unit_type',
            'has_balanced_exposures',
            'has_event_metrics',
            'has_pulse_metrics',
            'assignment_health',
            'has_crossover',
            'has_exposures',
            'has_recent_exposures_for_analyze_whn',
            'user_metrics_exist',
            'deduplication_rate',
            'deduplication_rate_group_level',
            'windowed_metrics_have_outliers',
            'exposures_data_is_behind',
            'pre_experimental_bias_check',
            'segments_of_interest_analysis',
            'has_changed_parameter',
            'metric_history_for_topline_impact',
            'default_value_mismatch',
            'has_data_gaps',
            'has_correct_target_app',
            'has_dag_failures',
            'has_exploration_completed',
            'autotune_has_outcomes',
          ]),
        ),
      }),
    ),
  ),
  healthCheckStatus: z.enum(['PASSED', 'FAILED', 'WAITING', 'WARNING']),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  inlineTargetingRulesJSON: z.optional(z.union([z.string(), z.null()])),
  summarySections: z.optional(
    z.union([
      z.array(
        z.object({
          name: z.string(),
          content: z.union([z.string(), z.null()]),
        }),
      ),
      z.null(),
    ]),
  ),
})

export const zExternalGateDto = z.object({
  id: z.string(),
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  idType: z.optional(z.string()),
  description: z.string().max(1000),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  tags: z.optional(z.array(z.string())),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  checksPerHour: z.union([z.number(), z.null()]),
  status: z.enum(['In Progress', 'Launched', 'Disabled', 'Archived']),
  type: z.enum(['TEMPORARY', 'PERMANENT', 'STALE', 'TEMPLATE']),
  typeReason: z.enum([
    'NONE',
    'STALE_PROBABLY_LAUNCHED',
    'STALE_PROBABLY_UNLAUNCHED',
    'STALE_PROBABLY_FORGOTTEN',
    'STALE_NO_RULES',
    'STALE_PROBABLY_DEAD_CHECK',
    'STALE_EMPTY_CHECKS',
    'STALE_ALL_TRUE',
    'STALE_ALL_FALSE',
  ]),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  isTemplate: z.optional(z.boolean()),
  isEnabled: z.boolean(),
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.number().gte(0).lte(100),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
    }),
  ),
  measureMetricLifts: z.optional(z.boolean()),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  reviewSettings: z.optional(
    z.object({
      requiredReview: z.boolean(),
      allowedReviewers: z.optional(
        z.union([
          z.array(
            z.object({
              id: z.string(),
              name: z.string(),
              email: z.string(),
            }),
          ),
          z.null(),
        ]),
      ),
    }),
  ),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
  activeReview: z.optional(
    z.object({
      reviewID: z.string(),
      reviewStatus: z.string(),
      description: z.string(),
    }),
  ),
})

/**
 * Array of event criteria for defining filtering conditions in metrics analysis.
 */
export const zMetricEventsCriteriaDto = z.object({
  type: z.enum(['value', 'metadata', 'user', 'user_custom']),
  column: z.optional(z.string()),
  condition: z.enum([
    'in',
    'not_in',
    '=',
    '>',
    '<',
    '>=',
    '<=',
    'is_null',
    'non_null',
    'contains',
    'not_contains',
    'sql_filter',
    'starts_with',
    'ends_with',
    'after_exposure',
    'before_exposure',
    'is_true',
    'is_false',
  ]),
  values: z.optional(z.array(z.string())),
  nullVacuousOverride: z.optional(z.boolean()),
})

export const zExternalMetricDefinitionContractDto = z.object({
  name: z.string(),
  type: z.enum([
    'ratio',
    'sum',
    'composite',
    'mean',
    'event_count_custom',
    'event_user',
    'funnel',
    'undefined',
    'setup_incomplete',
    'composite_sum',
    'import_window',
    'user_warehouse',
    'count_distinct',
  ]),
  isVerified: z.optional(z.boolean()),
  isReadOnly: z.optional(z.boolean()),
  unitTypes: z.optional(z.array(z.string())),
  metricEvents: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.optional(z.enum(['count', 'count_distinct', 'value', 'metadata'])),
        metadataKey: z.optional(z.string()),
        criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      }),
    ),
  ),
  metricComponentMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  description: z.optional(z.string()),
  directionality: z.enum(['increase', 'decrease']),
  tags: z.optional(z.array(z.string())),
  isPermanent: z.optional(z.boolean()),
  rollupTimeWindow: z.optional(z.string()),
  customRollUpStart: z.optional(z.number()),
  customRollUpEnd: z.optional(z.number()),
  funnelEventList: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.enum(['event_dau', 'event_user', 'event_count', 'event_count_custom']),
      }),
    ),
  ),
  funnelCountDistinct: z.optional(z.enum(['events', 'users'])),
  warehouseNative: z.optional(
    z.object({
      aggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      metricSourceName: z.optional(z.string()),
      criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      waitForCohortWindow: z.optional(z.boolean()),
      denominatorCriteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      denominatorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      denominatorCustomRollupEnd: z.optional(z.number()),
      denominatorCustomRollupStart: z.optional(z.number()),
      denominatorMetricSourceName: z.optional(z.string()),
      denominatorRollupTimeWindow: z.optional(z.string()),
      denominatorValueColumn: z.optional(z.string()),
      funnelCalculationWindow: z.optional(z.number()),
      funnelCountDistinct: z.optional(z.enum(['sessions', 'users'])),
      funnelEvents: z.optional(
        z.array(
          z.object({
            criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
            metricSourceName: z.optional(z.string()),
            name: z.optional(z.union([z.string(), z.null()])),
            sessionIdentifierField: z.optional(z.union([z.string(), z.null()])),
          }),
        ),
      ),
      funnelStartCriteria: z.optional(z.enum(['start_event', 'exposure'])),
      metricDimensionColumns: z.optional(z.array(z.string())),
      metricBakeDays: z.optional(z.number()),
      numeratorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      valueColumn: z.optional(z.string()),
      valueThreshold: z.optional(z.number()),
      allowNullRatioDenominator: z.optional(z.boolean()),
      funnelStrictOrdering: z.optional(z.boolean()),
      funnelUseExposureAsFirstEvent: z.optional(z.boolean()),
      funnelTimestampAllowanceMs: z.optional(z.number()),
      funnelTimeToConvert: z.optional(z.boolean()),
      winsorizationHigh: z.optional(z.number().gte(0).lte(1)),
      winsorizationLow: z.optional(z.number().gte(0).lte(1)),
      winsorizationHighDenominator: z.optional(z.number().gte(0).lte(1)),
      winsorizationLowDenominator: z.optional(z.number().gte(0).lte(1)),
      cupedAttributionWindow: z.optional(z.union([z.number(), z.null()])),
      rollupTimeWindow: z.optional(z.string()),
      customRollUpStart: z.optional(z.number()),
      customRollUpEnd: z.optional(z.number()),
      onlyIncludeUsersWithConversionEvent: z.optional(z.boolean()),
      denominatorCustomRollupMeasureInMinutes: z.optional(z.boolean()),
      customRollupMeasureInMinutes: z.optional(z.boolean()),
      percentile: z.optional(z.number()),
      useLogTransform: z.optional(z.boolean()),
      useSecondaryRetentionEvent: z.optional(z.boolean()),
      retentionEnd: z.optional(z.number()),
      retentionLength: z.optional(z.number()),
      logTransformBase: z.optional(z.union([z.number(), z.null()])),
      cap: z.optional(z.number()),
      surrogateMetricMSE: z.optional(z.union([z.number(), z.null()])),
    }),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
  id: z.string(),
  isHidden: z.optional(z.boolean()),
  lineage: z.object({
    events: z.array(z.string()),
    metrics: z.array(z.string()),
  }),
  creatorName: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  createdTime: z.optional(z.number()),
  lastModifierID: z.optional(z.union([z.string(), z.null()])),
  lastModifiedTime: z.optional(z.union([z.number(), z.null()])),
  lastModifierEmail: z.optional(z.union([z.string(), z.null()])),
  lastModifierName: z.optional(z.union([z.string(), z.null()])),
  owner: z.optional(
    z.object({
      ownerID: z.optional(z.string()),
      ownerType: z.optional(z.string()),
      ownerName: z.optional(z.string()),
      ownerEmail: z.optional(z.string()),
      name: z.string(),
    }),
  ),
})

/**
 * Create a new gate
 */
export const zGateCreateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  isEnabled: z.optional(z.boolean()),
  description: z.optional(z.string().max(1000)),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.number().gte(0).lte(100),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        completedAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        pendingAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
      }),
    ),
  ),
  tags: z.optional(z.array(z.string())),
  type: z.optional(z.enum(['PERMANENT', 'TEMPORARY'])),
  idType: z.optional(z.string()),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  measureMetricLifts: z.optional(z.boolean()),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  reviewSettings: z.optional(
    z.object({
      requiredReview: z.boolean(),
    }),
  ),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
  id: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-.]*$/),
  ),
  isTemplate: z.optional(z.boolean()),
})

export const zGateFullUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  isEnabled: z.boolean(),
  description: z.string().max(1000),
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.number().gte(0).lte(100),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
    }),
  ),
  tags: z.optional(z.array(z.string())),
  type: z.optional(z.enum(['PERMANENT', 'TEMPORARY'])),
  idType: z.optional(z.string()),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  measureMetricLifts: z.optional(z.boolean()),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  reviewSettings: z.optional(
    z.object({
      requiredReview: z.boolean(),
    }),
  ),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
})

export const zGatePartialUpdateDto = z.object({
  name: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_\-. ]*$/),
  ),
  isEnabled: z.optional(z.boolean()),
  description: z.optional(z.string().max(1000)),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.number().gte(0).lte(100),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        completedAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        pendingAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
      }),
    ),
  ),
  tags: z.optional(z.array(z.string())),
  type: z.optional(z.enum(['PERMANENT', 'TEMPORARY'])),
  idType: z.optional(z.string()),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  measureMetricLifts: z.optional(z.boolean()),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  reviewSettings: z.optional(
    z.object({
      requiredReview: z.boolean(),
    }),
  ),
  releasePipelineID: z.optional(z.union([z.string(), z.null()])),
})

export const zGatePulseResultsDto = z.object({
  ds: z.string(),
  monitoringMetrics: z.array(
    z.object({
      metricID: z.string(),
      metricName: z.string(),
      directionality: z.enum(['increase', 'decrease']),
      absoluteChange: z.optional(z.number()),
      confidenceIntervalDelta: z.optional(z.number()),
      percentChange: z.optional(z.number()),
      sequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      percentConfidenceIntervalDelta: z.optional(z.number()),
      percentSequentialTestingConfidenceIntervalDelta: z.optional(z.number()),
      testMean: z.optional(z.number()),
      controlMean: z.optional(z.number()),
      testStd: z.optional(z.number()),
      controlStd: z.optional(z.number()),
      testUnits: z.optional(z.number()),
      controlUnits: z.optional(z.number()),
      pValue: z.optional(z.number()),
      absoluteToplineImpact: z.optional(z.number()),
      absoluteToplineImpactDelta: z.optional(z.number()),
      relativeToplineImpact: z.optional(z.number()),
      relativeToplineImpactDelta: z.optional(z.number()),
      projectedAbsoluteToplineImpact: z.optional(z.number()),
      projectedAbsoluteToplineImpactDelta: z.optional(z.number()),
      projectedRelativeToplineImpact: z.optional(z.number()),
      projectedRelativeToplineImpactDelta: z.optional(z.number()),
    }),
  ),
})

export const zGateRulesDto = z.object({
  rules: z.array(z.record(z.string(), z.unknown())),
})

export const zHoldoutCreateContractDto = z.object({
  name: z
    .string()
    .min(3)
    .max(100)
    .regex(/^[a-zA-Z0-9_\- ]*$/),
  description: z.optional(z.string().max(1000)),
  idType: z.optional(z.string()),
  teamID: z.optional(z.union([z.string(), z.null()])),
})

export const zHoldoutDto = z.object({
  id: z.string(),
  name: z.optional(z.string()),
  idType: z.string(),
  description: z.string().max(1000),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.union([z.string(), z.null()]),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.union([z.string(), z.null()]),
  tags: z.optional(z.array(z.string())),
  targetApps: z.optional(z.array(z.string())),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  isEnabled: z.boolean(),
  passPercentage: z.number().gte(0).lte(10),
  gateIDs: z.array(z.string()),
  experimentIDs: z.array(z.string()),
  layerIDs: z.array(z.string()),
  isGlobal: z.boolean(),
  targetingGateID: z.union([z.string(), z.null()]),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
})

export const zHoldoutFullUpdateContractDto = z.object({
  isEnabled: z.boolean(),
  description: z.string().max(1000),
  passPercentage: z.number().gte(0).lte(10),
  gateIDs: z.array(z.string()),
  experimentIDs: z.array(z.string()),
  layerIDs: z.array(z.string()),
  isGlobal: z.boolean(),
  targetingGateID: z.union([z.string(), z.null()]),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
})

export const zHoldoutPartialUpdateContractDto = z.object({
  isEnabled: z.optional(z.boolean()),
  description: z.optional(z.string().max(1000)),
  passPercentage: z.optional(z.number().gte(0).lte(10)),
  gateIDs: z.optional(z.array(z.string())),
  experimentIDs: z.optional(z.array(z.string())),
  layerIDs: z.optional(z.array(z.string())),
  isGlobal: z.optional(z.boolean()),
  targetingGateID: z.optional(z.union([z.string(), z.null()])),
  monitoringMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
})

/**
 * Schema for a list of IDs with a name and count
 */
export const zIdListDto = z.object({
  name: z.string(),
  count: z.number(),
  ids: z.array(z.string()),
})

export const zIdListMetadataDto = z.object({
  currentVersion: z.optional(z.number()),
  isUpdating: z.optional(z.boolean()),
})

export const zIngestionBackfillContractDto = z.object({
  datestamp_start: z.string(),
  datestamp_end: z.string(),
  type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
  source: z.optional(z.union([z.string(), z.array(z.string()), z.null()])),
  dataset: z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties']),
})

export const zIngestionBackfillDataDto = z.object({
  runID: z.string(),
})

export const zIngestionCreateDatabricksConnectionContractDto = z.object({
  token: z.string(),
  host: z.string(),
  path: z.string(),
  deltaSharingCredentials: z.optional(z.string()),
  verified: z.optional(z.boolean()),
})

export const zIngestionDto = z.object({
  id: z.string(),
  type: z.string(),
  enabled: z.boolean(),
  data: z.record(z.string(), z.unknown()),
})

export const zIngestionEventCountResponseDto = z.union([
  z.array(
    z.object({
      date: z.string(),
      event: z.string(),
      count: z.number(),
      last_updated_time: z.iso.datetime(),
    }),
  ),
  z.array(
    z.object({
      date: z.string(),
      events: z.array(
        z.object({
          event: z.string(),
          count: z.number(),
          last_updated_time: z.iso.datetime(),
        }),
      ),
    }),
  ),
])

export const zIngestionEventDeltaResponseDto = z.union([
  z.array(
    z.object({
      date: z.string(),
      source: z.string(),
      event: z.string(),
      internal_count: z.number(),
      external_count: z.number(),
      has_diff: z.boolean(),
      threshold: z.number(),
      last_updated_time: z.iso.datetime(),
    }),
  ),
  z.array(
    z.object({
      date: z.string(),
      events: z.array(
        z.object({
          source: z.string(),
          event: z.string(),
          internal_count: z.number(),
          external_count: z.number(),
          has_diff: z.boolean(),
          threshold: z.number(),
          last_updated_time: z.iso.datetime(),
        }),
      ),
    }),
  ),
])

export const zIngestionRunDataContractDto = z.object({
  runID: z.string(),
  latestStatus: z.string(),
  lastUpdatedAt: z.iso.datetime(),
  createdAt: z.iso.datetime(),
  trigger: z.string(),
  sources: z.array(z.string()),
  dateStamps: z.array(z.string()),
  runHistory: z.array(
    z.object({
      statusTimestamp: z.iso.datetime(),
      status: z.string(),
    }),
  ),
  granularHistory: z.array(
    z.object({
      source: z.string(),
      latestSourceStatus: z.string(),
      statusByDate: z.array(
        z.object({
          dateStamp: z.string(),
          statuses: z.array(
            z.object({
              statusTimestamp: z.iso.datetime(),
              status: z.string(),
            }),
          ),
        }),
      ),
    }),
  ),
})

export const zIngestionScheduleDto = z.object({
  dataset: z.string(),
  scheduled_hour_pst: z.number(),
})

export const zIngestionScheduleUpdateContractDto = z.object({
  dataset: z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties']),
  scheduled_hour_pst: z.optional(z.number().gte(0).lte(23)).default(10),
})

export const zIngestionSourceCreateContractDto = z.union([
  z.object({
    dataset: z.enum(['Metrics']),
    column_mapping: z.optional(
      z.object({
        unit_id: z.string(),
        id_type: z.string(),
        dateid: z.string(),
        metric_name: z.string(),
        metric_value: z.optional(z.string()).default('null'),
        numerator: z.optional(z.string()).default('null'),
        denominator: z.optional(z.string()).default('null'),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.string(),
    query: z.optional(z.string()),
    use_delta_sharing: z.optional(z.unknown()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
  z.object({
    dataset: z.enum(['Events']),
    column_mapping: z.optional(
      z.object({
        unit_id: z.optional(z.string()),
        event_name: z.string(),
        timestamp: z.string(),
        ids: z.record(z.string(), z.string()).default({}),
        metadata: z.optional(z.record(z.string(), z.string())).default({}),
        metadata_object: z.optional(z.string()).default('null'),
        event_value: z.optional(z.string()).default(''),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.string(),
    query: z.optional(z.string()),
    use_delta_sharing: z.optional(z.unknown()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
  z.object({
    dataset: z.enum(['Exposures', 'export_exposures']),
    column_mapping: z.optional(
      z.object({
        experiment: z.string(),
        group_id: z.string(),
        unit_id: z.optional(z.string()),
        timestamp: z.string(),
        ids: z.record(z.string(), z.string()).default({}),
        metadata: z.optional(z.record(z.string(), z.string())).default({}),
        metadata_object: z.optional(z.string()).default('null'),
        event_value: z.optional(z.string()).default(''),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.string(),
    query: z.optional(z.string()),
    use_delta_sharing: z.optional(z.unknown()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
])

export const zIngestionStatusDto = z.object({
  ds: z.optional(z.iso.datetime()),
  ingestion_dataset: z.union([z.string(), z.null()]),
  ingestion_source: z.union([z.string(), z.null()]),
  source_name: z.union([z.string(), z.null()]),
  message: z.union([z.string(), z.null()]),
  status: z.union([z.string(), z.null()]),
  rowCount: z.optional(z.number()),
  metricCount: z.optional(z.number()),
  timestamp: z.union([z.iso.datetime(), z.null()]),
})

export const zIngestionUpdateContractDto = z.union([
  z.object({
    dataset: z.enum(['Metrics']),
    column_mapping: z.optional(
      z.object({
        unit_id: z.string(),
        id_type: z.string(),
        dateid: z.string(),
        metric_name: z.string(),
        metric_value: z.optional(z.string()).default('null'),
        numerator: z.optional(z.string()).default('null'),
        denominator: z.optional(z.string()).default('null'),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.optional(z.string()),
    query: z.optional(z.string()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
  z.object({
    dataset: z.enum(['Events']),
    column_mapping: z.optional(
      z.object({
        unit_id: z.optional(z.string()),
        event_name: z.string(),
        timestamp: z.string(),
        ids: z.record(z.string(), z.string()).default({}),
        metadata: z.optional(z.record(z.string(), z.string())).default({}),
        metadata_object: z.optional(z.string()).default('null'),
        event_value: z.optional(z.string()).default(''),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.optional(z.string()),
    query: z.optional(z.string()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
  z.object({
    dataset: z.enum(['Exposures', 'export_exposures']),
    column_mapping: z.optional(
      z.object({
        experiment: z.string(),
        group_id: z.string(),
        unit_id: z.optional(z.string()),
        timestamp: z.string(),
        ids: z.record(z.string(), z.string()).default({}),
        metadata: z.optional(z.record(z.string(), z.string())).default({}),
        metadata_object: z.optional(z.string()).default('null'),
        event_value: z.optional(z.string()).default(''),
      }),
    ),
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    source_name: z.optional(z.string()),
    query: z.optional(z.string()),
    share: z.optional(z.string()),
    schema: z.optional(z.string()),
    table: z.optional(z.string()),
    enabled: z.optional(z.boolean()),
  }),
])

export const zKeyCreateContractDto = z.object({
  description: z.string().max(1000),
  type: z.enum(['SERVER', 'CLIENT', 'CONSOLE', 'SCIM']),
  scopes: z.optional(
    z.array(
      z.enum([
        'omni_read_only',
        'omni_read_write',
        'client_download_config_specs',
        'none_hash_enabled',
        'can_access_keys',
        'client_can_write_user_store',
        'personal_read_only',
        'personal_read_write',
      ]),
    ),
  ),
  environments: z.optional(z.array(z.string())),
  targetAppID: z.optional(z.string()),
  secondaryTargetAppIDs: z.optional(z.array(z.string())),
})

export const zKeyDto = z.object({
  key: z.union([z.string(), z.null()]),
  type: z.enum(['SERVER', 'CLIENT', 'CONSOLE', 'SCIM']),
  description: z.string(),
  scopes: z.array(
    z.enum([
      'omni_read_only',
      'omni_read_write',
      'client_download_config_specs',
      'none_hash_enabled',
      'can_access_keys',
      'client_can_write_user_store',
      'personal_read_only',
      'personal_read_write',
    ]),
  ),
  environments: z.optional(z.array(z.string())),
  primaryTargetApp: z.optional(z.union([z.string(), z.null()])),
  secondaryTargetApps: z.optional(z.union([z.array(z.string()), z.null()])),
  status: z.enum(['active', 'deactivated']),
})

export const zKeyUpdateContractDto = z.object({
  description: z.optional(z.string().max(1000)),
  scopes: z.optional(
    z.array(
      z.enum([
        'omni_read_only',
        'omni_read_write',
        'client_download_config_specs',
        'none_hash_enabled',
        'can_access_keys',
        'client_can_write_user_store',
        'personal_read_only',
        'personal_read_write',
      ]),
    ),
  ),
  environments: z.optional(z.array(z.string())),
  targetAppID: z.optional(z.union([z.string(), z.null()])),
  secondaryTargetAppIDs: z.optional(z.union([z.array(z.string()), z.null()])),
})

export const zLayerContractDto = z.object({
  id: z.string(),
  name: z.optional(z.string()),
  idType: z.string(),
  description: z.string().max(1000),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.union([z.string(), z.null()]),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.union([z.string(), z.null()]),
  tags: z.optional(z.array(z.string())),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
  isImplicitLayer: z.boolean(),
  parameters: z.array(
    z.object({
      name: z.string(),
      type: z.enum(['string', 'number', 'boolean', 'object', 'array']),
      defaultValue: z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.record(z.string(), z.unknown()),
        z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.string(), z.unknown())])),
      ]),
    }),
  ),
})

export const zLayerCreateContractDto = z.object({
  name: z
    .string()
    .min(3)
    .max(100)
    .regex(/^[A-Za-z0-9_ -]*$/),
  description: z.optional(z.string().max(1000)),
  idType: z.string(),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
  team: z.optional(z.string()),
})

export const zLayerFullUpdateContractDto = z.object({
  description: z.string().max(1000),
  parameters: z.array(
    z.object({
      name: z.string(),
      type: z.enum(['string', 'number', 'boolean', 'object', 'array']),
      defaultValue: z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.record(z.string(), z.unknown()),
        z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.string(), z.unknown())])),
      ]),
    }),
  ),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
})

export const zLayerOverridesDto = z.object({
  conditionalOverrides: z.array(
    z.object({
      type: z.string(),
      name: z.string(),
      experimentName: z.string(),
      groupName: z.string(),
    }),
  ),
  idOverrides: z.array(
    z.object({
      groupName: z.string(),
      ids: z.array(z.string()),
      idType: z.optional(z.union([z.string(), z.null()])),
      environment: z.optional(z.union([z.string(), z.null()])),
      experimentName: z.optional(z.union([z.string(), z.null()])),
    }),
  ),
})

export const zLayerOverridesPatchDto = z.object({
  op: z.enum(['add']),
  conditionalOverrides: z.array(
    z.object({
      type: z.string(),
      name: z.string(),
      experimentName: z.string(),
      groupName: z.string(),
    }),
  ),
  idOverrides: z.array(
    z.object({
      groupName: z.string(),
      ids: z.array(z.string()),
      idType: z.optional(z.union([z.string(), z.null()])),
      environment: z.optional(z.union([z.string(), z.null()])),
      experimentName: z.optional(z.union([z.string(), z.null()])),
    }),
  ),
})

export const zLayerPartialUpdateContractDto = z.object({
  description: z.optional(z.string().max(1000)),
  parameters: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.enum(['string', 'number', 'boolean', 'object', 'array']),
        defaultValue: z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.record(z.string(), z.unknown()),
          z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.string(), z.unknown())])),
        ]),
      }),
    ),
  ),
  targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
})

export const zLoggedEventDto = z.object({
  timestamp: z.string(),
  name: z.string(),
  source: z.string(),
  value: z.string(),
  userID: z.string(),
})

export const zMetricCreationContractDto = z.object({
  name: z
    .string()
    .min(4)
    .max(200)
    .regex(/^[a-zA-Z0-9_.\-()/ %:]*$/),
  type: z.enum([
    'ratio',
    'mean',
    'event_count_custom',
    'event_user',
    'funnel',
    'composite',
    'composite_sum',
    'sum',
    'undefined',
    'user_warehouse',
  ]),
  isVerified: z.optional(z.boolean()),
  isReadOnly: z.optional(z.boolean()),
  unitTypes: z.optional(z.array(z.string())),
  metricEvents: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.optional(z.enum(['count', 'count_distinct', 'value', 'metadata'])),
        metadataKey: z.optional(z.string()),
        criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      }),
    ),
  ),
  metricComponentMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  description: z.optional(z.string().max(1000)),
  directionality: z.optional(z.enum(['increase', 'decrease'])),
  tags: z.optional(z.union([z.array(z.string()), z.string()])),
  isPermanent: z.optional(z.boolean()),
  rollupTimeWindow: z.optional(z.string()),
  customRollUpStart: z.optional(z.number()),
  customRollUpEnd: z.optional(z.number()),
  funnelEventList: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.enum(['event_dau', 'event_user', 'event_count', 'event_count_custom']),
      }),
    ),
  ),
  funnelCountDistinct: z.optional(z.enum(['events', 'users'])),
  warehouseNative: z.optional(
    z.object({
      aggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      metricSourceName: z.optional(z.string()),
      criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      waitForCohortWindow: z.optional(z.boolean()),
      denominatorCriteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      denominatorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      denominatorCustomRollupEnd: z.optional(z.number()),
      denominatorCustomRollupStart: z.optional(z.number()),
      denominatorMetricSourceName: z.optional(z.string()),
      denominatorRollupTimeWindow: z.optional(z.string()),
      denominatorValueColumn: z.optional(z.string()),
      funnelCalculationWindow: z.optional(z.number()),
      funnelCountDistinct: z.optional(z.enum(['sessions', 'users'])),
      funnelEvents: z.optional(
        z.array(
          z.object({
            criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
            metricSourceName: z.optional(z.string()),
            name: z.optional(z.union([z.string(), z.null()])),
            sessionIdentifierField: z.optional(z.union([z.string(), z.null()])),
          }),
        ),
      ),
      funnelStartCriteria: z.optional(z.enum(['start_event', 'exposure'])),
      metricDimensionColumns: z.optional(z.array(z.string())),
      metricBakeDays: z.optional(z.number()),
      numeratorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      valueColumn: z.optional(z.string()),
      valueThreshold: z.optional(z.number()),
      allowNullRatioDenominator: z.optional(z.boolean()),
      funnelStrictOrdering: z.optional(z.boolean()),
      funnelUseExposureAsFirstEvent: z.optional(z.boolean()),
      funnelTimestampAllowanceMs: z.optional(z.number()),
      funnelTimeToConvert: z.optional(z.boolean()),
      winsorizationHigh: z.optional(z.number().gte(0).lte(1)),
      winsorizationLow: z.optional(z.number().gte(0).lte(1)),
      winsorizationHighDenominator: z.optional(z.number().gte(0).lte(1)),
      winsorizationLowDenominator: z.optional(z.number().gte(0).lte(1)),
      cupedAttributionWindow: z.optional(z.union([z.number(), z.null()])),
      rollupTimeWindow: z.optional(z.string()),
      customRollUpStart: z.optional(z.number()),
      customRollUpEnd: z.optional(z.number()),
      onlyIncludeUsersWithConversionEvent: z.optional(z.boolean()),
      denominatorCustomRollupMeasureInMinutes: z.optional(z.boolean()),
      customRollupMeasureInMinutes: z.optional(z.boolean()),
      percentile: z.optional(z.number()),
      useLogTransform: z.optional(z.boolean()),
      useSecondaryRetentionEvent: z.optional(z.boolean()),
      retentionEnd: z.optional(z.number()),
      retentionLength: z.optional(z.number()),
      logTransformBase: z.optional(z.union([z.number(), z.null()])),
      cap: z.optional(z.number()),
      surrogateMetricMSE: z.optional(z.union([z.number(), z.null()])),
    }),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zMetricSourceContractDto = z.object({
  name: z.string(),
  description: z.string(),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.string(),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  sourceType: z.optional(z.enum(['table', 'query'])),
  tableName: z.optional(z.string()),
  datePartitionColumn: z.optional(z.string()),
  customFieldMapping: z.optional(
    z.array(
      z.object({
        key: z.string(),
        formula: z.string(),
      }),
    ),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
})

export const zMetricSourceCreationContractDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.string(),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  sourceType: z.optional(z.enum(['table', 'query'])),
  tableName: z.optional(z.string()),
  datePartitionColumn: z.optional(z.string()),
  customFieldMapping: z.optional(
    z.array(
      z.object({
        key: z.string(),
        formula: z.string(),
      }),
    ),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zMetricSourceUpdateContractDto = z.object({
  name: z.optional(z.unknown()),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  sql: z.string(),
  timestampColumn: z.string(),
  timestampAsDay: z.optional(z.boolean()),
  idTypeMapping: z.array(
    z.object({
      statsigUnitID: z.string(),
      column: z.string(),
    }),
  ),
  sourceType: z.optional(z.enum(['table', 'query'])),
  tableName: z.optional(z.string()),
  datePartitionColumn: z.optional(z.string()),
  customFieldMapping: z.optional(
    z.array(
      z.object({
        key: z.string(),
        formula: z.string(),
      }),
    ),
  ),
  isReadOnly: z.optional(z.boolean()),
  owner: z.optional(
    z.union([
      z.object({
        ownerID: z.optional(z.string()),
        ownerType: z.optional(z.string()),
        ownerName: z.optional(z.string()),
        ownerEmail: z.optional(z.string()),
      }),
      z.null(),
    ]),
  ),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  dryRun: z.optional(z.boolean()),
})

export const zMetricsUpdateContractDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
  isVerified: z.optional(z.boolean()),
  isReadOnly: z.optional(z.boolean()),
  isPermanent: z.optional(z.boolean()),
  warehouseNative: z.optional(
    z.object({
      aggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      metricSourceName: z.optional(z.string()),
      criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      waitForCohortWindow: z.optional(z.boolean()),
      denominatorCriteria: z.optional(z.array(zMetricEventsCriteriaDto)),
      denominatorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      denominatorCustomRollupEnd: z.optional(z.number()),
      denominatorCustomRollupStart: z.optional(z.number()),
      denominatorMetricSourceName: z.optional(z.string()),
      denominatorRollupTimeWindow: z.optional(z.string()),
      denominatorValueColumn: z.optional(z.string()),
      funnelCalculationWindow: z.optional(z.number()),
      funnelCountDistinct: z.optional(z.enum(['sessions', 'users'])),
      funnelEvents: z.optional(
        z.array(
          z.object({
            criteria: z.optional(z.array(zMetricEventsCriteriaDto)),
            metricSourceName: z.optional(z.string()),
            name: z.optional(z.union([z.string(), z.null()])),
            sessionIdentifierField: z.optional(z.union([z.string(), z.null()])),
          }),
        ),
      ),
      funnelStartCriteria: z.optional(z.enum(['start_event', 'exposure'])),
      metricDimensionColumns: z.optional(z.array(z.string())),
      metricBakeDays: z.optional(z.number()),
      numeratorAggregation: z.optional(
        z.enum([
          'count',
          'sum',
          'mean',
          'daily_participation',
          'ratio',
          'funnel',
          'count_distinct',
          'percentile',
          'first_value',
          'latest_value',
          'retention',
          'max',
          'min',
          '',
        ]),
      ),
      valueColumn: z.optional(z.string()),
      valueThreshold: z.optional(z.number()),
      allowNullRatioDenominator: z.optional(z.boolean()),
      funnelStrictOrdering: z.optional(z.boolean()),
      funnelUseExposureAsFirstEvent: z.optional(z.boolean()),
      funnelTimestampAllowanceMs: z.optional(z.number()),
      funnelTimeToConvert: z.optional(z.boolean()),
      winsorizationHigh: z.optional(z.number().gte(0).lte(1)),
      winsorizationLow: z.optional(z.number().gte(0).lte(1)),
      winsorizationHighDenominator: z.optional(z.number().gte(0).lte(1)),
      winsorizationLowDenominator: z.optional(z.number().gte(0).lte(1)),
      cupedAttributionWindow: z.optional(z.union([z.number(), z.null()])),
      rollupTimeWindow: z.optional(z.string()),
      customRollUpStart: z.optional(z.number()),
      customRollUpEnd: z.optional(z.number()),
      onlyIncludeUsersWithConversionEvent: z.optional(z.boolean()),
      denominatorCustomRollupMeasureInMinutes: z.optional(z.boolean()),
      customRollupMeasureInMinutes: z.optional(z.boolean()),
      percentile: z.optional(z.number()),
      useLogTransform: z.optional(z.boolean()),
      useSecondaryRetentionEvent: z.optional(z.boolean()),
      retentionEnd: z.optional(z.number()),
      retentionLength: z.optional(z.number()),
      logTransformBase: z.optional(z.union([z.number(), z.null()])),
      cap: z.optional(z.number()),
      surrogateMetricMSE: z.optional(z.union([z.number(), z.null()])),
    }),
  ),
  unitTypes: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  directionality: z.optional(z.enum(['increase', 'decrease'])),
  dryRun: z.optional(z.boolean()),
  owner: z.optional(
    z.object({
      email: z.optional(z.string()),
      ownerID: z.optional(z.string()),
    }),
  ),
})

export const zMetricValueDto = z.object({
  value: z.number(),
  unitType: z.string(),
  numerator: z.optional(z.number()),
  denominator: z.optional(z.number()),
  inputRows: z.optional(z.number()),
  metricName: z.string(),
  metricType: z.string(),
})

export const zMetricValuesDto = z.object({
  value: z.number(),
  unit_type: z.string(),
  row_count: z.optional(z.number()),
  numerator: z.optional(z.number()),
  denominator: z.optional(z.number()),
})

export const zMultiRuleDto = z.object({
  rules: z.array(
    z.object({
      name: z.string(),
      passPercentage: z.number().gte(0).lte(100),
      conditions: z.array(
        z.object({
          targetValue: z.optional(
            z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
          ),
          operator: z.optional(z.string()),
          field: z.optional(z.union([z.string(), z.null()])),
          customID: z.optional(z.union([z.string(), z.null()])),
          type: z.enum([
            'app_version',
            'browser_name',
            'browser_version',
            'country',
            'custom_field',
            'email',
            'environment_tier',
            'fails_gate',
            'fails_segment',
            'ip_address',
            'locale',
            'os_name',
            'os_version',
            'passes_gate',
            'passes_segment',
            'public',
            'time',
            'unit_id',
            'user_id',
            'url',
            'javascript',
            'device_model',
            'target_app',
          ]),
        }),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
    }),
  ),
})

export const zMultiRuleUpdateDto = z.object({
  rules: z.array(
    z.object({
      name: z.optional(z.string()),
      passPercentage: z.optional(z.number().gte(0).lte(100)),
      conditions: z.optional(
        z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
      ),
      environments: z.optional(z.union([z.array(z.string()), z.null()])),
      id: z.optional(z.string()),
      baseID: z.optional(z.string()),
      returnValue: z.optional(z.record(z.string(), z.unknown())),
      completedAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
      pendingAutomatedRollouts: z.optional(
        z.array(
          z.object({
            time: z.number(),
            passPercent: z.number(),
          }),
        ),
      ),
    }),
  ),
})

/**
 * Contract for overrides
 */
export const zOverrideDto = z.object({
  passingUserIDs: z.array(z.string().min(1)).max(2000),
  failingUserIDs: z.array(z.string().min(1)).max(2000),
  passingCustomIDs: z.optional(z.array(z.string().min(1)).max(2000)),
  failingCustomIDs: z.optional(z.array(z.string().min(1)).max(2000)),
  environmentOverrides: z.array(
    z.object({
      environment: z.optional(z.union([z.string(), z.null()])),
      unitID: z.union([z.string(), z.null()]),
      passingIDs: z.array(z.string()),
      failingIDs: z.array(z.string()),
    }),
  ),
})

export const zPaginationResponseMetadataDto = z.object({
  itemsPerPage: z.number(),
  pageNumber: z.number(),
  nextPage: z.union([z.string(), z.null()]),
  previousPage: z.union([z.string(), z.null()]),
  totalItems: z.optional(z.number()),
  all: z.optional(z.string()),
})

export const zPaginationResponseWithMessage = z.object({
  message: z.string(),
  data: z.array(z.record(z.string(), z.unknown())),
  pagination: zPaginationResponseMetadataDto,
})

export const zParamStoreCreateDto = z.object({
  name: z.string(),
  description: z.string(),
  displayName: z.string(),
  targetAppIDs: z.optional(z.array(z.string())),
  tags: z.optional(z.array(z.string())),
  team: z.optional(z.string()),
})

export const zParamStoreDto = z.object({
  id: z.string(),
  name: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdTime: z.number(),
  creatorID: z.string(),
  lastModifierID: z.string(),
  parameters: z.array(
    z.union([
      z.object({
        ref_type: z.enum(['static']),
        name: z.string(),
        param_type: z.enum(['boolean']),
        value: z.boolean(),
      }),
      z.object({
        ref_type: z.enum(['static']),
        name: z.string(),
        param_type: z.enum(['number']),
        value: z.number(),
      }),
      z.object({
        ref_type: z.enum(['static']),
        name: z.string(),
        param_type: z.enum(['string']),
        value: z.string(),
      }),
      z.object({
        ref_type: z.enum(['static']),
        name: z.string(),
        param_type: z.enum(['object']),
        value: z.record(z.string(), z.unknown()),
      }),
      z.object({
        ref_type: z.enum(['static']),
        name: z.string(),
        param_type: z.enum(['array']),
        value: z.array(z.unknown()),
      }),
      z.object({
        ref_type: z.enum(['gate']),
        name: z.string(),
        gate_name: z.string(),
        param_type: z.enum(['boolean']),
        pass_value: z.boolean(),
        fail_value: z.boolean(),
      }),
      z.object({
        ref_type: z.enum(['gate']),
        name: z.string(),
        gate_name: z.string(),
        param_type: z.enum(['number']),
        pass_value: z.number(),
        fail_value: z.number(),
      }),
      z.object({
        ref_type: z.enum(['gate']),
        name: z.string(),
        gate_name: z.string(),
        param_type: z.enum(['string']),
        pass_value: z.string(),
        fail_value: z.string(),
      }),
      z.object({
        ref_type: z.enum(['gate']),
        name: z.string(),
        gate_name: z.string(),
        param_type: z.enum(['object']),
        pass_value: z.record(z.string(), z.unknown()),
        fail_value: z.record(z.string(), z.unknown()),
      }),
      z.object({
        ref_type: z.enum(['gate']),
        name: z.string(),
        gate_name: z.string(),
        param_type: z.enum(['array']),
        pass_value: z.array(z.unknown()),
        fail_value: z.array(z.unknown()),
      }),
      z.object({
        ref_type: z.enum(['layer']),
        name: z.string(),
        param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
        layer_name: z.string(),
        param_name: z.string(),
      }),
      z.object({
        ref_type: z.enum(['dynamic_config']),
        name: z.string(),
        param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
        config_name: z.string(),
        param_name: z.string(),
      }),
      z.object({
        ref_type: z.enum(['experiment']),
        name: z.string(),
        param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
        experiment_name: z.string(),
        param_name: z.string(),
      }),
    ]),
  ),
})

export const zParamStoreUpdateDto = z.object({
  description: z.optional(z.string()),
  parameters: z.optional(
    z.array(
      z.union([
        z.object({
          ref_type: z.enum(['static']),
          name: z.string(),
          param_type: z.enum(['boolean']),
          value: z.boolean(),
        }),
        z.object({
          ref_type: z.enum(['static']),
          name: z.string(),
          param_type: z.enum(['number']),
          value: z.number(),
        }),
        z.object({
          ref_type: z.enum(['static']),
          name: z.string(),
          param_type: z.enum(['string']),
          value: z.string(),
        }),
        z.object({
          ref_type: z.enum(['static']),
          name: z.string(),
          param_type: z.enum(['object']),
          value: z.record(z.string(), z.unknown()),
        }),
        z.object({
          ref_type: z.enum(['static']),
          name: z.string(),
          param_type: z.enum(['array']),
          value: z.array(z.unknown()),
        }),
        z.object({
          ref_type: z.enum(['gate']),
          name: z.string(),
          gate_name: z.string(),
          param_type: z.enum(['boolean']),
          pass_value: z.boolean(),
          fail_value: z.boolean(),
        }),
        z.object({
          ref_type: z.enum(['gate']),
          name: z.string(),
          gate_name: z.string(),
          param_type: z.enum(['number']),
          pass_value: z.number(),
          fail_value: z.number(),
        }),
        z.object({
          ref_type: z.enum(['gate']),
          name: z.string(),
          gate_name: z.string(),
          param_type: z.enum(['string']),
          pass_value: z.string(),
          fail_value: z.string(),
        }),
        z.object({
          ref_type: z.enum(['gate']),
          name: z.string(),
          gate_name: z.string(),
          param_type: z.enum(['object']),
          pass_value: z.record(z.string(), z.unknown()),
          fail_value: z.record(z.string(), z.unknown()),
        }),
        z.object({
          ref_type: z.enum(['gate']),
          name: z.string(),
          gate_name: z.string(),
          param_type: z.enum(['array']),
          pass_value: z.array(z.unknown()),
          fail_value: z.array(z.unknown()),
        }),
        z.object({
          ref_type: z.enum(['layer']),
          name: z.string(),
          param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
          layer_name: z.string(),
          param_name: z.string(),
        }),
        z.object({
          ref_type: z.enum(['dynamic_config']),
          name: z.string(),
          param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
          config_name: z.string(),
          param_name: z.string(),
        }),
        z.object({
          ref_type: z.enum(['experiment']),
          name: z.string(),
          param_type: z.enum(['string', 'boolean', 'number', 'array', 'object']),
          experiment_name: z.string(),
          param_name: z.string(),
        }),
      ]),
    ),
  ),
})

export const zPrecommitHookArgsDto = z.union([
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['gate']),
    config_name: z.string(),
    type: z.enum(['rules']),
    diffs: z.union([z.array(z.unknown()), z.null()]),
    old_config: z.optional(
      z.object({
        id: z.string(),
        name: z.optional(
          z
            .string()
            .min(3)
            .max(100)
            .regex(/^[a-zA-Z0-9_\-. ]*$/),
        ),
        idType: z.optional(z.string()),
        description: z.string().max(1000),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.optional(z.union([z.string(), z.null()])),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.optional(z.union([z.string(), z.null()])),
        tags: z.optional(z.array(z.string())),
        targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
        checksPerHour: z.union([z.number(), z.null()]),
        status: z.enum(['In Progress', 'Launched', 'Disabled', 'Archived']),
        type: z.enum(['TEMPORARY', 'PERMANENT', 'STALE', 'TEMPLATE']),
        typeReason: z.enum([
          'NONE',
          'STALE_PROBABLY_LAUNCHED',
          'STALE_PROBABLY_UNLAUNCHED',
          'STALE_PROBABLY_FORGOTTEN',
          'STALE_NO_RULES',
          'STALE_PROBABLY_DEAD_CHECK',
          'STALE_EMPTY_CHECKS',
          'STALE_ALL_TRUE',
          'STALE_ALL_FALSE',
        ]),
        owner: z.optional(
          z.union([
            z.object({
              ownerID: z.optional(z.string()),
              ownerType: z.optional(z.string()),
              ownerName: z.optional(z.string()),
              ownerEmail: z.optional(z.string()),
            }),
            z.null(),
          ]),
        ),
        isTemplate: z.optional(z.boolean()),
        isEnabled: z.boolean(),
        rules: z.array(
          z.object({
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
            id: z.optional(z.string()),
            baseID: z.optional(z.string()),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            completedAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            pendingAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
          }),
        ),
        measureMetricLifts: z.optional(z.boolean()),
        monitoringMetrics: z.optional(
          z.array(
            z.object({
              name: z.string(),
              type: z.string(),
            }),
          ),
        ),
        reviewSettings: z.optional(
          z.object({
            requiredReview: z.boolean(),
            allowedReviewers: z.optional(
              z.union([
                z.array(
                  z.object({
                    id: z.string(),
                    name: z.string(),
                    email: z.string(),
                  }),
                ),
                z.null(),
              ]),
            ),
          }),
        ),
        releasePipelineID: z.optional(z.union([z.string(), z.null()])),
        activeReview: z.optional(
          z.object({
            reviewID: z.string(),
            reviewStatus: z.string(),
            description: z.string(),
          }),
        ),
      }),
    ),
    new_config: z.optional(
      z.object({
        id: z.string(),
        name: z.optional(
          z
            .string()
            .min(3)
            .max(100)
            .regex(/^[a-zA-Z0-9_\-. ]*$/),
        ),
        idType: z.optional(z.string()),
        description: z.string().max(1000),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.optional(z.union([z.string(), z.null()])),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.optional(z.union([z.string(), z.null()])),
        tags: z.optional(z.array(z.string())),
        targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
        checksPerHour: z.union([z.number(), z.null()]),
        status: z.enum(['In Progress', 'Launched', 'Disabled', 'Archived']),
        type: z.enum(['TEMPORARY', 'PERMANENT', 'STALE', 'TEMPLATE']),
        typeReason: z.enum([
          'NONE',
          'STALE_PROBABLY_LAUNCHED',
          'STALE_PROBABLY_UNLAUNCHED',
          'STALE_PROBABLY_FORGOTTEN',
          'STALE_NO_RULES',
          'STALE_PROBABLY_DEAD_CHECK',
          'STALE_EMPTY_CHECKS',
          'STALE_ALL_TRUE',
          'STALE_ALL_FALSE',
        ]),
        owner: z.optional(
          z.union([
            z.object({
              ownerID: z.optional(z.string()),
              ownerType: z.optional(z.string()),
              ownerName: z.optional(z.string()),
              ownerEmail: z.optional(z.string()),
            }),
            z.null(),
          ]),
        ),
        isTemplate: z.optional(z.boolean()),
        isEnabled: z.boolean(),
        rules: z.array(
          z.object({
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
            id: z.optional(z.string()),
            baseID: z.optional(z.string()),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            completedAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            pendingAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
          }),
        ),
        measureMetricLifts: z.optional(z.boolean()),
        monitoringMetrics: z.optional(
          z.array(
            z.object({
              name: z.string(),
              type: z.string(),
            }),
          ),
        ),
        reviewSettings: z.optional(
          z.object({
            requiredReview: z.boolean(),
            allowedReviewers: z.optional(
              z.union([
                z.array(
                  z.object({
                    id: z.string(),
                    name: z.string(),
                    email: z.string(),
                  }),
                ),
                z.null(),
              ]),
            ),
          }),
        ),
        releasePipelineID: z.optional(z.union([z.string(), z.null()])),
        activeReview: z.optional(
          z.object({
            reviewID: z.string(),
            reviewStatus: z.string(),
            description: z.string(),
          }),
        ),
      }),
    ),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['gate']),
    config_name: z.string(),
    type: z.enum(['update_target_apps']),
    old_target_apps: z.array(z.string()),
    new_target_apps: z.array(z.string()),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['dynamic_config']),
    config_name: z.string(),
    type: z.enum(['rules']),
    diffs: z.union([z.array(z.unknown()), z.null()]),
    old_config: z.optional(
      z.object({
        id: z.string(),
        name: z.optional(
          z
            .string()
            .min(3)
            .max(100)
            .regex(/^[a-zA-Z0-9_\-. ]*$/),
        ),
        idType: z.optional(z.string()),
        description: z.string().max(1000),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.optional(z.union([z.string(), z.null()])),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.optional(z.union([z.string(), z.null()])),
        tags: z.optional(z.array(z.string())),
        targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
        isEnabled: z.boolean().default(true),
        rules: z.array(
          z.object({
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
            id: z.optional(z.string()),
            baseID: z.optional(z.string()),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            completedAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            pendingAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            returnValueJson5: z.optional(z.string()),
            variants: z.optional(
              z.array(
                z.object({
                  id: z.optional(z.string()),
                  name: z.string(),
                  passPercentage: z.number().gte(0).lte(100),
                  returnValue: z.optional(z.record(z.string(), z.unknown())),
                  returnValueJson5: z.optional(z.string()),
                }),
              ),
            ),
          }),
        ),
        defaultValue: z.optional(z.record(z.string(), z.unknown())),
        defaultValueJson5: z.optional(z.string()),
        owner: z.optional(
          z.union([
            z.object({
              ownerID: z.optional(z.string()),
              ownerType: z.optional(z.string()),
              ownerName: z.optional(z.string()),
              ownerEmail: z.optional(z.string()),
            }),
            z.null(),
          ]),
        ),
        schema: z.optional(z.union([z.string(), z.null()])),
        schemaJson5: z.optional(z.union([z.string(), z.null()])),
        releasePipelineID: z.optional(z.union([z.string(), z.null()])),
        isTemplate: z.optional(z.boolean()),
      }),
    ),
    new_config: z.optional(
      z.object({
        id: z.string(),
        name: z.optional(
          z
            .string()
            .min(3)
            .max(100)
            .regex(/^[a-zA-Z0-9_\-. ]*$/),
        ),
        idType: z.optional(z.string()),
        description: z.string().max(1000),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.optional(z.union([z.string(), z.null()])),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.optional(z.union([z.string(), z.null()])),
        tags: z.optional(z.array(z.string())),
        targetApps: z.optional(z.union([z.string(), z.array(z.string())])),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
        isEnabled: z.boolean().default(true),
        rules: z.array(
          z.object({
            name: z.string(),
            passPercentage: z.number().gte(0).lte(100),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
            id: z.optional(z.string()),
            baseID: z.optional(z.string()),
            returnValue: z.optional(z.record(z.string(), z.unknown())),
            completedAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            pendingAutomatedRollouts: z.optional(
              z.array(
                z.object({
                  time: z.number(),
                  passPercent: z.number(),
                }),
              ),
            ),
            returnValueJson5: z.optional(z.string()),
            variants: z.optional(
              z.array(
                z.object({
                  id: z.optional(z.string()),
                  name: z.string(),
                  passPercentage: z.number().gte(0).lte(100),
                  returnValue: z.optional(z.record(z.string(), z.unknown())),
                  returnValueJson5: z.optional(z.string()),
                }),
              ),
            ),
          }),
        ),
        defaultValue: z.optional(z.record(z.string(), z.unknown())),
        defaultValueJson5: z.optional(z.string()),
        owner: z.optional(
          z.union([
            z.object({
              ownerID: z.optional(z.string()),
              ownerType: z.optional(z.string()),
              ownerName: z.optional(z.string()),
              ownerEmail: z.optional(z.string()),
            }),
            z.null(),
          ]),
        ),
        schema: z.optional(z.union([z.string(), z.null()])),
        schemaJson5: z.optional(z.union([z.string(), z.null()])),
        releasePipelineID: z.optional(z.union([z.string(), z.null()])),
        isTemplate: z.optional(z.boolean()),
      }),
    ),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['dynamic_config']),
    config_name: z.string(),
    type: z.enum(['update_target_apps']),
    old_target_apps: z.array(z.string()),
    new_target_apps: z.array(z.string()),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['segment']),
    config_name: z.string(),
    type: z.enum(['rules']),
    diffs: z.union([z.array(z.unknown()), z.null()]),
    old_config: z.optional(
      z.object({
        isEnabled: z.boolean(),
        type: z.enum(['id_list', 'rule_based', 'analysis_list', 'user_store_id_list']),
        count: z.optional(z.number()),
        rules: z.optional(
          z.array(
            z.object({
              name: z.string(),
              passPercentage: z.number().gte(0).lte(100),
              conditions: z.array(
                z.object({
                  targetValue: z.optional(
                    z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                  ),
                  operator: z.optional(z.string()),
                  field: z.optional(z.union([z.string(), z.null()])),
                  customID: z.optional(z.union([z.string(), z.null()])),
                  type: z.enum([
                    'app_version',
                    'browser_name',
                    'browser_version',
                    'country',
                    'custom_field',
                    'email',
                    'environment_tier',
                    'fails_gate',
                    'fails_segment',
                    'ip_address',
                    'locale',
                    'os_name',
                    'os_version',
                    'passes_gate',
                    'passes_segment',
                    'public',
                    'time',
                    'unit_id',
                    'user_id',
                    'url',
                    'javascript',
                    'device_model',
                    'target_app',
                  ]),
                }),
              ),
              environments: z.optional(z.union([z.array(z.string()), z.null()])),
              id: z.optional(z.string()),
              baseID: z.optional(z.string()),
              returnValue: z.optional(z.record(z.string(), z.unknown())),
            }),
          ),
        ),
        tags: z.optional(z.array(z.string())),
        id: z.string(),
        name: z.optional(z.string()),
        idType: z.string(),
        description: z.string(),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.union([z.string(), z.null()]),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.union([z.string(), z.null()]),
        targetApps: z.optional(z.array(z.string())),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
      }),
    ),
    new_config: z.optional(
      z.object({
        isEnabled: z.boolean(),
        type: z.enum(['id_list', 'rule_based', 'analysis_list', 'user_store_id_list']),
        count: z.optional(z.number()),
        rules: z.optional(
          z.array(
            z.object({
              name: z.string(),
              passPercentage: z.number().gte(0).lte(100),
              conditions: z.array(
                z.object({
                  targetValue: z.optional(
                    z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                  ),
                  operator: z.optional(z.string()),
                  field: z.optional(z.union([z.string(), z.null()])),
                  customID: z.optional(z.union([z.string(), z.null()])),
                  type: z.enum([
                    'app_version',
                    'browser_name',
                    'browser_version',
                    'country',
                    'custom_field',
                    'email',
                    'environment_tier',
                    'fails_gate',
                    'fails_segment',
                    'ip_address',
                    'locale',
                    'os_name',
                    'os_version',
                    'passes_gate',
                    'passes_segment',
                    'public',
                    'time',
                    'unit_id',
                    'user_id',
                    'url',
                    'javascript',
                    'device_model',
                    'target_app',
                  ]),
                }),
              ),
              environments: z.optional(z.union([z.array(z.string()), z.null()])),
              id: z.optional(z.string()),
              baseID: z.optional(z.string()),
              returnValue: z.optional(z.record(z.string(), z.unknown())),
            }),
          ),
        ),
        tags: z.optional(z.array(z.string())),
        id: z.string(),
        name: z.optional(z.string()),
        idType: z.string(),
        description: z.string(),
        lastModifierID: z.union([z.string(), z.null()]),
        lastModifiedTime: z.union([z.number(), z.null()]),
        lastModifierEmail: z.union([z.string(), z.null()]),
        lastModifierName: z.union([z.string(), z.null()]),
        creatorID: z.union([z.string(), z.null()]),
        createdTime: z.number(),
        creatorName: z.union([z.string(), z.null()]),
        creatorEmail: z.union([z.string(), z.null()]),
        targetApps: z.optional(z.array(z.string())),
        holdoutIDs: z.optional(z.array(z.string())),
        team: z.optional(z.union([z.string(), z.null()])),
        teamID: z.optional(z.union([z.string(), z.null()])),
        version: z.optional(z.number()),
      }),
    ),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['segment']),
    config_name: z.string(),
    type: z.enum(['update_target_apps']),
    old_target_apps: z.array(z.string()),
    new_target_apps: z.array(z.string()),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['update_allocation']),
    old_allocation: z.number(),
    new_allocation: z.number(),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['start_experiment']),
    new_allocation: z.number(),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['ship_experiment']),
    group: z.string(),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['abandon_experiment']),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['update_target_apps']),
    old_target_apps: z.array(z.string()),
    new_target_apps: z.array(z.string()),
  }),
  z.object({
    review_id: z.string(),
    submitter: z.string(),
    committer: z.string(),
    config_type: z.enum(['experiment']),
    experiment_name: z.string(),
    type: z.enum(['update_experiment_settings']),
    old_settings: z.object({
      groups: z.array(
        z.object({
          name: z.string(),
          parameterValuesJSON: z.string(),
          size: z.number(),
        }),
      ),
      allocation: z.number(),
      targetingGateID: z.union([z.string(), z.null()]),
      inlineTargetingRulesJSON: z.union([z.string(), z.null()]),
    }),
    new_settings: z.object({
      groups: z.array(
        z.object({
          name: z.string(),
          parameterValuesJSON: z.string(),
          size: z.number(),
        }),
      ),
      allocation: z.number(),
      targetingGateID: z.union([z.string(), z.null()]),
      inlineTargetingRulesJSON: z.union([z.string(), z.null()]),
    }),
  }),
])

export const zProjectDto = z.object({
  id: z.string(),
})

export const zPulseLoadHistoryDto = z.object({
  creatorName: z.optional(z.string()),
  createdTime: z.number(),
  finishedTime: z.optional(z.number()),
  finishedState: z.optional(z.enum(['success', 'failure', 'partial_failure', 'cancelled', 'timeout'])),
  startDs: z.string(),
  endDs: z.string(),
  reloadType: z.enum(['incremental', 'full', 'metric']),
  turboMode: z.boolean(),
})

export const zReleasePipelineCreateDto = z.object({
  name: z.string(),
  phases: z.optional(
    z.array(
      z.object({
        id: z.optional(z.string()),
        name: z.string(),
        timeIntervalMs: z.number(),
        requiredReview: z.boolean(),
        rules: z.array(
          z.object({
            id: z.optional(z.string()),
            name: z.string(),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
          }),
        ),
      }),
    ),
  ),
})

export const zReleasePipelineDto = z.object({
  id: z.string(),
  name: z.string(),
  creatorID: z.string(),
  createdTime: z.number(),
  lastModifierID: z.string(),
  phases: z.optional(
    z.array(
      z.object({
        id: z.optional(z.string()),
        name: z.string(),
        timeIntervalMs: z.number(),
        requiredReview: z.boolean(),
        rules: z.array(
          z.object({
            id: z.optional(z.string()),
            name: z.string(),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
          }),
        ),
      }),
    ),
  ),
})

export const zReleasePipelineTriggerActionBodyDto = z.object({
  phaseID: z.string(),
})

export const zReleasePipelineTriggerResponseDto = z.object({
  id: z.string(),
  releasePipelineID: z.string(),
  actions: z.array(
    z.object({
      type: z.union([
        z.literal('STARTED'),
        z.literal('ABORTED'),
        z.literal('PAUSED'),
        z.literal('UNPAUSED'),
        z.literal('APPROVED_FOR'),
        z.literal('SKIPPED'),
        z.literal('FULL_ROLL_OUT'),
        z.enum(['CLEANED_UP']),
      ]),
      timeMs: z.number(),
      phaseID: z.string(),
      actorID: z.string(),
      actorName: z.string(),
    }),
  ),
  creatorID: z.string(),
  createdTime: z.number(),
  description: z.optional(z.string()),
  gateID: z.optional(z.string()),
  dynamicConfigID: z.optional(z.string()),
  lastModifierID: z.string(),
  lastModifierName: z.string(),
  status: z.string(),
  currentPhase: z.union([z.string(), z.null()]),
  currentPhaseID: z.union([z.string(), z.null()]),
})

export const zReleasePipelineUpdateDto = z.object({
  name: z.optional(z.string()),
  phases: z.optional(
    z.array(
      z.object({
        id: z.optional(z.string()),
        name: z.string(),
        timeIntervalMs: z.number(),
        requiredReview: z.boolean(),
        rules: z.array(
          z.object({
            id: z.optional(z.string()),
            name: z.string(),
            conditions: z.array(
              z.object({
                targetValue: z.optional(
                  z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
                ),
                operator: z.optional(z.string()),
                field: z.optional(z.union([z.string(), z.null()])),
                customID: z.optional(z.union([z.string(), z.null()])),
                type: z.enum([
                  'app_version',
                  'browser_name',
                  'browser_version',
                  'country',
                  'custom_field',
                  'email',
                  'environment_tier',
                  'fails_gate',
                  'fails_segment',
                  'ip_address',
                  'locale',
                  'os_name',
                  'os_version',
                  'passes_gate',
                  'passes_segment',
                  'public',
                  'time',
                  'unit_id',
                  'user_id',
                  'url',
                  'javascript',
                  'device_model',
                  'target_app',
                ]),
              }),
            ),
            environments: z.optional(z.union([z.array(z.string()), z.null()])),
          }),
        ),
      }),
    ),
  ),
})

export const zReportDto = z.object({
  url: z.string(),
})

export const zRoleContractDto = z.object({
  name: z.string(),
  permissions: z.record(z.string(), z.boolean()),
})

export const zRoleUpdateContractDto = z.object({
  permissions: z.record(z.string(), z.boolean()),
})

export const zRuleDto = z.object({
  name: z.string(),
  passPercentage: z.number().gte(0).lte(100),
  conditions: z.array(
    z.object({
      targetValue: z.optional(z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()])),
      operator: z.optional(z.string()),
      field: z.optional(z.union([z.string(), z.null()])),
      customID: z.optional(z.union([z.string(), z.null()])),
      type: z.enum([
        'app_version',
        'browser_name',
        'browser_version',
        'country',
        'custom_field',
        'email',
        'environment_tier',
        'fails_gate',
        'fails_segment',
        'ip_address',
        'locale',
        'os_name',
        'os_version',
        'passes_gate',
        'passes_segment',
        'public',
        'time',
        'unit_id',
        'user_id',
        'url',
        'javascript',
        'device_model',
        'target_app',
      ]),
    }),
  ),
  environments: z.optional(z.union([z.array(z.string()), z.null()])),
  id: z.optional(z.string()),
  baseID: z.optional(z.string()),
  returnValue: z.optional(z.record(z.string(), z.unknown())),
  completedAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
  pendingAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
})

export const zRuleUpdateDto = z.object({
  name: z.optional(z.string()),
  passPercentage: z.optional(z.number().gte(0).lte(100)),
  conditions: z.optional(
    z.array(
      z.object({
        targetValue: z.optional(z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()])),
        operator: z.optional(z.string()),
        field: z.optional(z.union([z.string(), z.null()])),
        customID: z.optional(z.union([z.string(), z.null()])),
        type: z.enum([
          'app_version',
          'browser_name',
          'browser_version',
          'country',
          'custom_field',
          'email',
          'environment_tier',
          'fails_gate',
          'fails_segment',
          'ip_address',
          'locale',
          'os_name',
          'os_version',
          'passes_gate',
          'passes_segment',
          'public',
          'time',
          'unit_id',
          'user_id',
          'url',
          'javascript',
          'device_model',
          'target_app',
        ]),
      }),
    ),
  ),
  environments: z.optional(z.union([z.array(z.string()), z.null()])),
  id: z.optional(z.string()),
  baseID: z.optional(z.string()),
  returnValue: z.optional(z.record(z.string(), z.unknown())),
  completedAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
  pendingAutomatedRollouts: z.optional(
    z.array(
      z.object({
        time: z.number(),
        passPercent: z.number(),
      }),
    ),
  ),
})

export const zSegmentCreateContractDto = z.object({
  name: z
    .string()
    .min(3)
    .max(100)
    .regex(/^[a-zA-Z0-9_\- ]*$/),
  id: z.optional(
    z
      .string()
      .min(3)
      .max(100)
      .regex(/^[a-zA-Z0-9_-]*$/),
  ),
  description: z.optional(z.string().max(1000)),
  type: z.enum(['id_list', 'rule_based', 'analysis_list', 'user_store_id_list']),
  idType: z.optional(z.string()).default('userID'),
  tags: z.optional(z.array(z.string())),
  creatorID: z.optional(z.union([z.string(), z.null()])),
  creatorEmail: z.optional(z.union([z.string(), z.null()])),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.number().gte(0).lte(100),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_segment',
              'ip_address',
              'os_name',
              'os_version',
              'passes_segment',
              'unit_id',
              'user_id',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
        completedAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
        pendingAutomatedRollouts: z.optional(
          z.array(
            z.object({
              time: z.number(),
              passPercent: z.number(),
            }),
          ),
        ),
      }),
    ),
  ),
})

export const zSegmentDto = z.object({
  isEnabled: z.boolean(),
  type: z.enum(['id_list', 'rule_based', 'analysis_list', 'user_store_id_list']),
  count: z.optional(z.number()),
  rules: z.optional(
    z.array(
      z.object({
        name: z.string(),
        passPercentage: z.number().gte(0).lte(100),
        conditions: z.array(
          z.object({
            targetValue: z.optional(
              z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()]),
            ),
            operator: z.optional(z.string()),
            field: z.optional(z.union([z.string(), z.null()])),
            customID: z.optional(z.union([z.string(), z.null()])),
            type: z.enum([
              'app_version',
              'browser_name',
              'browser_version',
              'country',
              'custom_field',
              'email',
              'environment_tier',
              'fails_gate',
              'fails_segment',
              'ip_address',
              'locale',
              'os_name',
              'os_version',
              'passes_gate',
              'passes_segment',
              'public',
              'time',
              'unit_id',
              'user_id',
              'url',
              'javascript',
              'device_model',
              'target_app',
            ]),
          }),
        ),
        environments: z.optional(z.union([z.array(z.string()), z.null()])),
        id: z.optional(z.string()),
        baseID: z.optional(z.string()),
        returnValue: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  ),
  tags: z.optional(z.array(z.string())),
  id: z.string(),
  name: z.optional(z.string()),
  idType: z.string(),
  description: z.string(),
  lastModifierID: z.union([z.string(), z.null()]),
  lastModifiedTime: z.union([z.number(), z.null()]),
  lastModifierEmail: z.union([z.string(), z.null()]),
  lastModifierName: z.union([z.string(), z.null()]),
  creatorID: z.union([z.string(), z.null()]),
  createdTime: z.number(),
  creatorName: z.union([z.string(), z.null()]),
  creatorEmail: z.union([z.string(), z.null()]),
  targetApps: z.optional(z.array(z.string())),
  holdoutIDs: z.optional(z.array(z.string())),
  team: z.optional(z.union([z.string(), z.null()])),
  teamID: z.optional(z.union([z.string(), z.null()])),
  version: z.optional(z.number()),
})

export const zSegmentIdListContractDto = z.object({
  ids: z.array(z.string()).max(100000),
})

export const zSegmentIdListResetContractDto = z.object({
  ids: z.array(z.string()).max(100000),
})

export const zSegmentIdListUserStoreContractDto = z.object({
  ids: z.array(z.string()).max(1000),
  version: z.optional(z.number()),
})

export const zSegmentRulesDto = z.array(
  z.object({
    name: z.string(),
    passPercentage: z.number().gte(0).lte(100),
    conditions: z.array(
      z.object({
        targetValue: z.optional(z.union([z.array(z.string()), z.array(z.number()), z.string(), z.number(), z.null()])),
        operator: z.optional(z.string()),
        field: z.optional(z.union([z.string(), z.null()])),
        customID: z.optional(z.union([z.string(), z.null()])),
        type: z.enum([
          'app_version',
          'browser_name',
          'browser_version',
          'country',
          'custom_field',
          'email',
          'environment_tier',
          'fails_segment',
          'ip_address',
          'os_name',
          'os_version',
          'passes_segment',
          'unit_id',
          'user_id',
        ]),
      }),
    ),
    environments: z.optional(z.union([z.array(z.string()), z.null()])),
    id: z.optional(z.string()),
    baseID: z.optional(z.string()),
    returnValue: z.optional(z.record(z.string(), z.unknown())),
    completedAutomatedRollouts: z.optional(
      z.array(
        z.object({
          time: z.number(),
          passPercent: z.number(),
        }),
      ),
    ),
    pendingAutomatedRollouts: z.optional(
      z.array(
        z.object({
          time: z.number(),
          passPercent: z.number(),
        }),
      ),
    ),
  }),
)

export const zSettingsProjectContractDto = z.object({
  name: z.string(),
  visibility: z.enum(['OPEN', 'CLOSED', 'EXTERNAL']),
  default_unit_type: z.optional(z.string()),
})

export const zSettingsReviewsContractDto = z.object({
  is_config_review_required: z.boolean(),
  is_metric_review_required: z.boolean(),
  is_metric_review_required_on_verified_only: z.boolean(),
  is_whn_analysis_only_review_required: z.optional(z.boolean()),
  is_whn_source_review_required: z.optional(z.boolean()),
})

export const zSettingsRolesContractDto = z.object({
  default_project_role: z.string(),
})

export const zSettingsTeamsContractDto = z.object({
  require_teams_on_configs: z.boolean(),
})

export const zSingleDataResponse = z.object({
  message: z.string(),
  data: z.record(z.string(), z.unknown()),
})

export const zTagCreateDto = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(1000),
  isCore: z.optional(z.boolean()).default(false),
})

export const zTagDto = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  isCore: z.boolean(),
})

export const zTagUpdateDto = z.object({
  name: z.optional(z.string().min(1).max(100)),
  description: z.optional(z.string().max(1000)),
  isCore: z.optional(z.boolean()).default(false),
})

export const zTargetAppCreateDto = z.object({
  name: z.string(),
  description: z.string(),
  gates: z.optional(z.array(z.string())),
  dynamicConfigs: z.optional(z.array(z.string())),
  experiments: z.optional(z.array(z.string())),
})

export const zTargetAppDto = z.object({
  id: z.optional(z.string()),
  name: z.string(),
})

export const zTeamCreationDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  members: z.array(z.string()),
  admins: z.array(z.string()),
  defaultGateMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultExperimentPrimaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultExperimentSecondaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultHoldoutMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  changeTeamConfigs: z.enum(['anyone', 'team_only']),
  reviewApproval: z.enum(['anyone', 'team_only', 'admin_only']),
  defaultTargetApplications: z.array(z.string()),
  defaultHoldoutID: z.optional(z.union([z.string(), z.null()])),
  requireReviews: z.optional(z.union([z.boolean(), z.null()])),
  requireGateTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireExperimentTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireDynamicConfigTemplates: z.optional(z.union([z.boolean(), z.null()])),
})

export const zTeamDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  id: z.string(),
  defaultGateMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultExperimentPrimaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultExperimentSecondaryMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  defaultHoldoutMetrics: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
    }),
  ),
  changeTeamConfigs: z.enum(['anyone', 'team_only']),
  reviewApproval: z.enum(['anyone', 'team_only', 'admin_only']),
  defaultTargetApplications: z.array(z.string()),
  defaultHoldoutID: z.optional(z.union([z.string(), z.null()])),
  requireReviews: z.optional(z.union([z.boolean(), z.null()])),
  requireGateTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireExperimentTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireDynamicConfigTemplates: z.optional(z.union([z.boolean(), z.null()])),
  members: z.array(
    z.object({
      email: z.email(),
      firstName: z.string(),
      lastName: z.string(),
      role: z.string(),
    }),
  ),
  admins: z.array(
    z.object({
      email: z.email(),
      firstName: z.string(),
      lastName: z.string(),
      role: z.string(),
    }),
  ),
})

export const zTeamPartialUpdateDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  id: z.optional(z.string()),
  members: z.optional(z.array(z.string())),
  admins: z.optional(z.array(z.string())),
  defaultGateMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  defaultExperimentPrimaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  defaultExperimentSecondaryMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  defaultHoldoutMetrics: z.optional(
    z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  ),
  changeTeamConfigs: z.optional(z.enum(['anyone', 'team_only'])),
  reviewApproval: z.optional(z.enum(['anyone', 'team_only', 'admin_only'])),
  defaultTargetApplications: z.optional(z.array(z.string())),
  defaultHoldoutID: z.optional(z.union([z.string(), z.null()])),
  requireReviews: z.optional(z.union([z.boolean(), z.null()])),
  requireGateTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireExperimentTemplates: z.optional(z.union([z.boolean(), z.null()])),
  requireDynamicConfigTemplates: z.optional(z.union([z.boolean(), z.null()])),
})

export const zUnarchiveSchemaDto = z.object({
  unarchiveReason: z.optional(z.string()),
})

export const zUnitIdTypeContractDto = z.object({
  name: z.string(),
  description: z.optional(z.string()),
})

export const zUnitIdTypeUpdateContractDto = z.object({
  description: z.string(),
})

/**
 * Contract for updating overrides
 */
export const zUpdateOverridesContractDto = z.union([
  z.object({
    environmentOverrides: z.array(
      z.object({
        environment: z.optional(z.union([z.string(), z.null()])),
        unitID: z.union([z.string(), z.null()]),
        passingIDs: z.array(z.string()),
        failingIDs: z.array(z.string()),
      }),
    ),
  }),
  z.object({
    passingUserIDs: z.array(z.string().min(1)).max(2000),
    failingUserIDs: z.array(z.string().min(1)).max(2000),
    passingCustomIDs: z.optional(z.array(z.string().min(1)).max(2000)),
    failingCustomIDs: z.optional(z.array(z.string().min(1)).max(2000)),
  }),
])

export const zUpdateTargetAppDto = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
})

export const zUserContractDto = z.object({
  email: z.email(),
  firstName: z.string(),
  lastName: z.string(),
  role: z.string(),
})

export const zUserInvitesDto = z.object({
  role: z.string(),
  emails: z.array(z.email()),
  teams: z.optional(z.array(z.string())),
})

/**
 * Schema for updating user information.
 */
export const zUserUpdateDto = z.object({
  role: z.optional(z.string()),
  firstName: z.optional(z.string()),
  lastName: z.optional(z.string()),
})

export const zWhConnectionUpdateDto = z.object({
  databricks: z.optional(
    z.object({
      host: z.optional(z.string()),
      path: z.optional(z.string()),
      accessToken: z.optional(z.string()),
      stagingDatabase: z.optional(z.string()),
      oauthClientID: z.optional(z.union([z.string(), z.null()])),
      consoleComputePath: z.optional(z.union([z.string(), z.null()])),
    }),
  ),
  snowflake: z.optional(
    z.object({
      accountName: z.optional(z.string()),
      serviceUserName: z.optional(z.string()),
      serviceUserPassword: z.optional(z.string()),
      privateKey: z.optional(z.union([z.string(), z.null()])),
      keyPassPhrase: z.optional(z.union([z.string(), z.null()])),
      stagingDatabaseName: z.optional(z.string()),
      stagingSchemaName: z.optional(z.string()),
      computeWarehouse: z.optional(z.string()),
      consoleComputeWarehouse: z.optional(z.union([z.string(), z.null()])),
    }),
  ),
})

export const zGetConsoleV1AlertsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Alerts success response
 */
export const zGetConsoleV1AlertsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zAlertSchemaDto)),
  }),
)

export const zGetConsoleV1AuditLogsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      id: z.optional(z.string()),
      sortKey: z.optional(
        z.enum(['id', 'name', 'changeLog', 'actionType', 'date', 'time', 'updatedBy', 'updatedByUserID']),
      ),
      sortOrder: z.optional(z.enum(['asc', 'desc'])),
      latestID: z.optional(z.string()),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      actionType: z.optional(
        z.enum([
          'start_ai_config_version_evaluation_job',
          'clone_ai_config',
          'edit_ai_config_version',
          'delete_ai_config_version',
          'clone_ai_config_version',
          'ai_config_create',
          'create_ai_config_version',
          'upsert_ai_config_version',
          'create_ai_config_eval_grader',
          'edit_ai_config_eval_grader',
          'delete_ai_config_eval_grader',
          'set_enable_id_resolution_toggle',
          'dynamic_config_create',
          'dynamic_config_template_create',
          'dynamic_config_update_owners',
          'gate_overrides_update',
          'gate_template_create',
          'gate_create',
          'gate_update',
          'set_user_sampling_rate_for_gate',
          'gate_update_owners',
          'update_store_0_100_exposures',
          'update_gate_analytics_enabled',
          'update_gate_display_name',
          'release_pipeline_create',
          'release_pipeline_update',
          'release_pipeline_delete',
          'update_config_release_pipeline',
          'release_pipeline_trigger_create',
          'apply_experiment_review',
          'extend_experiment_pulse_end_date',
          'restart_experiment_pulse',
          'autotune_experiment_create',
          'autotune_experiment_delete',
          'autotune_experiment_snapshot_delete',
          'autotune_experiment_edit',
          'autotune_experiment_update_target_apps',
          'autotune_experiment_update_pulse_paused',
          'autotune_overrides_edit',
          'autotune_reviews_on',
          'experiment_data_report_delete',
          'experiment_discussion_post_create',
          'experiment_discussion_post_delete',
          'experiment_abandon',
          'experiment_pause_assignment',
          'experiment_stopped',
          'experiment_review_accept',
          'experiment_review_reject',
          'experiment_template_create',
          'update_template_decision_framework',
          'remove_template_decision_framework',
          'experiment_create',
          'experiment_review_create',
          'experiment_delete',
          'experiment_review_delete',
          'experiment_review_update_team',
          'experiment_snapshot_delete',
          'experiment_group_disable',
          'experiment_description_edit',
          'experiment_display_name_edit',
          'experiment_edit',
          'experiment_overrides_edit',
          'hypothesis_edit',
          'key_experiment_metrics_edit',
          'experiment_advanced_settings_edit',
          'experiment_decision_make',
          'experiment_restart',
          'experiment_rollout',
          'experiment_schedule_rollout',
          'experiment_reviews_on',
          'experiment_start',
          'schedule_experiment_start',
          'experiment_follow_toggle',
          'experiment_allowed_reviewers_update',
          'experiment_review_info_update',
          'update_experiment_enabled_non_prod_environments',
          'archive_experiment',
          'unarchive_experiment',
          'experiment_update_owners',
          'update_echidna_subtype',
          'setup_stratified_sampling',
          'experiment_update_target_apps',
          'experiment_update_subdimension_filter',
          'experiment_review_update_overrides',
          'experiment_review_update_owners',
          'experiment_update_decision_note',
          'experiment_update_summary_sections',
          'unattach_experiment_to_power_analysis_report',
          'attach_experiment_to_power_analysis_report',
          'pin_chart_to_summary',
          'set_geotest_design',
          'delete_geotest_design',
          'create_geotest_design',
          'experiment_assigned_to_layer',
          'holdout_create',
          'holdout_delete',
          'holdout_layer_parameter_values_update',
          'holdout_update',
          'holdout_update_owners',
          'metric_edit_definition',
          'metric_edit_description',
          'metric_add_tag',
          'metric_remove_tag',
          'schedule_delete_metric',
          'schedule_archive_metric',
          'update_metric_is_permanent',
          'update_metric_is_verified',
          'metric_reviews_on',
          'metric_disable_reviews_locally',
          'custom_metric_definition_edit',
          'custom_metric_definition_create',
          'custom_metric_definition_delete',
          'custom_metric_update_owners',
          'tag_metrics_bulk',
          'tag_create',
          'tag_delete',
          'tag_edit',
          'segment_create',
          'segment_update_owners',
          'layer_update_owners',
          'layer_review_commit',
          'layer_review_accept',
          'layer_parameter_add',
          'layer_create',
          'layer_review_create',
          'layer_review_delete',
          'layer_delete',
          'layer_snapshot_delete',
          'layer_description_edit',
          'layer_edit',
          'layer_overrides_edit',
          'layer_parameters_edit',
          'layer_review_reject',
          'layer_allowed_reviewers_update',
          'layer_review_info_update',
          'layer_update_target_apps',
          'delete_layer_parameter',
          'update_layer_parameter',
          'config_review_accept',
          'config_review_commit',
          'config_review_create',
          'config_delete',
          'config_review_delete',
          'config_reviews_disable',
          'config_review_reject',
          'config_resalt',
          'config_revert',
          'config_require_reviews',
          'config_state_toggle',
          'config_allowed_reviewers_update',
          'config_conditions_update',
          'config_default_value_update',
          'config_description_update',
          'config_display_name_update',
          'config_environments_update',
          'config_review_info_update',
          'config_review_update',
          'config_review_required_update',
          'config_add_tag',
          'config_edit_tags',
          'config_remove_tag',
          'config_monitoring_metrics_update',
          'config_edit_target_apps',
          'update_config_analytics_enabled',
          'set_self_approvals_blocked',
          'release_pipeline_completed',
          'pin_dashboard_for_company',
          'add_dashboard_widget',
          'create_dashboard',
          'delete_dashboard_widget',
          'edit_dashboard_widget',
          'delete_dashboard',
          'edit_dashboard_description',
          'edit_dashboard_name',
          'restore_dashboard',
          'update_dashboard_widgets_from_generated_tags',
          'dashboard_update_owners',
          'update_dashboard_settings',
          'create_topline_alert',
          'update_topline_alert',
          'delete_topline_alert',
          'active_user_definition_update',
          'company_create',
          'company_metric_management_update',
          'metric_allowed_reviewers_update',
          'metric_review_commit',
          'metric_review_create',
          'metric_review_info_update',
          'set_metric_directionality',
          'custom_metric_edit',
          'custom_metric_name_edit',
          'custom_metric_review_accept',
          'custom_metric_review_delete',
          'custom_metric_review_reject',
          'delete_metric',
          'archive_metric',
          'unarchive_metric',
          'cancel_delete_metric',
          'cancel_archive_metric',
          'edit_guardrail_metric_alert',
          'create_guardrail_metric_alert',
          'delete_guardrail_metric_alert',
          'resolve_guardrail_metric_alert',
          'unsnooze_guardrail_metric_alert',
          'update_echidna_metric_loading_window',
          'update_metric_review_required',
          'layer_reviews_on',
          'delete_tag',
          'ID_list_update',
          'update_gate_is_permanent',
          'load_echidna_metric',
          'update_server_sdk_configuration_rollback',
          'company_ID_type_add',
          'update_echidna_source_review_required',
          'AWS_marketplace_account_delete',
          'batch_cancel_company_invites',
          'batch_user_role_update',
          'company_basic_info_edit',
          'company_delete',
          'company_email_domain_config_delete',
          'company_environments_edit',
          'add_geo_type',
          'delete_geo_type',
          'company_ID_type_delete',
          'company_ID_type_edit',
          'company_invite_access_update',
          'update_entities_require_teams',
          'update_company_user_store_enabled',
          'company_member_remove',
          'company_metric_delete',
          'company_snapshot_delete',
          'config_id_type_update',
          'config_update_owners',
          'create_customer_app',
          'edit_target_app',
          'delete_target_app',
          'source_allowed_reviewers_update',
          'create_echidna_assignment_source',
          'create_echidna_entity_property_source',
          'create_echidna_metric_source',
          'create_echidna_data_quality_checks',
          'create_echidna_source_review',
          'accept_echidna_source_review',
          'commit_echidna_source_review',
          'reject_echidna_source_review',
          'update_echidna_source_review',
          'delete_echidna_source_review',
          'create_power_analysis_gate_query',
          'create_power_analysis_custom_query',
          'custom_pulse_query_create',
          'custom_pulse_query_delete',
          'custom_pulse_query_name_edit',
          'custom_query_toggle_favorite',
          'custom_sankey_delete',
          'delete_echidna_assignment_source',
          'delete_echidna_entity_property_source',
          'delete_echidna_metric_source',
          'delete_payment_method',
          'tag_update_owners',
          'modify_override_config',
          'modify_overrides',
          'remove_override_config',
          'scheduled_custom_pulse_query_create',
          'integration_delete',
          'integration_create',
          'integration_update',
          'scheduled_pulse_custom_query_delete',
          'scheduled_pulse_query_name_edit',
          'user_data_load',
          'organization_member_remove',
          'shared_report_link_upsert',
          'scheduled_pulse_rollups_update',
          'OIDC_configuration_delete',
          'project_review_group_delete',
          'SSO_disable',
          'project_description_edit',
          'project_owner_set',
          'user_role_update',
          'OIDC_configuration_upsert',
          'payment_entitlements_upsert',
          'project_review_group_upsert',
          'project_review_group_remove',
          'update_team_settings',
          'update_team_admins',
          'update_team_name',
          'update_team_description',
          'update_team',
          'shared_report_link_delete',
          'experiment_data_report_rename',
          'experiment_data_report_update_parameters',
          'event_dimension_update',
          'integration_set_enabled',
          'integration_update_disabled_events',
          'integration_update_outgoing_config',
          'integration_update_rate_limits',
          'integration_upsert',
          'ingestion_source_delete',
          'tag_configs_bulk',
          'org_api_key_create',
          'sdk_key_create',
          'sdk_key_deactivate',
          'sdk_key_delete',
          'secret_key_regenerate',
          'sdk_key_update_description',
          'set_api_share_key_access',
          'set_plan_type',
          'generate_integration_webhook_secret',
          'set_default_payment_method',
          'set_user_sampling_rate',
          'sdk_key_update_environments',
          'upsert_trigger_integration',
          'delete_trigger_integration',
          'dismiss_runaway_entity',
          'update_echidna_metric_source',
          'update_echidna_metric_source_name',
          'update_echidna_metric_tag_or_description',
          'update_echidna_assignment_source',
          'update_echidna_assignment_source_name',
          'update_echidna_assignment_source_loading_window',
          'update_echidna_entity_property_source',
          'update_echidna_entity_property_source_name',
          'update_echidna_source_owner',
          'update_precommit_hook',
          'load_echidna_pulse',
          'load_echidna_autotune_pulse',
          'load_echidna_assignment_source',
          'set_echidna_schedule_hour',
          'echidna_drop_tables',
          'upsert_user_role',
          'delete_user_role',
          'sdk_key_update_target_app',
          'set_gate_analytics_enabled_by_default',
          'set_dynamic_config_analytics_enabled_by_default',
          'set_gate_analytics_0_100_exposures_enabled',
          'update_bv3_subscription',
          'upsert_experiment_settings',
          'upsert_gate_settings',
          'sdk_key_update_scopes',
          'user_login',
          'param_store_create',
          'param_store_update',
          'set_bv3_plan_type',
          'set_echidna_project_pulse_schedule',
          'set_echidna_project_metric_schedule',
          'set_company_default_user_role',
          'set_company_session_replay_sampling_rate',
          'set_company_session_replay_settings',
          'cancel_echidna_dag',
          'set_require_target_app_for_new_entity',
          'add_segments_of_interest_property',
          'delete_segments_of_interest_property',
          'add_srm_debugger_custom_dimension',
          'delete_srm_debugger_custom_dimension',
          'param_store_delete',
          'setup_external_opt_in',
          'param_store_update_owners',
          'create_statsig_proxy',
          'update_echidna_assignment_source_is_verified',
          'update_echidna_metric_source_is_verified',
          'update_echidna_entity_property_source_is_verified',
          'update_echidna_source_is_verified',
          'set_automated_bot_removals',
          'pulse_results_export',
          'update_company_auto_capture_settings',
          'update_company_experiment_exclusion_segment',
          'set_stop_new_assignment_toggle',
          'set_stop_experiment_enabled',
          'update_company_remove_default_gates_setting',
          'set_whn_results_export_setting',
          'update_experiment_quality_score_settings',
          'update_experiment_salt',
          'update_precommit_webhook_key',
          'set_whn_table_ttls',
          'set_id_resolution_inferred_id',
          'set_id_resolution_labeled_id',
          'add_session_recordings_to_playlist',
          'delete_session_recordings_from_playlist',
          'delete_session_replay_playlist',
          'backfill_metric_results',
          'cancel_metric_backfills',
          'archive_org_project',
          'update_ai_assistance_enabled',
          'update_ai_business_context',
          'update_experiment_ai_settings',
          'upsert_ai_config_eval_groups',
          'upsert_user_store_client_targeting_properties',
          'set_ai_config_baseline_version',
          'update_experiment_quality_score_criteria',
        ]),
      ),
      actionTypes: z.optional(
        z.array(
          z.enum([
            'start_ai_config_version_evaluation_job',
            'clone_ai_config',
            'edit_ai_config_version',
            'delete_ai_config_version',
            'clone_ai_config_version',
            'ai_config_create',
            'create_ai_config_version',
            'upsert_ai_config_version',
            'create_ai_config_eval_grader',
            'edit_ai_config_eval_grader',
            'delete_ai_config_eval_grader',
            'set_enable_id_resolution_toggle',
            'dynamic_config_create',
            'dynamic_config_template_create',
            'dynamic_config_update_owners',
            'gate_overrides_update',
            'gate_template_create',
            'gate_create',
            'gate_update',
            'set_user_sampling_rate_for_gate',
            'gate_update_owners',
            'update_store_0_100_exposures',
            'update_gate_analytics_enabled',
            'update_gate_display_name',
            'release_pipeline_create',
            'release_pipeline_update',
            'release_pipeline_delete',
            'update_config_release_pipeline',
            'release_pipeline_trigger_create',
            'apply_experiment_review',
            'extend_experiment_pulse_end_date',
            'restart_experiment_pulse',
            'autotune_experiment_create',
            'autotune_experiment_delete',
            'autotune_experiment_snapshot_delete',
            'autotune_experiment_edit',
            'autotune_experiment_update_target_apps',
            'autotune_experiment_update_pulse_paused',
            'autotune_overrides_edit',
            'autotune_reviews_on',
            'experiment_data_report_delete',
            'experiment_discussion_post_create',
            'experiment_discussion_post_delete',
            'experiment_abandon',
            'experiment_pause_assignment',
            'experiment_stopped',
            'experiment_review_accept',
            'experiment_review_reject',
            'experiment_template_create',
            'update_template_decision_framework',
            'remove_template_decision_framework',
            'experiment_create',
            'experiment_review_create',
            'experiment_delete',
            'experiment_review_delete',
            'experiment_review_update_team',
            'experiment_snapshot_delete',
            'experiment_group_disable',
            'experiment_description_edit',
            'experiment_display_name_edit',
            'experiment_edit',
            'experiment_overrides_edit',
            'hypothesis_edit',
            'key_experiment_metrics_edit',
            'experiment_advanced_settings_edit',
            'experiment_decision_make',
            'experiment_restart',
            'experiment_rollout',
            'experiment_schedule_rollout',
            'experiment_reviews_on',
            'experiment_start',
            'schedule_experiment_start',
            'experiment_follow_toggle',
            'experiment_allowed_reviewers_update',
            'experiment_review_info_update',
            'update_experiment_enabled_non_prod_environments',
            'archive_experiment',
            'unarchive_experiment',
            'experiment_update_owners',
            'update_echidna_subtype',
            'setup_stratified_sampling',
            'experiment_update_target_apps',
            'experiment_update_subdimension_filter',
            'experiment_review_update_overrides',
            'experiment_review_update_owners',
            'experiment_update_decision_note',
            'experiment_update_summary_sections',
            'unattach_experiment_to_power_analysis_report',
            'attach_experiment_to_power_analysis_report',
            'pin_chart_to_summary',
            'set_geotest_design',
            'delete_geotest_design',
            'create_geotest_design',
            'experiment_assigned_to_layer',
            'holdout_create',
            'holdout_delete',
            'holdout_layer_parameter_values_update',
            'holdout_update',
            'holdout_update_owners',
            'metric_edit_definition',
            'metric_edit_description',
            'metric_add_tag',
            'metric_remove_tag',
            'schedule_delete_metric',
            'schedule_archive_metric',
            'update_metric_is_permanent',
            'update_metric_is_verified',
            'metric_reviews_on',
            'metric_disable_reviews_locally',
            'custom_metric_definition_edit',
            'custom_metric_definition_create',
            'custom_metric_definition_delete',
            'custom_metric_update_owners',
            'tag_metrics_bulk',
            'tag_create',
            'tag_delete',
            'tag_edit',
            'segment_create',
            'segment_update_owners',
            'layer_update_owners',
            'layer_review_commit',
            'layer_review_accept',
            'layer_parameter_add',
            'layer_create',
            'layer_review_create',
            'layer_review_delete',
            'layer_delete',
            'layer_snapshot_delete',
            'layer_description_edit',
            'layer_edit',
            'layer_overrides_edit',
            'layer_parameters_edit',
            'layer_review_reject',
            'layer_allowed_reviewers_update',
            'layer_review_info_update',
            'layer_update_target_apps',
            'delete_layer_parameter',
            'update_layer_parameter',
            'config_review_accept',
            'config_review_commit',
            'config_review_create',
            'config_delete',
            'config_review_delete',
            'config_reviews_disable',
            'config_review_reject',
            'config_resalt',
            'config_revert',
            'config_require_reviews',
            'config_state_toggle',
            'config_allowed_reviewers_update',
            'config_conditions_update',
            'config_default_value_update',
            'config_description_update',
            'config_display_name_update',
            'config_environments_update',
            'config_review_info_update',
            'config_review_update',
            'config_review_required_update',
            'config_add_tag',
            'config_edit_tags',
            'config_remove_tag',
            'config_monitoring_metrics_update',
            'config_edit_target_apps',
            'update_config_analytics_enabled',
            'set_self_approvals_blocked',
            'release_pipeline_completed',
            'pin_dashboard_for_company',
            'add_dashboard_widget',
            'create_dashboard',
            'delete_dashboard_widget',
            'edit_dashboard_widget',
            'delete_dashboard',
            'edit_dashboard_description',
            'edit_dashboard_name',
            'restore_dashboard',
            'update_dashboard_widgets_from_generated_tags',
            'dashboard_update_owners',
            'update_dashboard_settings',
            'create_topline_alert',
            'update_topline_alert',
            'delete_topline_alert',
            'active_user_definition_update',
            'company_create',
            'company_metric_management_update',
            'metric_allowed_reviewers_update',
            'metric_review_commit',
            'metric_review_create',
            'metric_review_info_update',
            'set_metric_directionality',
            'custom_metric_edit',
            'custom_metric_name_edit',
            'custom_metric_review_accept',
            'custom_metric_review_delete',
            'custom_metric_review_reject',
            'delete_metric',
            'archive_metric',
            'unarchive_metric',
            'cancel_delete_metric',
            'cancel_archive_metric',
            'edit_guardrail_metric_alert',
            'create_guardrail_metric_alert',
            'delete_guardrail_metric_alert',
            'resolve_guardrail_metric_alert',
            'unsnooze_guardrail_metric_alert',
            'update_echidna_metric_loading_window',
            'update_metric_review_required',
            'layer_reviews_on',
            'delete_tag',
            'ID_list_update',
            'update_gate_is_permanent',
            'load_echidna_metric',
            'update_server_sdk_configuration_rollback',
            'company_ID_type_add',
            'update_echidna_source_review_required',
            'AWS_marketplace_account_delete',
            'batch_cancel_company_invites',
            'batch_user_role_update',
            'company_basic_info_edit',
            'company_delete',
            'company_email_domain_config_delete',
            'company_environments_edit',
            'add_geo_type',
            'delete_geo_type',
            'company_ID_type_delete',
            'company_ID_type_edit',
            'company_invite_access_update',
            'update_entities_require_teams',
            'update_company_user_store_enabled',
            'company_member_remove',
            'company_metric_delete',
            'company_snapshot_delete',
            'config_id_type_update',
            'config_update_owners',
            'create_customer_app',
            'edit_target_app',
            'delete_target_app',
            'source_allowed_reviewers_update',
            'create_echidna_assignment_source',
            'create_echidna_entity_property_source',
            'create_echidna_metric_source',
            'create_echidna_data_quality_checks',
            'create_echidna_source_review',
            'accept_echidna_source_review',
            'commit_echidna_source_review',
            'reject_echidna_source_review',
            'update_echidna_source_review',
            'delete_echidna_source_review',
            'create_power_analysis_gate_query',
            'create_power_analysis_custom_query',
            'custom_pulse_query_create',
            'custom_pulse_query_delete',
            'custom_pulse_query_name_edit',
            'custom_query_toggle_favorite',
            'custom_sankey_delete',
            'delete_echidna_assignment_source',
            'delete_echidna_entity_property_source',
            'delete_echidna_metric_source',
            'delete_payment_method',
            'tag_update_owners',
            'modify_override_config',
            'modify_overrides',
            'remove_override_config',
            'scheduled_custom_pulse_query_create',
            'integration_delete',
            'integration_create',
            'integration_update',
            'scheduled_pulse_custom_query_delete',
            'scheduled_pulse_query_name_edit',
            'user_data_load',
            'organization_member_remove',
            'shared_report_link_upsert',
            'scheduled_pulse_rollups_update',
            'OIDC_configuration_delete',
            'project_review_group_delete',
            'SSO_disable',
            'project_description_edit',
            'project_owner_set',
            'user_role_update',
            'OIDC_configuration_upsert',
            'payment_entitlements_upsert',
            'project_review_group_upsert',
            'project_review_group_remove',
            'update_team_settings',
            'update_team_admins',
            'update_team_name',
            'update_team_description',
            'update_team',
            'shared_report_link_delete',
            'experiment_data_report_rename',
            'experiment_data_report_update_parameters',
            'event_dimension_update',
            'integration_set_enabled',
            'integration_update_disabled_events',
            'integration_update_outgoing_config',
            'integration_update_rate_limits',
            'integration_upsert',
            'ingestion_source_delete',
            'tag_configs_bulk',
            'org_api_key_create',
            'sdk_key_create',
            'sdk_key_deactivate',
            'sdk_key_delete',
            'secret_key_regenerate',
            'sdk_key_update_description',
            'set_api_share_key_access',
            'set_plan_type',
            'generate_integration_webhook_secret',
            'set_default_payment_method',
            'set_user_sampling_rate',
            'sdk_key_update_environments',
            'upsert_trigger_integration',
            'delete_trigger_integration',
            'dismiss_runaway_entity',
            'update_echidna_metric_source',
            'update_echidna_metric_source_name',
            'update_echidna_metric_tag_or_description',
            'update_echidna_assignment_source',
            'update_echidna_assignment_source_name',
            'update_echidna_assignment_source_loading_window',
            'update_echidna_entity_property_source',
            'update_echidna_entity_property_source_name',
            'update_echidna_source_owner',
            'update_precommit_hook',
            'load_echidna_pulse',
            'load_echidna_autotune_pulse',
            'load_echidna_assignment_source',
            'set_echidna_schedule_hour',
            'echidna_drop_tables',
            'upsert_user_role',
            'delete_user_role',
            'sdk_key_update_target_app',
            'set_gate_analytics_enabled_by_default',
            'set_dynamic_config_analytics_enabled_by_default',
            'set_gate_analytics_0_100_exposures_enabled',
            'update_bv3_subscription',
            'upsert_experiment_settings',
            'upsert_gate_settings',
            'sdk_key_update_scopes',
            'user_login',
            'param_store_create',
            'param_store_update',
            'set_bv3_plan_type',
            'set_echidna_project_pulse_schedule',
            'set_echidna_project_metric_schedule',
            'set_company_default_user_role',
            'set_company_session_replay_sampling_rate',
            'set_company_session_replay_settings',
            'cancel_echidna_dag',
            'set_require_target_app_for_new_entity',
            'add_segments_of_interest_property',
            'delete_segments_of_interest_property',
            'add_srm_debugger_custom_dimension',
            'delete_srm_debugger_custom_dimension',
            'param_store_delete',
            'setup_external_opt_in',
            'param_store_update_owners',
            'create_statsig_proxy',
            'update_echidna_assignment_source_is_verified',
            'update_echidna_metric_source_is_verified',
            'update_echidna_entity_property_source_is_verified',
            'update_echidna_source_is_verified',
            'set_automated_bot_removals',
            'pulse_results_export',
            'update_company_auto_capture_settings',
            'update_company_experiment_exclusion_segment',
            'set_stop_new_assignment_toggle',
            'set_stop_experiment_enabled',
            'update_company_remove_default_gates_setting',
            'set_whn_results_export_setting',
            'update_experiment_quality_score_settings',
            'update_experiment_salt',
            'update_precommit_webhook_key',
            'set_whn_table_ttls',
            'set_id_resolution_inferred_id',
            'set_id_resolution_labeled_id',
            'add_session_recordings_to_playlist',
            'delete_session_recordings_from_playlist',
            'delete_session_replay_playlist',
            'backfill_metric_results',
            'cancel_metric_backfills',
            'archive_org_project',
            'update_ai_assistance_enabled',
            'update_ai_business_context',
            'update_experiment_ai_settings',
            'upsert_ai_config_eval_groups',
            'upsert_user_store_client_targeting_properties',
            'set_ai_config_baseline_version',
            'update_experiment_quality_score_criteria',
          ]),
        ),
      ),
      startDate: z.optional(z.string()),
      endDate: z.optional(z.string()),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Audit logs listed successfully.
 */
export const zGetConsoleV1AuditLogsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zAuditLogDto)),
  }),
)

export const zGetConsoleV1AutotunesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Autotune Experiments listed successfully.
 */
export const zGetConsoleV1AutotunesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zAutotuneExperimentDto)),
  }),
)

export const zPostConsoleV1AutotunesData = z.object({
  body: zAutotuneCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Autotune Success
 */
export const zPostConsoleV1AutotunesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAutotuneExperimentDto),
  }),
)

export const zDeleteConsoleV1AutotunesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Autotune Success
 */
export const zDeleteConsoleV1AutotunesByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1AutotunesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Autotune Success
 */
export const zGetConsoleV1AutotunesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAutotuneExperimentDto),
  }),
)

export const zPatchConsoleV1AutotunesByIdData = z.object({
  body: zAutotunePartialUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Partially Update Autotune Success
 */
export const zPatchConsoleV1AutotunesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAutotuneExperimentDto),
  }),
)

export const zPostConsoleV1AutotunesByIdData = z.object({
  body: zAutotuneFullUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Fully Update Autotune Success
 */
export const zPostConsoleV1AutotunesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAutotuneExperimentDto),
  }),
)

export const zPutConsoleV1AutotunesByIdMakeDecisionData = z.object({
  body: zExperimentStatusUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Finish Experiment Early Success
 */
export const zPutConsoleV1AutotunesByIdMakeDecisionResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1AutotunesByIdResetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Reset Experiment Success
 */
export const zPutConsoleV1AutotunesByIdResetResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1AutotunesByIdStartData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Start Autotune Experiment Success
 */
export const zPutConsoleV1AutotunesByIdStartResponse = z.object({
  message: z.optional(z.string()),
})

export const zPostConsoleV1ChangeValidationData = z.object({
  body: zChangeValidationDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Change Validation Success
 */
export const zPostConsoleV1ChangeValidationResponse = z.object({
  message: z.optional(z.string()),
})

export const zPatchConsoleV1ChangeValidationMessageData = z.object({
  body: zChangeValidationUpdateMessageDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Change Validation Message Success
 */
export const zPatchConsoleV1ChangeValidationMessageResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1CompanyData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get company info response
 */
export const zGetConsoleV1CompanyResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zCompanyInfoResponseDto),
  }),
)

export const zGetConsoleV1DynamicConfigsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      releasePipelineID: z.optional(z.union([z.string(), z.null()])),
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Dynamic Configs Success
 */
export const zGetConsoleV1DynamicConfigsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zDynamicConfigDto)),
  }),
)

export const zPostConsoleV1DynamicConfigsData = z.object({
  body: zDynamicConfigCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create gate response
 */
export const zPostConsoleV1DynamicConfigsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zDeleteConsoleV1DynamicConfigsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Dynamic Config Response
 */
export const zDeleteConsoleV1DynamicConfigsByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1DynamicConfigsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Dynamic Config Response
 */
export const zGetConsoleV1DynamicConfigsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zPatchConsoleV1DynamicConfigsByIdData = z.object({
  body: zDynamicConfigPartialUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Partially Update Dynamic Config Response
 */
export const zPatchConsoleV1DynamicConfigsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zPostConsoleV1DynamicConfigsByIdData = z.object({
  body: zDynamicConfigFullUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Fully Update Dynamic Config Response
 */
export const zPostConsoleV1DynamicConfigsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zPutConsoleV1DynamicConfigsByIdDisableData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Disable Dynamic Config Response
 */
export const zPutConsoleV1DynamicConfigsByIdDisableResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zPutConsoleV1DynamicConfigsByIdEnableData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Enable Dynamic Config Response
 */
export const zPutConsoleV1DynamicConfigsByIdEnableResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zDeleteConsoleV1DynamicConfigsByIdRuleByRuleIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    ruleId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Dynamic Config Rule Response
 */
export const zDeleteConsoleV1DynamicConfigsByIdRuleByRuleIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zGetConsoleV1DynamicConfigsByIdRuleByRuleIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    ruleId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Specific Dynamic Config Rule Response
 */
export const zGetConsoleV1DynamicConfigsByIdRuleByRuleIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigRuleDto),
  }),
)

export const zPatchConsoleV1DynamicConfigsByIdRuleByRuleIdData = z.object({
  body: zDynamicConfigRulePartialDto,
  path: z.object({
    id: z.string(),
    ruleId: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Dynamic Config Rule Response
 */
export const zPatchConsoleV1DynamicConfigsByIdRuleByRuleIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zDynamicConfigDto),
  }),
)

export const zGetConsoleV1DynamicConfigsByIdRulesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Dynamic Config Rules Response
 */
export const zGetConsoleV1DynamicConfigsByIdRulesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zDynamicConfigRulesDto)),
  }),
)

export const zGetConsoleV1DynamicConfigsByIdVersionsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Dynamic Config Versions Success
 */
export const zGetConsoleV1DynamicConfigsByIdVersionsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zDynamicConfigDto)),
  }),
)

export const zGetConsoleV1EnvironmentsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Environments Response
 */
export const zGetConsoleV1EnvironmentsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEnvironmentsContractDto),
  }),
)

export const zPostConsoleV1EnvironmentsData = z.object({
  body: zEnvironmentsUpdateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Environments Response
 */
export const zPostConsoleV1EnvironmentsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEnvironmentsContractDto),
  }),
)

export const zGetConsoleV1EventsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Events response
 */
export const zGetConsoleV1EventsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zLoggedEventDto)),
  }),
)

export const zGetConsoleV1EventsByEventNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    eventName: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get specific events response
 */
export const zGetConsoleV1EventsByEventNameResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zLoggedEventDto)),
  }),
)

export const zGetConsoleV1EventsByEventNameMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    eventName: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get metrics from events response
 */
export const zGetConsoleV1EventsByEventNameMetricsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalMetricDefinitionContractDto)),
  }),
)

export const zGetConsoleV1ExperimentsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      layerID: z.optional(z.string()),
      idType: z.optional(z.string()),
      teamID: z.optional(z.union([z.string(), z.null()])),
      status: z.optional(
        z.union([
          z.literal('active'),
          z.literal('setup'),
          z.literal('decision_made'),
          z.literal('abandoned'),
          z.literal('archived'),
          z.literal('experiment_stopped'),
          z.literal('assignment_stopped'),
          z.array(
            z.enum([
              'active',
              'setup',
              'decision_made',
              'abandoned',
              'archived',
              'experiment_stopped',
              'assignment_stopped',
            ]),
          ),
        ]),
      ),
      targetAppID: z.optional(z.string()),
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Experiments Success
 */
export const zGetConsoleV1ExperimentsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalExperimentDto)),
  }),
)

export const zPostConsoleV1ExperimentsData = z.object({
  body: zExperimentCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Experiment Success
 */
export const zPostConsoleV1ExperimentsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zDeleteConsoleV1ExperimentsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Experiment Success
 */
export const zDeleteConsoleV1ExperimentsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zGetConsoleV1ExperimentsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Experiment Success
 */
export const zGetConsoleV1ExperimentsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zPatchConsoleV1ExperimentsByIdData = z.object({
  body: zExperimentPartialUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Partially Update Experiment Success
 */
export const zPatchConsoleV1ExperimentsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zPostConsoleV1ExperimentsByIdData = z.object({
  body: zExperimentFullUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Fully Update Experiment Success
 */
export const zPostConsoleV1ExperimentsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zPutConsoleV1ExperimentsByIdAbandonData = z.object({
  body: zExperimentAbandonDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Abandon Experiment Success
 */
export const zPutConsoleV1ExperimentsByIdAbandonResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1ExperimentsByIdArchiveData = z.object({
  body: zExperimentArchiveDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Archive Experiment Success
 */
export const zPutConsoleV1ExperimentsByIdArchiveResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1ExperimentsByIdCumulativeExposuresData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get cumulative exposures success
 */
export const zGetConsoleV1ExperimentsByIdCumulativeExposuresResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zCumulativeExposureResponseDto),
  }),
)

export const zPostConsoleV1ExperimentsByIdDisableGroupsData = z.object({
  body: zEnableDisableGroupsDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Disable experiment groups
 */
export const zPostConsoleV1ExperimentsByIdDisableGroupsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zPostConsoleV1ExperimentsByIdEnableGroupsData = z.object({
  body: zEnableDisableGroupsDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Enable experiment groups
 */
export const zPostConsoleV1ExperimentsByIdEnableGroupsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalExperimentDto),
  }),
)

export const zPostConsoleV1ExperimentsByIdLoadPulseData = z.object({
  body: zEchidnaLoadPulseQueryDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      refresh: z.optional(z.enum(['full', 'incremental', 'metric'])),
      metricIDs: z.optional(z.array(z.string())),
      ruleId: z.optional(z.string()),
      turboMode: z.optional(z.boolean()),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Load Pulse Success
 */
export const zPostConsoleV1ExperimentsByIdLoadPulseResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1ExperimentsByIdMakeDecisionData = z.object({
  body: zExperimentStatusUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Make Experiment Decision Success
 */
export const zPutConsoleV1ExperimentsByIdMakeDecisionResponse = z.object({
  message: z.optional(z.string()),
})

export const zDeleteConsoleV1ExperimentsByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Update Experiment Overrides Success
 */
export const zDeleteConsoleV1ExperimentsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExperimentOverridesDto),
  }),
)

export const zGetConsoleV1ExperimentsByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Experiment Overrides Success
 */
export const zGetConsoleV1ExperimentsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExperimentOverridesDto),
  }),
)

export const zPatchConsoleV1ExperimentsByIdOverridesData = z.object({
  body: zExperimentOverridesDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Partially Update Experiment Overrides Success
 */
export const zPatchConsoleV1ExperimentsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExperimentOverridesDto),
  }),
)

export const zPostConsoleV1ExperimentsByIdOverridesData = z.object({
  body: zExperimentOverridesDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Experiment Overrides Success
 */
export const zPostConsoleV1ExperimentsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExperimentOverridesDto),
  }),
)

export const zGetConsoleV1ExperimentsByIdPulseLoadHistoryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Pulse Load History
 */
export const zGetConsoleV1ExperimentsByIdPulseLoadHistoryResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zPulseLoadHistoryDto)),
  }),
)

export const zGetConsoleV1ExperimentsByIdPulseResultsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.object({
    control: z.string(),
    test: z.string(),
    cuped: z.optional(z.string()),
    confidence: z.optional(z.string()),
    applyBonferroniPerVariant: z.optional(z.string()),
    applyBonferroniPerMetric: z.optional(z.string()),
    bonferroniPrimaryMetricWeight: z.optional(z.string()),
    applyBenjaminiHochbergPerMetric: z.optional(z.string()),
    applyBenjaminiHochbergPerVariant: z.optional(z.string()),
    date: z.optional(z.string()),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Pulse Results Success
 */
export const zGetConsoleV1ExperimentsByIdPulseResultsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExperimentPulseResultsDto),
  }),
)

export const zPutConsoleV1ExperimentsByIdResetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Reset Experiment Success
 */
export const zPutConsoleV1ExperimentsByIdResetResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1ExperimentsByIdStartData = z.object({
  body: zExperimentStartDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Start Experiment Success
 */
export const zPutConsoleV1ExperimentsByIdStartResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1ExperimentsByIdUnarchiveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Unarchive Experiment Success
 */
export const zPutConsoleV1ExperimentsByIdUnarchiveResponse = z.object({
  message: z.optional(z.string()),
})

export const zDeleteConsoleV1ExperimentsAssignmentSourceByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Assignment Source response
 */
export const zDeleteConsoleV1ExperimentsAssignmentSourceByNameResponse = z.object({
  message: z.optional(z.string()),
})

export const zPatchConsoleV1ExperimentsAssignmentSourceByNameData = z.object({
  body: zAssignmentSourcePartialUpdateDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Patch Assignment Source response
 */
export const zPatchConsoleV1ExperimentsAssignmentSourceByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAssignmentSourceContractDto),
  }),
)

export const zPostConsoleV1ExperimentsAssignmentSourceByNameData = z.object({
  body: zAssignmentSourceQueryUpdateDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Post Assignment Source response
 */
export const zPostConsoleV1ExperimentsAssignmentSourceByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAssignmentSourceContractDto),
  }),
)

export const zGetConsoleV1ExperimentsAssignmentSourcesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Assignment Sources response
 */
export const zGetConsoleV1ExperimentsAssignmentSourcesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zAssignmentSourceContractDto)),
  }),
)

export const zPostConsoleV1ExperimentsAssignmentSourcesData = z.object({
  body: zAssignmentSourceCreationDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Assignment Source response
 */
export const zPostConsoleV1ExperimentsAssignmentSourcesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zAssignmentSourceContractDto),
  }),
)

export const zGetConsoleV1ExperimentsEntityPropertiesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Entity Property Sources response
 */
export const zGetConsoleV1ExperimentsEntityPropertiesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zEntityPropertySourceDto)),
  }),
)

export const zPostConsoleV1ExperimentsEntityPropertiesData = z.object({
  body: zEntityPropertySourceCreationDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Entity Property Source response
 */
export const zPostConsoleV1ExperimentsEntityPropertiesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEntityPropertySourceDto),
  }),
)

export const zDeleteConsoleV1ExperimentsEntityPropertyByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Entity Property Source response
 */
export const zDeleteConsoleV1ExperimentsEntityPropertyByNameResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1ExperimentsEntityPropertyByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Entity Property Source response
 */
export const zGetConsoleV1ExperimentsEntityPropertyByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEntityPropertySourceDto),
  }),
)

export const zPatchConsoleV1ExperimentsEntityPropertyByNameData = z.object({
  body: zEntityPropertySourcePartialUpdateDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Patch Entity Property Source response
 */
export const zPatchConsoleV1ExperimentsEntityPropertyByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEntityPropertySourceDto),
  }),
)

export const zPostConsoleV1ExperimentsEntityPropertyByNameData = z.object({
  body: zEntityPropertySourceQueryUpdateDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Post Entity Property Source response
 */
export const zPostConsoleV1ExperimentsEntityPropertyByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zEntityPropertySourceDto),
  }),
)

export const zGetConsoleV1ExperimentsQualifyingEventsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List metric source response
 */
export const zGetConsoleV1ExperimentsQualifyingEventsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zMetricSourceContractDto)),
  }),
)

export const zPostConsoleV1ExperimentsQualifyingEventsData = z.object({
  body: zMetricSourceCreationContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create qualifying event response
 */
export const zPostConsoleV1ExperimentsQualifyingEventsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zDeleteConsoleV1ExperimentsQualifyingEventsByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Qualifying Event response
 */
export const zDeleteConsoleV1ExperimentsQualifyingEventsByNameResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1ExperimentsQualifyingEventsByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Qualifying Event response
 */
export const zGetConsoleV1ExperimentsQualifyingEventsByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zPostConsoleV1ExperimentsQualifyingEventsByNameData = z.object({
  body: zMetricSourceUpdateContractDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Qualifying Event response
 */
export const zPostConsoleV1ExperimentsQualifyingEventsByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zGetConsoleV1ExposureCountData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      experiments: z.optional(z.union([z.string(), z.array(z.string()).max(25)])),
      gates: z.optional(z.union([z.string(), z.array(z.string()).max(25)])),
      dynamicConfigs: z.optional(z.union([z.string(), z.array(z.string()).max(25)])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Experiment Success
 */
export const zGetConsoleV1ExposureCountResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExposureCountDto),
  }),
)

export const zGetConsoleV1GatesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      idType: z.optional(z.union([z.string(), z.array(z.string())])),
      type: z.optional(z.enum(['TEMPORARY', 'PERMANENT', 'STALE', 'TEMPLATE'])),
      typeReason: z.optional(
        z.enum([
          'NONE',
          'STALE_PROBABLY_LAUNCHED',
          'STALE_PROBABLY_UNLAUNCHED',
          'STALE_PROBABLY_FORGOTTEN',
          'STALE_NO_RULES',
          'STALE_PROBABLY_DEAD_CHECK',
          'STALE_EMPTY_CHECKS',
          'STALE_ALL_TRUE',
          'STALE_ALL_FALSE',
        ]),
      ),
      passRate: z.optional(
        z.union([z.literal('0'), z.literal('100'), z.literal('INBETWEEN'), z.array(z.enum(['0', '100', 'INBETWEEN']))]),
      ),
      rolloutRate: z.optional(
        z.union([z.literal('0'), z.literal('100'), z.literal('INBETWEEN'), z.array(z.enum(['0', '100', 'INBETWEEN']))]),
      ),
      releasePipelineID: z.optional(z.union([z.string(), z.null()])),
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List gates success
 */
export const zGetConsoleV1GatesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalGateDto)),
  }),
)

export const zPostConsoleV1GatesData = z.object({
  body: zGateCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create gate response
 */
export const zPostConsoleV1GatesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zDeleteConsoleV1GatesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete gate response
 */
export const zDeleteConsoleV1GatesByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1GatesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get gate response
 */
export const zGetConsoleV1GatesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPatchConsoleV1GatesByIdData = z.object({
  body: zGatePartialUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update gate response
 */
export const zPatchConsoleV1GatesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPostConsoleV1GatesByIdData = z.object({
  body: zGateFullUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update gate response
 */
export const zPostConsoleV1GatesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPutConsoleV1GatesByIdArchiveData = z.object({
  body: zArchiveSchemaDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Archive gate response
 */
export const zPutConsoleV1GatesByIdArchiveResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPutConsoleV1GatesByIdDisableData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Launch gate response
 */
export const zPutConsoleV1GatesByIdDisableResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPutConsoleV1GatesByIdEnableData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Enable gate response
 */
export const zPutConsoleV1GatesByIdEnableResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPutConsoleV1GatesByIdLaunchData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Launch gate response
 */
export const zPutConsoleV1GatesByIdLaunchResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPostConsoleV1GatesByIdLoadPulseData = z.object({
  body: zEchidnaGateLoadPulseQueryDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Load Pulse Gate Response
 */
export const zPostConsoleV1GatesByIdLoadPulseResponse = z.object({
  message: z.optional(z.string()),
})

export const zDeleteConsoleV1GatesByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Gate Override Success
 */
export const zDeleteConsoleV1GatesByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zGetConsoleV1GatesByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Gate Override Success
 */
export const zGetConsoleV1GatesByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zPatchConsoleV1GatesByIdOverridesData = z.object({
  body: zUpdateOverridesContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Add Gate Override Success
 */
export const zPatchConsoleV1GatesByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zPostConsoleV1GatesByIdOverridesData = z.object({
  body: zUpdateOverridesContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Gate Override Success
 */
export const zPostConsoleV1GatesByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zPostConsoleV1GatesByIdRuleData = z.object({
  body: zRuleDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Add Gate Rule Response
 */
export const zPostConsoleV1GatesByIdRuleResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zGetConsoleV1GatesByIdRulesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get gate rules response
 */
export const zGetConsoleV1GatesByIdRulesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zGateRulesDto)),
  }),
)

export const zPatchConsoleV1GatesByIdRulesData = z.object({
  body: zMultiRuleUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update gate response
 */
export const zPatchConsoleV1GatesByIdRulesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPostConsoleV1GatesByIdRulesData = z.object({
  body: zMultiRuleDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Add Multiple Gate Rules Response
 */
export const zPostConsoleV1GatesByIdRulesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zDeleteConsoleV1GatesByIdRulesByRuleIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    ruleID: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update gate response
 */
export const zDeleteConsoleV1GatesByIdRulesByRuleIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zPatchConsoleV1GatesByIdRulesByRuleIdData = z.object({
  body: zRuleUpdateDto,
  path: z.object({
    id: z.string(),
    ruleID: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update gate response
 */
export const zPatchConsoleV1GatesByIdRulesByRuleIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zGetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    ruleID: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Pulse Load History
 */
export const zGetConsoleV1GatesByIdRulesByRuleIdPulseLoadHistoryResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zPulseLoadHistoryDto)),
  }),
)

export const zGetConsoleV1GatesByIdRulesByRuleIdPulseResultsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    ruleID: z.string(),
  }),
  query: z.optional(
    z.object({
      cuped: z.optional(z.string()),
      confidence: z.optional(z.string()),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Pulse Results Success
 */
export const zGetConsoleV1GatesByIdRulesByRuleIdPulseResultsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zGatePulseResultsDto),
  }),
)

export const zPutConsoleV1GatesByIdUnarchiveData = z.object({
  body: zUnarchiveSchemaDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Unarchive gate response
 */
export const zPutConsoleV1GatesByIdUnarchiveResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalGateDto),
  }),
)

export const zGetConsoleV1GatesByIdVersionsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Gate Versions Success
 */
export const zGetConsoleV1GatesByIdVersionsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalGateDto)),
  }),
)

export const zGetConsoleV1HoldoutsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List holdouts response
 */
export const zGetConsoleV1HoldoutsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zHoldoutDto)),
  }),
)

export const zPostConsoleV1HoldoutsData = z.object({
  body: zHoldoutCreateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create holdout response
 */
export const zPostConsoleV1HoldoutsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zHoldoutDto),
  }),
)

export const zDeleteConsoleV1HoldoutsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete holdout response
 */
export const zDeleteConsoleV1HoldoutsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zHoldoutDto),
  }),
)

export const zGetConsoleV1HoldoutsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get holdout by id response
 */
export const zGetConsoleV1HoldoutsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zHoldoutDto),
  }),
)

export const zPatchConsoleV1HoldoutsByIdData = z.object({
  body: zHoldoutPartialUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update holdout response
 */
export const zPatchConsoleV1HoldoutsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zHoldoutDto),
  }),
)

export const zPostConsoleV1HoldoutsByIdData = z.object({
  body: zHoldoutFullUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update holdout response
 */
export const zPostConsoleV1HoldoutsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zHoldoutDto),
  }),
)

export const zDeleteConsoleV1HoldoutsByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Remove Holdout Overrides Success
 */
export const zDeleteConsoleV1HoldoutsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zGetConsoleV1HoldoutsByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Holdout Overrides Success
 */
export const zGetConsoleV1HoldoutsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zPatchConsoleV1HoldoutsByIdOverridesData = z.object({
  body: zUpdateOverridesContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Add Holdout Overrides Success
 */
export const zPatchConsoleV1HoldoutsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zPostConsoleV1HoldoutsByIdOverridesData = z.object({
  body: zUpdateOverridesContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Holdout Overrides Success
 */
export const zPostConsoleV1HoldoutsByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zOverrideDto),
  }),
)

export const zGetConsoleV1HoldoutsByIdPulseResultsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      cuped: z.optional(z.string()),
      confidence: z.optional(z.string()),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Pulse Results Success
 */
export const zGetConsoleV1HoldoutsByIdPulseResultsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zGatePulseResultsDto),
  }),
)

export const zDeleteConsoleV1IngestionData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    dataset: z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties']),
    source_name: z.optional(z.string()),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Ingestion Success
 */
export const zDeleteConsoleV1IngestionResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionDto),
  }),
)

export const zGetConsoleV1IngestionData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    type: z.enum(['redshift', 'bigquery-v2', 'snowflake-v2', 'databricks', 'azure-synapse', 's3', 'athena', 'adls']),
    dataset: z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties']),
    source_name: z.optional(z.string()),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Ingestion Success
 */
export const zGetConsoleV1IngestionResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionDto),
  }),
)

export const zPatchConsoleV1IngestionData = z.object({
  body: zIngestionUpdateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Ingestion Success
 */
export const zPatchConsoleV1IngestionResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionDto),
  }),
)

export const zPostConsoleV1IngestionData = z.object({
  body: zIngestionSourceCreateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Ingestion Success
 */
export const zPostConsoleV1IngestionResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionDto),
  }),
)

export const zPostConsoleV1IngestionBackfillData = z.object({
  body: zIngestionBackfillContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Backfill Ingestion Success
 */
export const zPostConsoleV1IngestionBackfillResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionBackfillDataDto),
  }),
)

export const zPostConsoleV1IngestionConnectionDatabricksData = z.object({
  body: zIngestionCreateDatabricksConnectionContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Ingestion Databricks Success
 */
export const zPostConsoleV1IngestionConnectionDatabricksResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionDto),
  }),
)

export const zGetConsoleV1IngestionEventsCountData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    source_name: z.optional(z.string()),
    event_name: z.optional(z.string()),
    start_date: z.string(),
    end_date: z.string(),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Ingestion Event Count Success
 */
export const zGetConsoleV1IngestionEventsCountResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionEventCountResponseDto),
  }),
)

export const zGetConsoleV1IngestionEventsDeltaData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    source_name: z.optional(z.string()),
    event_name: z.optional(z.string()),
    start_date: z.string(),
    end_date: z.string(),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Ingestion Event Delta Ledger Success
 */
export const zGetConsoleV1IngestionEventsDeltaResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionEventDeltaResponseDto),
  }),
)

export const zGetConsoleV1IngestionRunsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Ingestion Runs Success
 */
export const zGetConsoleV1IngestionRunsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zIngestionRunDataContractDto)),
  }),
)

export const zGetConsoleV1IngestionRunsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Ingestion Run Success
 */
export const zGetConsoleV1IngestionRunsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionRunDataContractDto),
  }),
)

export const zGetConsoleV1IngestionScheduleData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    dataset: z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties']),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Ingestion Schedule Success
 */
export const zGetConsoleV1IngestionScheduleResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionScheduleDto),
  }),
)

export const zPostConsoleV1IngestionScheduleData = z.object({
  body: zIngestionScheduleUpdateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Ingestion Schedule Success
 */
export const zPostConsoleV1IngestionScheduleResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIngestionScheduleDto),
  }),
)

export const zGetConsoleV1IngestionStatusData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    startDate: z.string(),
    endDate: z.string(),
    source: z.optional(z.string()),
    dataset: z.optional(z.enum(['Events', 'Metrics', 'export_exposures', 'entity_properties'])),
    status: z.optional(
      z.enum([
        'IMPORT_SUCCESSFUL',
        'LOADED_EMPTY_DATA',
        'IMPORT_SCHEDULED',
        'IMPORT_RESCHEDULED',
        'IMPORT_STARTED',
        'BACKFILL_REQUESTED',
        'CONNECTION_CONFIG_ERROR',
        'SSH_ERROR',
        'QUERY_CONSTRUCTION_ERROR',
        'INTERNAL_WRITE_ERROR_METRICS',
        'INTERNAL_WRITE_ERROR_EVENTS',
        'INTERNAL_WRITE_ERROR_EXPOSURES',
        'QUERY_ERROR',
        'SETUP_ERROR',
        'AUTHENTICATION_ERROR',
        'CONNECTION_ERROR',
        'BULK_LOAD_ERROR',
        'BULK_LOAD_SUCCESSFUL',
        '%Other',
      ]),
    ),
    statuses: z.optional(
      z.array(
        z.enum([
          'IMPORT_SUCCESSFUL',
          'LOADED_EMPTY_DATA',
          'IMPORT_SCHEDULED',
          'IMPORT_RESCHEDULED',
          'IMPORT_STARTED',
          'BACKFILL_REQUESTED',
          'CONNECTION_CONFIG_ERROR',
          'SSH_ERROR',
          'QUERY_CONSTRUCTION_ERROR',
          'INTERNAL_WRITE_ERROR_METRICS',
          'INTERNAL_WRITE_ERROR_EVENTS',
          'INTERNAL_WRITE_ERROR_EXPOSURES',
          'QUERY_ERROR',
          'SETUP_ERROR',
          'AUTHENTICATION_ERROR',
          'CONNECTION_ERROR',
          'BULK_LOAD_ERROR',
          'BULK_LOAD_SUCCESSFUL',
          '%Other',
        ]),
      ),
    ),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Ingestions Status Success
 */
export const zGetConsoleV1IngestionStatusResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zIngestionStatusDto)),
  }),
)

export const zGetConsoleV1KeysData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      primaryTargetApp: z.optional(z.string()),
      environment: z.optional(z.string()),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Keys listed successfully
 */
export const zGetConsoleV1KeysResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zKeyDto)),
  }),
)

export const zPostConsoleV1KeysData = z.object({
  body: zKeyCreateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key created successfully
 */
export const zPostConsoleV1KeysResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zKeyDto),
  }),
)

export const zDeleteConsoleV1KeysByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key deleted successfully
 */
export const zDeleteConsoleV1KeysByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1KeysByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key read successfully
 */
export const zGetConsoleV1KeysByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zKeyDto),
  }),
)

export const zPatchConsoleV1KeysByIdData = z.object({
  body: zKeyUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key updated successfully
 */
export const zPatchConsoleV1KeysByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zKeyDto),
  }),
)

export const zPatchConsoleV1KeysByIdDeactivateData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key deactivated successfully
 */
export const zPatchConsoleV1KeysByIdDeactivateResponse = z.object({
  message: z.optional(z.string()),
})

export const zPatchConsoleV1KeysByIdRotateData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Key rotated successfully
 */
export const zPatchConsoleV1KeysByIdRotateResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zKeyDto),
  }),
)

export const zGetConsoleV1LayersData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Layers response
 */
export const zGetConsoleV1LayersResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zLayerContractDto)),
  }),
)

export const zPostConsoleV1LayersData = z.object({
  body: zLayerCreateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Layer Response
 */
export const zPostConsoleV1LayersResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerContractDto),
  }),
)

export const zDeleteConsoleV1LayersByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete layer repsonse
 */
export const zDeleteConsoleV1LayersByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1LayersByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get one layer response
 */
export const zGetConsoleV1LayersByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerContractDto),
  }),
)

export const zPatchConsoleV1LayersByIdData = z.object({
  body: zLayerPartialUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Partial update layer response
 */
export const zPatchConsoleV1LayersByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerContractDto),
  }),
)

export const zPostConsoleV1LayersByIdData = z.object({
  body: zLayerFullUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update layer response
 */
export const zPostConsoleV1LayersByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerContractDto),
  }),
)

export const zGetConsoleV1LayersByIdExperimentsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Experiment related to Layer Success
 */
export const zGetConsoleV1LayersByIdExperimentsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalExperimentDto)),
  }),
)

export const zDeleteConsoleV1LayersByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Update Layer Overrides Success
 */
export const zDeleteConsoleV1LayersByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerOverridesDto),
  }),
)

export const zGetConsoleV1LayersByIdOverridesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Layer Overrides Success
 */
export const zGetConsoleV1LayersByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerOverridesDto),
  }),
)

export const zPatchConsoleV1LayersByIdOverridesData = z.object({
  body: zLayerOverridesPatchDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Add Layer Overrides Success
 */
export const zPatchConsoleV1LayersByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerOverridesDto),
  }),
)

export const zPostConsoleV1LayersByIdOverridesData = z.object({
  body: zLayerOverridesDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Layer Overrides Success
 */
export const zPostConsoleV1LayersByIdOverridesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zLayerOverridesDto),
  }),
)

export const zGetConsoleV1MetricsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    id: z.string(),
    date: z.string(),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get metric data on given date response
 */
export const zGetConsoleV1MetricsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zMetricValuesDto)),
  }),
)

export const zPostConsoleV1MetricsData = z.object({
  body: zMetricCreationContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create metric response
 */
export const zPostConsoleV1MetricsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalMetricDefinitionContractDto),
  }),
)

export const zDeleteConsoleV1MetricsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete metric response
 */
export const zDeleteConsoleV1MetricsByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1MetricsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Metric Definition response
 */
export const zGetConsoleV1MetricsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalMetricDefinitionContractDto),
  }),
)

export const zPostConsoleV1MetricsByIdData = z.object({
  body: zMetricsUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update metric response
 */
export const zPostConsoleV1MetricsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zExternalMetricDefinitionContractDto),
  }),
)

export const zPutConsoleV1MetricsByIdCancelArchiveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Cancel archive metric response
 */
export const zPutConsoleV1MetricsByIdCancelArchiveResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1MetricsByIdExperimentsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      layerID: z.optional(z.string()),
      idType: z.optional(z.string()),
      teamID: z.optional(z.union([z.string(), z.null()])),
      status: z.optional(
        z.union([
          z.literal('active'),
          z.literal('setup'),
          z.literal('decision_made'),
          z.literal('abandoned'),
          z.literal('archived'),
          z.literal('experiment_stopped'),
          z.literal('assignment_stopped'),
          z.array(
            z.enum([
              'active',
              'setup',
              'decision_made',
              'abandoned',
              'archived',
              'experiment_stopped',
              'assignment_stopped',
            ]),
          ),
        ]),
      ),
      targetAppID: z.optional(z.string()),
      creatorName: z.optional(z.union([z.string(), z.null()])),
      creatorID: z.optional(z.union([z.string(), z.null()])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List experinments using metric response
 */
export const zGetConsoleV1MetricsByIdExperimentsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalExperimentDto)),
  }),
)

export const zPostConsoleV1MetricsByIdReloadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      incremental: z.optional(z.enum(['true', 'false'])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Reload metric data response
 */
export const zPostConsoleV1MetricsByIdReloadResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1MetricsByIdScheduleArchiveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Schedule a metric archive
 */
export const zPutConsoleV1MetricsByIdScheduleArchiveResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1MetricsByIdUnarchiveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Unarchive metric response
 */
export const zPutConsoleV1MetricsByIdUnarchiveResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1MetricsListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      showHiddenMetrics: z.optional(z.enum(['true', 'false'])),
      tags: z.optional(z.union([z.string(), z.array(z.string())])),
      filters: z.optional(z.string()),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List all metrics in the project response
 */
export const zGetConsoleV1MetricsListResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalMetricDefinitionContractDto)),
  }),
)

export const zPostConsoleV1MetricsMetricSourceData = z.object({
  body: zMetricSourceCreationContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create metric source response
 */
export const zPostConsoleV1MetricsMetricSourceResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zDeleteConsoleV1MetricsMetricSourceByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete metric source response
 */
export const zDeleteConsoleV1MetricsMetricSourceByNameResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1MetricsMetricSourceByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read metric source response
 */
export const zGetConsoleV1MetricsMetricSourceByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zPostConsoleV1MetricsMetricSourceByNameData = z.object({
  body: zMetricSourceUpdateContractDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update metric source response
 */
export const zPostConsoleV1MetricsMetricSourceByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zMetricSourceContractDto),
  }),
)

export const zGetConsoleV1MetricsMetricSourceByNameMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read metric source metrics response
 */
export const zGetConsoleV1MetricsMetricSourceByNameMetricsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zExternalMetricDefinitionContractDto)),
  }),
)

export const zGetConsoleV1MetricsMetricSourceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List metric source response
 */
export const zGetConsoleV1MetricsMetricSourceListResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zMetricSourceContractDto)),
  }),
)

export const zGetConsoleV1MetricsValuesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    date: z.string(),
    metricName: z.optional(z.string()),
    metricType: z.optional(z.string()),
    limit: z.optional(z.union([z.string(), z.number()])),
    page: z.optional(z.union([z.string(), z.number()])),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List All Metric Values Response
 */
export const zGetConsoleV1MetricsValuesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zMetricValueDto)),
  }),
)

export const zGetConsoleV1ParamStoresData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List param stores
 */
export const zGetConsoleV1ParamStoresResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zParamStoreDto)),
  }),
)

export const zPostConsoleV1ParamStoresData = z.object({
  body: zParamStoreCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create param store
 */
export const zPostConsoleV1ParamStoresResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zParamStoreDto),
  }),
)

export const zGetConsoleV1ParamStoresByNameData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get param store
 */
export const zGetConsoleV1ParamStoresByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zParamStoreDto),
  }),
)

export const zPostConsoleV1ParamStoresByNameData = z.object({
  body: zParamStoreUpdateDto,
  path: z.object({
    name: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update param store
 */
export const zPostConsoleV1ParamStoresByNameResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zParamStoreDto),
  }),
)

export const zGetConsoleV1ProjectData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Project Info
 */
export const zGetConsoleV1ProjectResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zProjectDto),
  }),
)

export const zGetConsoleV1ProjectUsageBillingReportData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    start: z.optional(z.int().gte(0)),
    end: z.int().gt(0),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Report URL generated successfully
 */
export const zGetConsoleV1ProjectUsageBillingReportResponse = z.string()

export const zGetConsoleV1ReleasePipelineTriggersData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      releasePipelineID: z.optional(z.string()),
      gateID: z.optional(z.string()),
      dynamicConfigID: z.optional(z.string()),
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List pipeline triggers success
 */
export const zGetConsoleV1ReleasePipelineTriggersResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zReleasePipelineTriggerResponseDto)),
  }),
)

export const zGetConsoleV1ReleasePipelineTriggersByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get pipeline trigger success
 */
export const zGetConsoleV1ReleasePipelineTriggersByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdAbortData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Aborted pipeline trigger successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdAbortResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdApproveData = z.object({
  body: zReleasePipelineTriggerActionBodyDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Approved pipeline trigger phase successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdApproveResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdPauseData = z.object({
  body: zReleasePipelineTriggerActionBodyDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Paused pipeline trigger successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdPauseResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdRolloutData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Fully rolled out pipeline trigger successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdRolloutResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdSkipData = z.object({
  body: zReleasePipelineTriggerActionBodyDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Skipped pipeline trigger phase successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdSkipResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zPutConsoleV1ReleasePipelineTriggersByIdUnpauseData = z.object({
  body: zReleasePipelineTriggerActionBodyDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Unpaused pipeline trigger successfully
 */
export const zPutConsoleV1ReleasePipelineTriggersByIdUnpauseResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineTriggerResponseDto),
  }),
)

export const zGetConsoleV1ReleasePipelinesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List pipelines
 */
export const zGetConsoleV1ReleasePipelinesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zReleasePipelineDto)),
  }),
)

export const zPostConsoleV1ReleasePipelinesData = z.object({
  body: zReleasePipelineCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create pipeline
 */
export const zPostConsoleV1ReleasePipelinesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineDto),
  }),
)

export const zDeleteConsoleV1ReleasePipelinesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete pipeline
 */
export const zDeleteConsoleV1ReleasePipelinesByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1ReleasePipelinesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get pipeline
 */
export const zGetConsoleV1ReleasePipelinesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineDto),
  }),
)

export const zPostConsoleV1ReleasePipelinesByIdData = z.object({
  body: zReleasePipelineUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update pipeline
 */
export const zPostConsoleV1ReleasePipelinesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReleasePipelineDto),
  }),
)

export const zGetConsoleV1ReportsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    type: z.enum(['first_exposures', 'pulse_daily', 'topline_impact_daily']),
    date: z.string(),
  }),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Reports
 */
export const zGetConsoleV1ReportsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zReportDto),
  }),
)

export const zGetConsoleV1RolesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Roles Response
 */
export const zGetConsoleV1RolesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zRoleContractDto)),
  }),
)

export const zPostConsoleV1RolesData = z.object({
  body: zRoleContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Role Response
 */
export const zPostConsoleV1RolesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zRoleContractDto),
  }),
)

export const zDeleteConsoleV1RolesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Role Response
 */
export const zDeleteConsoleV1RolesByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1RolesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Role Response
 */
export const zGetConsoleV1RolesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zRoleContractDto),
  }),
)

export const zPatchConsoleV1RolesByIdData = z.object({
  body: zRoleUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Role Response
 */
export const zPatchConsoleV1RolesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zRoleContractDto),
  }),
)

export const zGetConsoleV1SegmentsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Segments Success
 */
export const zGetConsoleV1SegmentsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zSegmentDto)),
  }),
)

export const zPostConsoleV1SegmentsData = z.object({
  body: zSegmentCreateContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Segment Success
 */
export const zPostConsoleV1SegmentsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSegmentDto),
  }),
)

export const zDeleteConsoleV1SegmentsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Segment Success
 */
export const zDeleteConsoleV1SegmentsByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1SegmentsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Segment Success
 */
export const zGetConsoleV1SegmentsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSegmentDto),
  }),
)

export const zPatchConsoleV1SegmentsByIdAddIdsData = z.object({
  body: zSegmentIdListUserStoreContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * User Store ID List updated successfully.
 */
export const zPatchConsoleV1SegmentsByIdAddIdsResponse = z.object({
  message: z.optional(z.string()),
})

export const zPutConsoleV1SegmentsByIdArchiveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Archive Segment Success
 */
export const zPutConsoleV1SegmentsByIdArchiveResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSegmentDto),
  }),
)

export const zPostConsoleV1SegmentsByIdConditionalData = z.object({
  body: zSegmentRulesDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Rules Successfully Updated
 */
export const zPostConsoleV1SegmentsByIdConditionalResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSegmentDto),
  }),
)

export const zDeleteConsoleV1SegmentsByIdIdListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Segment ids deleted successfully.
 */
export const zDeleteConsoleV1SegmentsByIdIdListResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1SegmentsByIdIdListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * IDs read successfully
 */
export const zGetConsoleV1SegmentsByIdIdListResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(zIdListDto),
  }),
)

export const zPatchConsoleV1SegmentsByIdIdListData = z.object({
  body: zSegmentIdListContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Segment ids updated successfully.
 */
export const zPatchConsoleV1SegmentsByIdIdListResponse = z.object({
  message: z.optional(z.string()),
})

export const zPostConsoleV1SegmentsByIdIdListResetData = z.object({
  body: zSegmentIdListResetContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Reset ID List Segment Success
 */
export const zPostConsoleV1SegmentsByIdIdListResetResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1SegmentsByIdIdlistMetadataData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * ID List metadata read successfully
 */
export const zGetConsoleV1SegmentsByIdIdlistMetadataResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zIdListMetadataDto),
  }),
)

export const zPatchConsoleV1SegmentsByIdRemoveIdsData = z.object({
  body: zSegmentIdListUserStoreContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * User Store ID List updated successfully.
 */
export const zPatchConsoleV1SegmentsByIdRemoveIdsResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1SettingsProjectData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Project Settings Response
 */
export const zGetConsoleV1SettingsProjectResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsProjectContractDto),
  }),
)

export const zPostConsoleV1SettingsProjectData = z.object({
  body: zSettingsProjectContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Project Settings Response
 */
export const zPostConsoleV1SettingsProjectResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsProjectContractDto),
  }),
)

export const zGetConsoleV1SettingsReviewsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Reviews Settings Response
 */
export const zGetConsoleV1SettingsReviewsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsReviewsContractDto),
  }),
)

export const zPostConsoleV1SettingsReviewsData = z.object({
  body: zSettingsReviewsContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Reviews Settings Response
 */
export const zPostConsoleV1SettingsReviewsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsReviewsContractDto),
  }),
)

export const zGetConsoleV1SettingsRolesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Roles Settings Response
 */
export const zGetConsoleV1SettingsRolesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsRolesContractDto),
  }),
)

export const zPostConsoleV1SettingsRolesData = z.object({
  body: zSettingsRolesContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Roles Settings Response
 */
export const zPostConsoleV1SettingsRolesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsRolesContractDto),
  }),
)

export const zGetConsoleV1SettingsTeamsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Teams Settings Response
 */
export const zGetConsoleV1SettingsTeamsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsTeamsContractDto),
  }),
)

export const zPostConsoleV1SettingsTeamsData = z.object({
  body: zSettingsTeamsContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Teams Settings Response
 */
export const zPostConsoleV1SettingsTeamsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zSettingsTeamsContractDto),
  }),
)

export const zGetConsoleV1TagsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Tags Success
 */
export const zGetConsoleV1TagsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zTagDto)),
  }),
)

export const zPostConsoleV1TagsData = z.object({
  body: zTagCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Tag Response
 */
export const zPostConsoleV1TagsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTagDto),
  }),
)

export const zDeleteConsoleV1TagsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete tag response
 */
export const zDeleteConsoleV1TagsByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1TagsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Tag Success
 */
export const zGetConsoleV1TagsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTagDto),
  }),
)

export const zPatchConsoleV1TagsByIdData = z.object({
  body: zTagUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Tag Response
 */
export const zPatchConsoleV1TagsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTagDto),
  }),
)

export const zGetConsoleV1TargetAppData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Target Apps Success
 */
export const zGetConsoleV1TargetAppResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zTargetAppDto)),
  }),
)

export const zPatchConsoleV1TargetAppData = z.object({
  body: zBulkAssignConfigTargetAppDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Bulk Assign Target Apps Success
 */
export const zPatchConsoleV1TargetAppResponse = z.object({
  message: z.optional(z.string()),
})

export const zPostConsoleV1TargetAppData = z.object({
  body: zTargetAppCreateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Target App Success
 */
export const zPostConsoleV1TargetAppResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTargetAppDto),
  }),
)

export const zDeleteConsoleV1TargetAppByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Target App Success
 */
export const zDeleteConsoleV1TargetAppByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1TargetAppByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Read Target App Success
 */
export const zGetConsoleV1TargetAppByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTargetAppDto),
  }),
)

export const zPatchConsoleV1TargetAppByIdData = z.object({
  body: zUpdateTargetAppDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Target App Success
 */
export const zPatchConsoleV1TargetAppByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1UnitIdTypesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List Unit ID Types Response
 */
export const zGetConsoleV1UnitIdTypesResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zUnitIdTypeContractDto)),
  }),
)

export const zPostConsoleV1UnitIdTypesData = z.object({
  body: zUnitIdTypeContractDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create Unit ID Type Response
 */
export const zPostConsoleV1UnitIdTypesResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zUnitIdTypeContractDto),
  }),
)

export const zDeleteConsoleV1UnitIdTypesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete Unit ID Type Response
 */
export const zDeleteConsoleV1UnitIdTypesByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1UnitIdTypesByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get Unit ID Type Response
 */
export const zGetConsoleV1UnitIdTypesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zUnitIdTypeContractDto),
  }),
)

export const zPatchConsoleV1UnitIdTypesByIdData = z.object({
  body: zUnitIdTypeUpdateContractDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update Unit ID Type Response
 */
export const zPatchConsoleV1UnitIdTypesByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zUnitIdTypeContractDto),
  }),
)

export const zGetConsoleV1UsersData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * List users response
 */
export const zGetConsoleV1UsersResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zUserContractDto)),
  }),
)

export const zGetConsoleV1UsersByEmailData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    email: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get user response
 */
export const zGetConsoleV1UsersByEmailResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zUserContractDto),
  }),
)

export const zPostConsoleV1UsersByEmailData = z.object({
  body: zUserUpdateDto,
  path: z.object({
    email: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update user response
 */
export const zPostConsoleV1UsersByEmailResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zUserContractDto),
  }),
)

export const zPostConsoleV1UsersInviteData = z.object({
  body: zUserInvitesDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Invite user response
 */
export const zPostConsoleV1UsersInviteResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1UsersTeamsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z.optional(z.union([z.string(), z.number()])),
      page: z.optional(z.union([z.string(), z.number()])),
    }),
  ),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get teams response
 */
export const zGetConsoleV1UsersTeamsResponse = zPaginationResponseWithMessage.and(
  z.object({
    data: z.optional(z.array(zTeamDto)),
  }),
)

export const zPostConsoleV1UsersTeamsData = z.object({
  body: zTeamCreationDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Create team response
 */
export const zPostConsoleV1UsersTeamsResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTeamDto),
  }),
)

export const zDeleteConsoleV1UsersTeamsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Delete team response
 */
export const zDeleteConsoleV1UsersTeamsByIdResponse = z.object({
  message: z.optional(z.string()),
})

export const zGetConsoleV1UsersTeamsByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Get team response
 */
export const zGetConsoleV1UsersTeamsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTeamDto),
  }),
)

export const zPatchConsoleV1UsersTeamsByIdData = z.object({
  body: zTeamPartialUpdateDto,
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Update team response
 */
export const zPatchConsoleV1UsersTeamsByIdResponse = zSingleDataResponse.and(
  z.object({
    data: z.optional(zTeamDto),
  }),
)

export const zPatchConsoleV1WhConnectionsData = z.object({
  body: zWhConnectionUpdateDto,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      'x-respect-review-settings': z.optional(z.string()),
    }),
  ),
})

/**
 * Connection updated successfully
 */
export const zPatchConsoleV1WhConnectionsResponse = z.object({
  message: z.optional(z.string()),
})
